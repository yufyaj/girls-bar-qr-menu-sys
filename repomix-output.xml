This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
__tests__/api/menu-categories/delete.test.ts
.augment-guidelines
.cursorrules
.env.example
.gitignore
app/api/auth/login/route.ts
app/api/auth/user/route.ts
app/api/casts/[id]/route.ts
app/api/casts/route.ts
app/api/checkout/[session_id]/route.ts
app/api/dashboard/sessions/route.ts
app/api/logout/route.ts
app/api/menu-categories/[category_id]/route.ts
app/api/menu-categories/route.ts
app/api/menus/[id]/route.ts
app/api/menus/route.ts
app/api/order-items/[order_item_id]/route.ts
app/api/order-items/[order_item_id]/status/route.ts
app/api/orders/[order_id]/items/route.ts
app/api/orders/[order_id]/status/route.ts
app/api/orders/active-items/route.ts
app/api/orders/active/route.ts
app/api/orders/route.ts
app/api/proxy-order/active-tables/route.ts
app/api/seat-types/[id]/route.ts
app/api/seat-types/route.ts
app/api/sessions/[session_id]/calculate-charge/route.ts
app/api/sessions/[session_id]/move/route.ts
app/api/sessions/[session_id]/orders/route.ts
app/api/sessions/[session_id]/route.ts
app/api/sessions/[session_id]/store-info/route.ts
app/api/sessions/active/route.ts
app/api/smaregi-products/route.ts
app/api/smaregi-sync/route.ts
app/api/stores/[store_id]/route.ts
app/api/stores/route.ts
app/api/stores/settings/route.ts
app/api/stores/settings/smaregi-status/route.ts
app/api/tables/[table_id]/menus/route.ts
app/api/tables/[table_id]/route.ts
app/api/tables/[table_id]/sessions/[session_id]/pause/route.ts
app/api/tables/[table_id]/sessions/[session_id]/resume/route.ts
app/api/tables/[table_id]/sessions/[session_id]/route.ts
app/api/tables/[table_id]/sessions/route.ts
app/api/tables/route.ts
app/api/upload/menu-image/route.ts
app/globals.css
app/layout.tsx
app/login/[store_code]/login-form.tsx
app/login/[store_code]/page.tsx
app/menu/[table_id]/cart-context.tsx
app/menu/[table_id]/cart-display.tsx
app/menu/[table_id]/cart-modal.tsx
app/menu/[table_id]/cast-select-modal.tsx
app/menu/[table_id]/cast-selection.tsx
app/menu/[table_id]/checkout-complete.tsx
app/menu/[table_id]/checkout-display.tsx
app/menu/[table_id]/checkout-modal.tsx
app/menu/[table_id]/client-customer-selection.tsx
app/menu/[table_id]/client-menu-page.tsx
app/menu/[table_id]/customer-type-selection.tsx
app/menu/[table_id]/header-with-menu-button.tsx
app/menu/[table_id]/menu-display.tsx
app/menu/[table_id]/menu-page-wrapper.tsx
app/menu/[table_id]/modal.tsx
app/menu/[table_id]/page.tsx
app/menu/[table_id]/seat-selection.tsx
app/page.tsx
app/portal/casts/[id]/edit/page.tsx
app/portal/casts/cast-form.tsx
app/portal/casts/delete-button.tsx
app/portal/casts/new/page.tsx
app/portal/casts/page.tsx
app/portal/components/header.tsx
app/portal/components/layout-wrapper.tsx
app/portal/components/side-menu.tsx
app/portal/dashboard/dashboard-client.tsx
app/portal/dashboard/page.tsx
app/portal/layout.tsx
app/portal/menu-categories/category-list.tsx
app/portal/menu-categories/page.tsx
app/portal/menus/[id]/edit/page.tsx
app/portal/menus/menu-form.tsx
app/portal/menus/menu-list.tsx
app/portal/menus/new/page.tsx
app/portal/menus/page.tsx
app/portal/menus/smaregi-sync-button.tsx
app/portal/order-board/order-board-client.tsx
app/portal/order-board/order-board.tsx
app/portal/order-board/page.tsx
app/portal/proxy-order/cart.tsx
app/portal/proxy-order/cast-select-modal.tsx
app/portal/proxy-order/menu-display.tsx
app/portal/proxy-order/page.tsx
app/portal/proxy-order/table-selector.tsx
app/portal/seat-types/_components/seat-type-form.tsx
app/portal/seat-types/[id]/edit/page.tsx
app/portal/seat-types/new/page.tsx
app/portal/seat-types/page.tsx
app/portal/store-settings/page.tsx
app/portal/store-settings/settings-form.tsx
app/portal/tables/_components/charge-control-button.tsx
app/portal/tables/_components/table-form.tsx
app/portal/tables/_components/table-move-button.tsx
app/portal/tables/[table_id]/edit/page.tsx
app/portal/tables/new/page.tsx
app/portal/tables/page.tsx
app/portal/tables/tables-client.tsx
docs/migration-guide.md
docs/スマレジ連携設定.md
docs/メニュー画像アップロード.md
docs/実装計画書.md
docs/進捗管理.md
docs/設計書.md
docs/要件定義書.md
fix_next_event_after_move_null.sql
fix_next_event_after_move_property_access.sql
lib/auth.ts
lib/charge.ts
lib/database.types.ts
lib/smaregi.ts
lib/supabase-realtime.ts
lib/supabase.ts
middleware.ts
next-env.d.ts
next.config.js
package.json
postcss.config.js
scripts/run-migration.js
scripts/seed.ts
supabase/.temp/cli-latest
supabase/.temp/gotrue-version
supabase/.temp/pooler-url
supabase/.temp/postgres-version
supabase/.temp/project-ref
supabase/.temp/rest-version
supabase/.temp/storage-version
supabase/config.toml
supabase/migrations/20250428000000_initial_schema.sql
supabase/migrations/20250428000001_rls_policies.sql
supabase/migrations/20250428000002_charge_functions.sql
supabase/migrations/20250428000003_audit_triggers.sql
supabase/migrations/20250428000004_report_views.sql
supabase/migrations/20250428000007_audit_triggers_fix.sql
supabase/migrations/20250428000008_audit_triggers_toggle.sql
supabase/migrations/20250430000000_add_store_id_to_seat_types.sql
supabase/migrations/20250501000000_add_store_settings.sql
supabase/migrations/20250502000000_add_display_name_to_store_users.sql
supabase/migrations/20250503000000_add_smaregi_keys.sql
supabase/migrations/20250504000000_add_smaregi_contract_id.sql
supabase/migrations/20250601000000_add_menu_categories.sql
supabase/migrations/20250601000001_migrate_menu_categories.sql
supabase/migrations/20250602000000_remove_staff_drink.sql
supabase/migrations/20250603000000_add_smaregi_category_id.sql
supabase/migrations/20250604000000_add_category_treat_cast_flag.sql
supabase/migrations/20250610000000_add_menu_images_bucket.sql
supabase/migrations/20250701000000_add_status_to_order_items.sql
supabase/migrations/20250702000000_update_seat_types_code_to_uuid.sql
supabase/migrations/20250703000003_recreate_seat_types_table.sql
supabase/migrations/20250703000004_fix_sessions_foreign_key.sql
supabase/migrations/20250704000000_add_time_unit_minutes_to_seat_types.sql
supabase/migrations/20250705000000_rename_price_per_30min_to_price_per_unit.sql
supabase/migrations/20250706000000_update_charge_functions.sql
supabase/migrations/20250707000000_update_charge_functions_time_unit.sql
supabase/migrations/20250707000001_update_table_usage_view.sql
supabase/migrations/20250708000000_update_sessions_table.sql
supabase/migrations/20250801000000_add_charge_pause.sql
supabase/migrations/20250802000000_add_table_move_charge.sql
supabase/migrations/20250803000000_fix_table_move_charge_calculation.sql
supabase/migrations/20250804000000_fix_charge_calculation_for_short_time.sql
supabase/migrations/20250805000000_fix_table_move_charge_calculation.sql
supabase/migrations/20250806000000_fix_double_charge_calculation.sql
supabase/migrations/20250807000000_fix_table_move_zero_minute_charge.sql
supabase/migrations/20250808000000_fix_table_move_immediate_charge.sql
supabase/migrations/20250809000000_fix_table_move_charge_calculation_final.sql
supabase/migrations/20250810000000_fix_table_move_minimum_charge.sql
supabase/migrations/20250811000000_fix_table_move_time_progression.sql
supabase/migrations/20250812000000_fix_next_event_after_move_null.sql
supabase/migrations/20250813000000_fix_next_event_after_move_null_robust.sql
supabase/migrations/20250814000000_fix_next_event_after_move_property_access.sql
supabase/migrations/20250815000000_add_smaregi_product_id_to_seat_types.sql
supabase/migrations/20250816000000_add_tax_rate_to_stores.sql
tailwind.config.js
tsconfig.json
tsconfig.scripts.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/sessions/[session_id]/store-info/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ session_id: string }> }
) {
  try {
    const { session_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッション情報を取得
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select('store_id')
      .eq('session_id', session_id)
      .single();

    if (sessionError || !session) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 店舗情報を取得
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('store_id, name, tax_rate')
      .eq('store_id', session.store_id)
      .single();

    if (storeError || !store) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 404 }
      );
    }

    return NextResponse.json(store);
  } catch (error) {
    console.error('店舗情報取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/smaregi-products/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient } from '@/lib/supabase';
import { getSmaregiAccessToken, fetchSmaregiProducts } from '@/lib/smaregi';

export async function GET(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗情報を取得
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('enable_smaregi_integration, smaregi_client_id, smaregi_client_secret, smaregi_contract_id')
      .eq('store_id', storeId)
      .single();

    if (storeError) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // スマレジ連携が無効の場合はエラー
    if (!store.enable_smaregi_integration) {
      return NextResponse.json(
        { error: 'スマレジ連携が無効になっています' },
        { status: 403 }
      );
    }

    // スマレジAPIの認証情報が設定されていない場合はエラー
    if (!store.smaregi_client_id || !store.smaregi_client_secret || !store.smaregi_contract_id) {
      return NextResponse.json(
        { error: 'スマレジAPIの認証情報が設定されていません' },
        { status: 400 }
      );
    }

    // スマレジAPIのアクセストークンを取得
    const accessToken = await getSmaregiAccessToken(
      store.smaregi_client_id,
      store.smaregi_client_secret,
      store.smaregi_contract_id
    );

    // スマレジAPIから商品情報を取得
    const products = await fetchSmaregiProducts(accessToken, store.smaregi_contract_id);

    // 商品情報を整形
    const formattedProducts = products.map(product => ({
      productId: product.productCode,
      name: product.productName,
      price: parseInt(product.price, 10)
    }));

    return NextResponse.json({
      products: formattedProducts
    });
  } catch (error) {
    console.error('スマレジ商品取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stores/settings/smaregi-status/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗情報を取得
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('enable_smaregi_integration')
      .eq('store_id', storeId)
      .single();

    if (storeError) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      enabled: store.enable_smaregi_integration
    });
  } catch (error) {
    console.error('スマレジ連携状態取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/portal/store-settings/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import SettingsForm from './settings-form';

export default async function StoreSettingsPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    redirect('/login');
  }

  // 店舗情報を取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報の取得に失敗しました</div>;
  }

  const store = await storeResponse.json();

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">店舗設定</h1>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <SettingsForm
              storeId={store.store_id}
              enableSmaregiIntegration={store.enable_smaregi_integration}
              smaregiClientId={store.smaregi_client_id || ''}
              smaregiClientSecret={store.smaregi_client_secret || ''}
              smaregiContractId={store.smaregi_contract_id || ''}
              taxRate={store.tax_rate || 10.0}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/store-settings/settings-form.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface SettingsFormProps {
  storeId: string;
  enableSmaregiIntegration: boolean;
  smaregiClientId?: string;
  smaregiClientSecret?: string;
  smaregiContractId?: string;
  taxRate?: number;
}

export default function SettingsForm({
  storeId,
  enableSmaregiIntegration,
  smaregiClientId = '',
  smaregiClientSecret = '',
  smaregiContractId = '',
  taxRate = 10.0,
}: SettingsFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const [settings, setSettings] = useState({
    enableSmaregiIntegration,
    smaregiClientId,
    smaregiClientSecret,
    smaregiContractId,
    taxRate,
  });

  const handleToggle = () => {
    setSettings({
      ...settings,
      enableSmaregiIntegration: !settings.enableSmaregiIntegration,
    });
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;

    // 数値フィールドの場合は数値に変換
    if (name === 'taxRate') {
      const numValue = parseFloat(value);
      if (!isNaN(numValue)) {
        setSettings({
          ...settings,
          [name]: numValue,
        });
      }
    } else {
      setSettings({
        ...settings,
        [name]: value,
      });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      // スマレジ連携が有効な場合、クライアントID、シークレット、契約IDが必要
      if (settings.enableSmaregiIntegration &&
          (!settings.smaregiClientId || !settings.smaregiClientSecret || !settings.smaregiContractId)) {
        setError('スマレジ連携を有効にする場合は、クライアントID、シークレット、契約IDが必要です');
        setIsLoading(false);
        return;
      }

      // 消費税率のバリデーション
      if (settings.taxRate < 0 || settings.taxRate > 100) {
        setError('消費税率は0〜100の範囲で入力してください');
        setIsLoading(false);
        return;
      }

      const response = await fetch('/api/stores/settings', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          enable_smaregi_integration: settings.enableSmaregiIntegration,
          smaregi_client_id: settings.smaregiClientId,
          smaregi_client_secret: settings.smaregiClientSecret,
          smaregi_contract_id: settings.smaregiContractId,
          tax_rate: settings.taxRate,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '設定の更新に失敗しました');
      }

      setSuccess('設定が正常に更新されました');
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="rounded-md bg-red-50 p-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">エラー</h3>
              <div className="mt-2 text-sm text-red-700">
                <p>{error}</p>
              </div>
            </div>
          </div>
        </div>
      )}

      {success && (
        <div className="rounded-md bg-green-50 p-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-green-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-medium text-green-800">{success}</p>
            </div>
          </div>
        </div>
      )}

      <div>
        <h2 className="text-lg font-medium text-gray-900">基本設定</h2>
        <div className="mt-4">
          <label htmlFor="taxRate" className="block text-sm font-medium text-gray-700">
            消費税率 (%)
          </label>
          <div className="mt-1 relative rounded-md shadow-sm w-32">
            <input
              type="number"
              name="taxRate"
              id="taxRate"
              min="0"
              max="100"
              step="0.1"
              value={settings.taxRate}
              onChange={handleInputChange}
              className="focus:ring-blue-500 focus:border-blue-500 block w-full pr-8 sm:text-sm border-gray-300 rounded-md"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
              <span className="text-gray-500 sm:text-sm">%</span>
            </div>
          </div>
          <p className="mt-1 text-sm text-gray-500">
            会計時に適用される消費税率を設定します。
          </p>
        </div>
      </div>

      <div className="pt-6 border-t border-gray-200 mt-6">
        <h2 className="text-lg font-medium text-gray-900">スマレジ連携設定</h2>
        <div className="mt-4 space-y-4">
          <div className="flex items-start">
            <div className="flex items-center h-5">
              <input
                id="enableSmaregiIntegration"
                name="enableSmaregiIntegration"
                type="checkbox"
                checked={settings.enableSmaregiIntegration}
                onChange={handleToggle}
                className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
              />
            </div>
            <div className="ml-3 text-sm">
              <label htmlFor="enableSmaregiIntegration" className="font-medium text-gray-700">
                スマレジ連携
              </label>
              <p className="text-gray-500">
                スマレジとの連携機能を有効にします。無効にすると、スマレジへの会計データ送信が行われなくなります。
              </p>
            </div>
          </div>

          {settings.enableSmaregiIntegration && (
            <div className="mt-6 pl-7">
              <div className="grid grid-cols-1 gap-y-6 gap-x-4 sm:grid-cols-6">
                <div className="sm:col-span-3">
                  <label htmlFor="smaregiClientId" className="block text-sm font-medium text-gray-700">
                    クライアントID
                  </label>
                  <div className="mt-1">
                    <input
                      type="text"
                      name="smaregiClientId"
                      id="smaregiClientId"
                      value={settings.smaregiClientId}
                      onChange={handleInputChange}
                      className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                      placeholder="スマレジから提供されたクライアントID"
                    />
                  </div>
                </div>

                <div className="sm:col-span-3">
                  <label htmlFor="smaregiClientSecret" className="block text-sm font-medium text-gray-700">
                    クライアントシークレット
                  </label>
                  <div className="mt-1">
                    <input
                      type="password"
                      name="smaregiClientSecret"
                      id="smaregiClientSecret"
                      value={settings.smaregiClientSecret}
                      onChange={handleInputChange}
                      className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                      placeholder="スマレジから提供されたシークレット"
                    />
                  </div>
                </div>

                <div className="sm:col-span-3">
                  <label htmlFor="smaregiContractId" className="block text-sm font-medium text-gray-700">
                    契約ID
                  </label>
                  <div className="mt-1">
                    <input
                      type="text"
                      name="smaregiContractId"
                      id="smaregiContractId"
                      value={settings.smaregiContractId}
                      onChange={handleInputChange}
                      className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                      placeholder="スマレジの契約ID"
                    />
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="pt-5">
        <div className="flex justify-end">
          <button
            type="button"
            onClick={() => router.back()}
            className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            disabled={isLoading}
          >
            キャンセル
          </button>
          <button
            type="submit"
            className="ml-3 inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            disabled={isLoading}
          >
            {isLoading ? '保存中...' : '保存'}
          </button>
        </div>
      </div>
    </form>
  );
}
</file>

<file path="docs/スマレジ連携設定.md">
# スマレジ連携設定

## 概要

本システムはスマレジと連携することで、スマレジに登録されている商品情報を自動的に取り込み、メニューとして表示することができます。
また、会計時にはスマレジに対して会計データを送信することができます。

## 前提条件

- スマレジのアカウントを持っていること
- スマレジ・デベロッパーズに登録していること
- スマレジ・アプリマーケットでアプリを作成していること

## 設定手順

### 1. スマレジ・デベロッパーズでアプリを作成する

1. [スマレジ・デベロッパーズ](https://developers.smaregi.dev/)にログインします。
2. 「アプリを作成する」をクリックします。
3. アプリ名、説明、リダイレクトURIなどを入力し、アプリを作成します。
4. 作成後、クライアントIDとクライアントシークレットが表示されるので、メモしておきます。

### 2. 店舗設定画面でスマレジ連携を有効にする

1. 管理者アカウントでログインします。
2. 店舗設定画面に移動します。
3. 「スマレジ連携」を有効にします。
4. 以下の情報を入力します：
   - クライアントID: スマレジ・デベロッパーズで作成したアプリのクライアントID
   - クライアントシークレット: スマレジ・デベロッパーズで作成したアプリのクライアントシークレット
   - 契約ID: スマレジ・デベロッパーズの左上に表示されている契約ID
5. 「保存」をクリックします。

### 3. メニュー同期を実行する

1. 管理者アカウントでログインします。
2. メニュー管理画面に移動します。
3. 「スマレジと同期」ボタンをクリックします。
4. 同期が完了すると、スマレジに登録されている商品情報がメニューとして表示されます。

## 注意事項

- スマレジ連携が有効になっている場合、カテゴリとメニューの追加は本システム上ではできません。カテゴリやメニューを追加するには、スマレジ側で部門や商品を登録した後、「スマレジと同期」ボタンをクリックしてください。
- スマレジの商品情報を変更した場合は、再度同期を実行する必要があります。
- スマレジの部門情報はカテゴリとして取り込まれます。
- スマレジのオプション商品は「スタッフドリンク」として扱われます。
- スマレジの商品コードは本システムの商品IDとして使用されます。
- スマレジの商品画像は `/products/images` APIエンドポイントから一括取得され、本システムの商品画像URLとして使用されます。
- スマレジAPIのレスポンスに含まれる `url` または `imageUrl` プロパティから画像URLを取得します。
- 商品画像がスマレジに登録されていない場合は、画像なしとして表示されます。
- 同じ商品に複数の画像が登録されている場合は、最初の画像が使用されます。
- スマレジの画像を表示するには、`next.config.js`ファイルの`images.domains`に`pos-cache.smaregi.dev`と`pos-cache.smaregi.jp`を追加する必要があります。

## トラブルシューティング

### 同期に失敗する場合

- クライアントIDとクライアントシークレットが正しいか確認してください。
- 契約IDが正しいか確認してください。
- スマレジ連携が有効になっているか確認してください。
- ネットワーク接続を確認してください。

### 特定の商品が同期されない場合

- スマレジ側で商品が正しく登録されているか確認してください。
- 商品コードが重複していないか確認してください。
- 商品が非表示になっていないか確認してください。

### 商品画像が表示されない場合

- スマレジ側で商品画像が正しく登録されているか確認してください。
- `next.config.js`ファイルに`pos-cache.smaregi.dev`と`pos-cache.smaregi.jp`が追加されているか確認してください。
- 設定変更後はサーバーを再起動してください。
- ブラウザのコンソールでエラーメッセージを確認してください。

## APIリファレンス

スマレジAPIの詳細については、[スマレジ・プラットフォームAPI POS仕様書](https://www1.smaregi.dev/apidoc/)を参照してください。
</file>

<file path="docs/メニュー画像アップロード.md">
# メニュー画像アップロード機能

## 概要

メニュー（商品）の新規作成・編集画面から画像をアップロードし、Supabaseのストレージに保存する機能です。

## 機能詳細

1. メニュー編集画面で「画像を選択」ボタンをクリックすると、ファイル選択ダイアログが表示されます。
2. 画像ファイル（JPEG、PNG、WebP、GIF）を選択すると、自動的に適切なサイズにリサイズされます。
3. リサイズ後の画像がプレビュー表示されます（この時点ではまだアップロードされません）。
4. フォームの「追加」または「更新」ボタンをクリックすると、画像がアップロードされます。
5. 「画像を削除」ボタンをクリックすると、画像がクリアされます（ストレージからは削除されません）。

## 技術仕様

### 画像リサイズ

- 最大サイズ: 幅800px × 高さ800px
- アスペクト比: 元の画像のアスペクト比を維持
- 処理方法: クライアント側でCanvas APIを使用してリサイズ
- 画質: 90%（JPEG/WebPの場合）

### ストレージ設定

- バケット名: `menu-images`
- アクセス権限:
  - 閲覧: 誰でも可能
  - アップロード: 管理者のみ
  - 更新: 管理者のみ
  - 削除: 管理者のみ
- ファイル制限:
  - 最大サイズ: 5MB
  - 許可形式: JPEG, PNG, WebP, GIF

### APIエンドポイント

- URL: `/api/upload/menu-image`
- メソッド: POST
- リクエスト形式: multipart/form-data
- パラメータ:
  - `file`: アップロードする画像ファイル
- レスポンス:
  - 成功時: `{ url: "画像の公開URL" }`
  - エラー時: `{ error: "エラーメッセージ" }`

### ファイル命名規則

アップロードされたファイルは以下の命名規則で保存されます:

```
{store_id}/{uuid}.{extension}
```

- `store_id`: 店舗ID（UUID）
- `uuid`: ランダムに生成されたUUID（v4）
- `extension`: 元のファイルの拡張子（jpg, png, webp, gif など）

## 初期設定

### Supabaseストレージバケットの作成

初回利用時には、Supabaseのストレージバケットを作成する必要があります。APIは自動的にバケットの作成を試みますが、権限の問題で失敗する場合は手動で作成してください。

#### 手動でのバケット作成方法

1. Supabaseのダッシュボード（https://app.supabase.com）にログインします
2. プロジェクトを選択します
3. 左側のメニューから「Storage」を選択します
4. 「New Bucket」ボタンをクリックします
5. バケット名に「menu-images」を入力します
6. 「Public」チェックボックスをオンにします（公開バケットとして設定）
7. 「Create bucket」ボタンをクリックします

#### RLSポリシーの設定

バケットを作成した後、以下のRLSポリシーを設定します：

1. 作成したバケットの「Policies」タブをクリックします
2. 以下のポリシーを追加します：

- **閲覧ポリシー**:
  - 名前: メニュー画像は誰でも閲覧可能
  - 対象: SELECT
  - ポリシー: `true`（誰でも閲覧可能）

- **アップロードポリシー**:
  - 名前: 管理者のみメニュー画像をアップロード可能
  - 対象: INSERT
  - ポリシー: `EXISTS (SELECT 1 FROM public.store_users WHERE user_id = auth.uid() AND role = 'admin')`

- **更新ポリシー**:
  - 名前: 管理者のみメニュー画像を更新可能
  - 対象: UPDATE
  - ポリシー: `EXISTS (SELECT 1 FROM public.store_users WHERE user_id = auth.uid() AND role = 'admin')`

- **削除ポリシー**:
  - 名前: 管理者のみメニュー画像を削除可能
  - 対象: DELETE
  - ポリシー: `EXISTS (SELECT 1 FROM public.store_users WHERE user_id = auth.uid() AND role = 'admin')`

## 注意事項

1. 画像ファイルは5MB以下である必要があります。
2. 許可されているファイル形式は JPEG, PNG, WebP, GIF のみです。
3. 画像を削除してもストレージからは自動的に削除されません。不要な画像は定期的に管理者がクリーンアップする必要があります。
4. 初回利用時にバケットが存在しない場合、APIは自動的にバケットの作成を試みますが、権限の問題で失敗する場合があります。その場合は上記の手順でバケットを手動で作成してください。

## 今後の拡張予定

1. 不要画像の自動クリーンアップ
2. 画像の一括アップロード機能
3. 画像のクロップ・編集機能
4. 画像のリサイズサイズをユーザーが選択できる機能
</file>

<file path="docs/実装計画書.md">
# QRオーダー & 会計連携システム  
## **実装計画書** ― *v 2025-04-28 (Rev 1)*  
> 対象：詳細設計書 *Rev 6.2* に基づく実装フェーズ  
> 方針：**「機能を実装したら直後にテストコードをコミット」** を徹底し、CI パイプラインで順次自動検証する。  

---

## 1. 開発モデル概要

| 項目 | 採用方針 |
| :-- | :-- |
| **リポジトリ** | GitHub (monorepo) |
| **ブランチ運用** | <br>1. `main` … 常時デプロイ可能<br>2. `dev` … スプリント統合 (週次)<br>3. `feature/**` … 1 Issue = 1 PR |
| **コード規約** | ESLint + Prettier + Husky pre-commit |
| **CI** | GitHub Actions (lint → unit → api → e2e smoke) |
| **CD** | Vercel Preview (自動) → `main` マージで Prod |
| **テスト必須化** | **PR が通る条件**<br>‐ *新規／変更コード* に対応するテストが追加されている<br>‐ カバレッジ差分が低下しない |

---

## 2. 役割分担

| ロール | 主担当 | 備考 |
| :-- | :-- | :-- |
| **Tech Lead** | 加藤さん | レビュー方針／CI 設計 |
| **Backend** | A さん | Supabase SQL & Route Handlers |
| **Frontend** | B さん | RSC / Portal & Menu UI |
| **QA** | C さん | Playwright シナリオ／負荷試験 |
| **DevOps** | D さん | GitHub Actions / Vercel 環境 |

---

## 3. スプリント予定 (2 週間＝10 営業日)

| Sprint | 主要成果物 | 日程 | 完了判定 |
| :-: | :-- | :-- | :-- |
| **S0** | 開発環境セットアップ<br>CI / lint / test 雛形 | 4-28 – 5-02 | `main` に CI グリーン |
| **S1** | ⚙️ **Auth & RLS 基盤**<br> `/login/{store_code}` 画面 | 5-05 – 5-16 | QA: RLS 403/200 テスト完 |
| **S2** | 🪑 **テーブル CRUD + QR** (`/portal/tables`) | 5-19 – 5-30 | QR 画像生成 E2E 通過 |
| **S3** | 🍣 **QRメニュー v1** (`/menu/[table]`)<br> オフライン閲覧 | 6-02 – 6-13 | Workbox offline test |
| **S4** | 📦 **注文フロー & Kanban** | 6-16 – 6-27 | 2 ブラウザ同期 < 1 s |
| **S5** | 💰 **チャージ & 会計**<br> (`fn_calc_total_charge`) | 6-30 – 7-11 | 金額境界値 UT 100 % |
| **S6** | 📈 **レポート & エクスポート** | 7-14 – 7-25 | CSV 形式 QA 承認 |
| **S7** | 🔒 **負荷 & セキュリティ hardening** | 7-28 – 8-08 | k6 p95<300 ms / ZAP 0 高 |
| **S8** | 🚀 UAT & 本番リリース | 8-11 – 8-22 | UAT sign-off + Prod cut-over |

*バッファ*：8-25 – 8-29（緊急修正 & ドキュメント整備）

---

## 4. 機能別タスク‐テスト対応表

| モジュール / 画面 | 実装タスク (PR) | **直後に書くテスト** |
| :-- | :-- | :-- |
| **Auth** | `route.ts(login)` / `/api/login` | Supertest: 正常/403、CSRF |
| **StoreGuard** | Portal layout | Vitest: `hasRole()` 単体 |
| **SeatTypeForm** | CRUD UI + PATCH API | RTL + Vitest: バリデ・価格更新 |
| **Table QR** | QR PNG 生成 | Playwright: ダウンロード可否 |
| **Menu PWA** | `menu/layout.tsx` (SW) | Workbox integration test |
| **OrderBoard** | Kanban DnD + WS | Playwright: DnD → status 変化 |
| **Charge Logic** | `charge.ts` + SQL 関数 | Vitest: 0,29,30,31 分境界 |
| **Checkout** | `/api/checkout` + `/sales` | Supertest: 201 / Retry 3 |
| **Reports** | SQL View + CSV | Vitest: 集計合計、列順 |

---

## 5. 1 PR の流れ（共通フロー）

```mermaid
graph TD
  A(Fork feature/**) --> B(実装)
  B --> C(単体テスト追加)
  C --> D(API/E2E テスト追加)
  D --> E(Push → PR)
  E --> F(CI: lint & 全テスト)
  F -->|Green| G(コードレビュー)
  G -->|Approve| H(Merge → Preview)
  H --> I(QA smoke) -->|OK| J(main マージ)
```

---

## 6. カバレッジと品質ゲート

| テスト層 | ツール | 最低ライン (main) |
| :-- | :-- | :-- |
| Unit + API | Vitest + Supertest | **80 % line** |
| E2E | Playwright | コアシナリオ 100 % 通過 |
| Perf | k6 | p95 < 300 ms |
| Sec | ZAP Baseline | High 0 / Medium 0 |

*Codecov ⇢ GitHub PR status で “80 % 未満なら merge 禁止”。*

---

## 7. リスク & 対策

| リスク | インパクト | 対策 |
| :-- | :-- | :-- |
| Broadcast 遅延 > 1 s | 注文ステータスの食い違い | k6 + WebSocket 負荷テスト / 再送 ACK |
| `session_seat_events` 大量化 | 会計 SQL 遅延 | 複合 INDEX ＆ パーティション検証 |
| スマレジ API 障害 | 会計連携停止 | Retry 3 → Dead-letter + 管理UI エラー表示 |

---

## 8. コミュニケーション

- **デイリースタンドアップ**：Slack huddle (15 min)  
- **ウィークリーレビュー**：金曜午後・`dev` → `main` マージ判断  
- **仕様変更**：Issue → 設計書 Rev 更新 → 影響分析 → 合意後着手  

---

## 9. 付録：ラベル運用

| ラベル | 意味 |
| :-- | :-- |
| `feat` | 新機能 |
| `fix` | バグ修正 |
| `test` | テスト追加のみ |
| `chore` | CI / ドキュメント |
| `blocked` | 外部待ち |
| `urgent` | リリース前クリティカル |
</file>

<file path="docs/進捗管理.md">
### 1. スプリント全体サマリ

| Sprint | 期間 (2025) | 主要成果物 | 責任者 | Status | 備考 |
| :--: | :-- | :-- | :-- | :-- | :-- |
| S0 | 04-28 – 05-02 | 開発環境 / CI 雛形 | DevOps | ☑ In Progress | 基本構造・DB実装完了 |
| S1 | 05-05 – 05-16 | Auth & RLS 基盤 | Backend | ☑ In Progress | 認証・ミドルウェア実装中 |
| S2 | 05-19 – 05-30 | テーブル CRUD + QR | Frontend | ☐ Planned | テーブル・席種管理実装 |
| S3 | 06-02 – 06-13 | QR メニュー v1 (PWA) | Frontend | ☐ Planned | PWA Shell/UI実装 |
| S4 | 06-16 – 06-27 | 注文フロー & Kanban | Shared | ☐ Planned | 注文API/UI実装中 |
| S5 | 06-30 – 07-11 | チャージ & 会計 | Backend | ☐ Planned | 合算課金 |
| S6 | 07-14 – 07-25 | レポート & CSV | Backend | ☐ Planned | – |
| S7 | 07-28 – 08-08 | 負荷 & セキュリティ | QA | ☐ Planned | k6 / ZAP |
| S8 | 08-11 – 08-22 | UAT & リリース | 全員 | ☐ Planned | – |
| **Buffer** | 08-25 – 08-29 | 予備期間 | – | – | 緊急修正 |

---

### 2. Sprint ボード（チェックリスト形式）

#### S0 — 環境セットアップ

- [ ] **CI パイプライン**
  - [ ] lint ジョブ
  - [ ] unit / api テストジョブ
  - [ ] Playwright smoke
- [ ] **ESLint / Prettier / Husky**
  - [ ] ESLint設定
  - [ ] Prettier設定
  - [ ] Husky設定
- [x] **DB マイグレーション**
  - [x] テーブル定義
  - [x] RLS ポリシー
  - [x] チャージ計算関数
  - [x] シードスクリプト
- [ ] README に開発手順追記
- [ ] **レビュー** → merge → `main` で CI 緑

---

#### S1 — Auth & RLS

| タスク | Owener | Impl | Test | Review | Status |
| :-- | :-- | :--: | :--: | :--: | :-- |
| `/login/{code}` 画面 SSR | FE | ☑ | ☐ | ☐ | 実装完了 |
| `/api/login` Route | BE | ☑ | ☐ | ☐ | 実装完了 |
| `StoreGuard` ミドルウェア | FE | ☑ | ☐ | ☐ | 実装完了 |
| RLS ポリシー (`stores`, `orders` …) | BE | ☑ | ☐ | ☐ | 実装完了 |
| ポータル共通レイアウト | FE | ☑ | ☐ | ☐ | 実装完了 |
| Supertest: 200 / 403 | QA | – | ☐ | – | – |

---

#### S2 — テーブル CRUD + QR

| タスク | Impl | UT | E2E | Review | Status |
| :-- | :--: | :--: | :--: | :--: | :-- |
| `/portal/tables` CRUD UI | ☑ | ☐ | ☐ | ☐ | 実装完了 |
| `/portal/seat-types` CRUD UI | ☑ | ☐ | ☐ | ☐ | 実装完了 |
| QR PNG 生成 (qrcode pkg) | ☑ | ☐ | ☐ | ☐ | 実装完了 |
| Playwright: DL 検証 | – | – | ☐ | – | – |

---

#### S3 — QR メニュー (PWA)

- [x] `/menu/layout` PWA Shell
- [ ] Workbox SW 設定
- [ ] MenuList / Cart / Checkout UI
- [ ] RTL + Vitest コンポーネントテスト
- [ ] Offline/Online E2E

---

#### S4 — 注文フロー & Kanban

| タスク | Impl | UT | API | E2E | Review | Status |
| :-- | :--: | :--: | :--: | :--: | :--: | :-- |
| `OrderBoard.tsx` (DnD) | ☑ | ☐ | – | ☐ | ☐ | 実装完了 |
| `/api/orders/{id}/status` | ☑ | ☐ | ☐ | – | ☐ | 実装完了 |
| `/api/orders` (POST) | ☐ | ☐ | ☐ | – | ☐ | 未実装 |
| `OrderCard.tsx` | ☑ | ☐ | – | ☐ | ☐ | 実装完了 |
| Broadcast Channel 設定 | ☑ | ☐ | – | ☐ | ☐ | 実装完了 |

---

#### S5 — チャージ & 会計

- [ ] `fn_calc_total_charge` SQL
- [x] `charge.ts` ユーティリティ
- [ ] `/api/checkout` Route
- [ ] Unit: 境界値 0/29/30/31 分
- [ ] Supertest: `/sales` Mock
- [ ] Playwright: 完全会計シナリオ

---

#### S6 — レポート

- [ ] SQL View `v_daily_sales`
- [ ] `/portal/reports/[period]` UI
- [ ] CSV Export ボタン
- [ ] Vitest: 合計一致
- [ ] Playwright: DL & CSV 構造

---

#### S7 — Hardening

| 項目 | Owner | Status |
| :-- | :-- | :-- |
| k6 スクリプト (50 VU) | QA | ☐ |
| ZAP baseline Job | QA | ☐ |
| Broadcast 再送試験 | BE | ☐ |

---

### 3. テストカバレッジ目標トラッカー

| 週 | Lines % | Functions % | 状態 |
| :-- | :--: | :--: | :-- |
| S0 End | ≥ 40 | ≥ 40 | ☐ |
| S2 End | ≥ 60 | ≥ 60 | ☐ |
| S4 End | ≥ 70 | ≥ 70 | ☐ |
| **S5 End** | **≥ 80** | **≥ 80** | ☐ *(Merge gate)* |

---

### 4. カンバン用ラベル早見表

| ラベル | 色 | 目的 |
| :-- | :-- | :-- |
| `feat` | 🔵 | 新機能実装 |
| `test` | 🟢 | テスト追加のみ |
| `review-needed` | 🟡 | レビュー待ち |
| `blocked` | 🟥 | 外部依存で停止 |
| `urgent` | 🟣 | 本番前クリティカル |

---

## ✅ 運用メモ

- **毎日**：担当者は自タスクのチェックを更新し、Slack #dev-standup へ報告
- **毎 PR**：テストが未追加なら `bot/test-missing` ラベル → CI 失敗
- **スプリントレビュー**：進捗表を参照し未完タスクは翌スプリントへリスケ
</file>

<file path="docs/設計書.md">
# QRオーダー & 会計連携システム
## **詳細設計書** ― *v 2025-08-02 Rev 7.2*

## 0  変更履歴

| Rev | 日付 | 主要変更点 |
| :-- | :-- | :-- |
| 4 | 04-28 | Kanban UI／Broadcast／マルチテナント（JWT claim あり） |
| 5 | 04-28 | **席種変更スナップショット課金**（`session_seat_events`） |
| 6 | 04-28 | **JWT custom claim 排除**・権限は DB `store_users` 管理 |
| 6.1 | 04-28 | **`/login/{store_code}`** SSR + 店舗名表示・所属チェック |
| **6.2** | 04-28 | **ディレクトリを Portal (店側) / Menu (客側) に物理分離** |
| **6.3** | 05-01 | **店舗設定画面追加**・キャスト管理とスマレジ連携の有効/無効設定 |
| **6.4** | 05-01 | **キャスト管理画面追加**・スマレジ連携設定を別画面に分離 |
| **6.5** | 05-02 | **メニュー管理画面追加**・メニューのCRUDとスマレジ同期機能 |
| **6.6** | 05-03 | **スマレジ連携キー保存機能追加**・スマレジAPIキーの保存と管理 |
| **6.7** | 06-01 | **メニューカテゴリ管理機能追加**・カテゴリのCRUDと表示順管理 |
| **6.8** | 06-02 | **スタッフドリンク機能削除**・メニューからスタッフドリンク機能を削除 |
| **6.9** | 06-10 | **QRアクセス時のフロー改善**・座席選択→新規/指名選択→メニュー表示の流れを実装 |
| **7.0** | 06-15 | **代理注文機能追加**・キャスト/管理者が来店客の代わりに注文できる機能を実装 |
| **7.1** | 08-01 | **料金課金一時停止機能追加**・テーブル管理画面から料金課金を一時停止/再開できる機能を実装 |
| **7.2** | 08-02 | **リアルタイム更新機能強化**・ダッシュボード、注文ボード、テーブル管理画面のリアルタイム更新を実装 |

---

## 1  高レベル・アーキテクチャ

```
Browser (PWA)
│  ├─ /portal/**   ← キャスト・管理者
│  └─ /menu/**     ← 来店客 (offline capable)
│
│  React Server Components / SW
└──┬───────────────────────────
   │ Server Actions / fetch
┌──▼──────── BFF ────────────┐
│  Next.js Route Handlers      │  (認証＋RLS)
└──┬────────┬────────────────┘
   │ RPC    │ Broadcast/Realtime
┌──▼────────▼───────────────┐
│       Supabase (PG15)        │
└─────────────────────────────┘
```

- **/menu/** 側のみ Workbox でオフライン対応。
- Broadcast Channel `broadcast:orders` で Kanban 同期遅延 ≤ 1 s。
- Supabase Realtime サブスクリプションでダッシュボード、注文ボード、テーブル管理画面をリアルタイム更新。

---

## 2  認証・マルチテナント

| 項目 | 方針 |
| :-- | :-- |
| ログイン URL | **`/login/{store_code}`**（パラメータ必須） |
| 表示 | 店舗名を SSR しログイン画面に大見出し表示 |
| 認証 | Supabase Auth（メール＋パスワード） |
| 所属確認 | `store_users` に該当行がなければ **403** |
| JWT | **標準 claim のみ**（custom claim 0） |
| RLS | `store_id IN (SELECT store_id FROM store_users WHERE user_id = auth.uid())` |

---

## 3  データベース DDL（主要テーブル）

```sql
create table stores (
  store_id    uuid primary key default gen_random_uuid(),
  store_code  text unique not null,
  name        text not null,
  enable_cast_management boolean not null default true,
  enable_smaregi_integration boolean not null default true,
  smaregi_client_id text,
  smaregi_client_secret text,
  smaregi_contract_id text
);

create table store_users (
  id        uuid primary key default gen_random_uuid(),
  store_id  uuid references stores on delete cascade,
  user_id   uuid references auth.users on delete cascade,
  role      text check (role in ('admin','cast')) not null,
  display_name text
);

create table menu_categories (
  category_id uuid primary key default gen_random_uuid(),
  store_id uuid references stores on delete cascade not null,
  name text not null,
  display_order int not null default 0,
  unique(store_id, name)
);

create table seat_types (
  seat_type_id uuid primary key default gen_random_uuid(),
  store_id uuid references stores on delete cascade not null,
  display_name text not null,
  price_per_unit int not null,
  time_unit_minutes int not null default 30,
  unique(store_id, seat_type_id)
);

create table tables (
  table_id uuid primary key default gen_random_uuid(),
  store_id uuid references stores,
  name text,
  seat_type_id uuid references seat_types
);

create table sessions (
  session_id uuid primary key default gen_random_uuid(),
  store_id uuid references stores,
  table_id uuid references tables,
  start_at timestamptz default now(),
  charge_started_at timestamptz,
  charge_paused_at timestamptz,
  selected_cast_id uuid references auth.users(id),
  is_new_customer boolean
);

create table session_seat_events (
  event_id uuid primary key default gen_random_uuid(),
  session_id uuid references sessions on delete cascade,
  seat_type_id uuid references seat_types,
  price_snapshot int not null,
  changed_at timestamptz default now()
);

create table orders (
  order_id uuid primary key default gen_random_uuid(),
  store_id uuid references stores,
  session_id uuid references sessions,
  status text check (status in ('new','ack','prep','served','closed','cancel')),
  created_by_role text,
  proxy boolean default false,
  created_at timestamptz default now()
);
```

### RLS ポリシー例

```sql
create policy is_my_store on orders
  using (store_id in (select store_id from store_users where user_id = auth.uid()));

create policy seat_type_store_admin_all on seat_types
  using (store_id in (
    select store_id from store_users
    where user_id = auth.uid() and role = 'admin'
  ));

create policy seat_type_store_cast_select on seat_types
  for select
  using (store_id in (
    select store_id from store_users
    where user_id = auth.uid()
  ));
```

---

## 4  ビジネスロジック

### 4.1 席種変更 & スナップショット挿入

1. `/portal/tables` で席種変更
2. API `PATCH /api/sessions/{id}/seat-type`
   - `sessions.seat_type_id` 更新
   - `session_seat_events` に `price_snapshot` を追加
   - Broadcast `session:update`

### 4.2 会計時の合算チャージ

`fn_calc_total_charge(session_id)` が
`session_seat_events` 区間ごとに
1. 経過時間を 30 分切上げ（一時停止期間を考慮）
2. `price_snapshot` と乗算
3. 区間合計をすべて加算 → 戻り値をスマレジ `/sales` に含める。

### 4.3 料金課金の一時停止と再開

1. テーブル管理画面で「課金一時停止」ボタンをクリック
2. API `POST /api/tables/{table_id}/sessions/{session_id}/pause` を呼び出し
3. `sessions.charge_paused_at` に現在時刻を記録
4. 料金計算時に一時停止時間を考慮して計算
5. 「課金再開」ボタンをクリックすると `charge_paused_at` を null に設定

### 4.3 QRアクセス時のユーザーフロー

1. ユーザーがQRリンク（`/menu/[table_id]`）にアクセス
2. セッションの状態に応じて以下のフローを実行:
   - **セッションがない場合**:
     1. 「この席に座る」ボタンを表示
     2. ボタンクリック時に`charge_started_at`を現在時刻で記録
     3. 「新規」または「指名あり」の選択画面を表示
     4. 「新規」選択時は`is_new_customer=true`を記録
     5. 「指名あり」選択時はキャスト一覧を表示し、選択したキャストの`selected_cast_id`を記録
     6. メニュー画面を表示
   - **セッションがある場合**:
     1. 既存のセッション情報を使用してメニュー画面を表示

---

## 5  API エンドポイント

| Method | Path | 権限 | 要点 |
| :-- | :-- | :-- | :-- |
| POST | `/api/login` | – | email+pass+store_code / 403 if not member |
| GET | `/api/me` | cast/admin | `[{store_id, role}]` |
| GET | `/api/orders/active` | cast/admin | store フィルタ |
| PATCH | `/api/orders/{id}/status` | cast/admin | Kanban 更新 → Broadcast |
| PATCH | `/api/sessions/{id}/seat-type` | admin | 席種変更＋snapshot |
| PATCH | `/api/tables/{table_id}/sessions/{session_id}` | - | セッション更新（座席選択・キャスト選択） |
| POST | `/api/tables/{table_id}/sessions/{session_id}/pause` | admin | 料金課金一時停止 |
| POST | `/api/tables/{table_id}/sessions/{session_id}/resume` | admin | 料金課金再開 |
| POST | `/api/checkout/{session}` | cast/admin | `fn_calc_total_charge` → `/sales` |
| POST | `/api/smaregi-sync` | admin | メニュー同期 |
| PATCH | `/api/stores/settings` | admin | 店舗設定更新 |
| GET | `/api/casts` | admin | キャスト一覧取得 |
| POST | `/api/casts` | admin | キャスト追加 |
| GET | `/api/casts/{id}` | admin | キャスト詳細取得 |
| PATCH | `/api/casts/{id}` | admin | キャスト更新 |
| DELETE | `/api/casts/{id}` | admin | キャスト削除 |
| GET | `/api/menus` | admin | メニュー一覧取得 |
| POST | `/api/menus` | admin | メニュー追加 |
| GET | `/api/menus/{id}` | admin | メニュー詳細取得 |
| PATCH | `/api/menus/{id}` | admin | メニュー更新 |
| DELETE | `/api/menus/{id}` | admin | メニュー削除 |
| GET | `/api/menu-categories` | admin | カテゴリ一覧取得 |
| POST | `/api/menu-categories` | admin | カテゴリ追加 |
| PATCH | `/api/menu-categories/{id}` | admin | カテゴリ更新 |
| DELETE | `/api/menu-categories/{id}` | admin | カテゴリ削除 |

---

## 6  フロントエンド構成

| ディレクトリ | 目的 | Guard |
| :-- | :-- | :-- |
| **`app/portal/`** | キャスト・管理者 UI（要認証） | `StoreGuard` |
| **`app/menu/`** | 来店客 QR メニュー（非認証） | なし |
| `app/login/` | 店舗別ログイン画面 | なし |
| `components/ui/` | 共有 Atomic UI | – |
| `features/` | orders, sessions など共有ロジック | – |
| `stores/` | Zustand stores | – |

### 主なページ

| ルート | 説明 |
| :-- | :-- |
| `/portal/dashboard` | 全卓状況＋経過タイマー |
| `/portal/order-board` | Kanban ステータス管理 |
| `/portal/proxy-order` | 代理注文機能（テーブル選択・メニュー表示・注文） |
| `/portal/tables` | テーブル CRUD & QR 発行 |
| `/portal/seat-types` | 席種単価編集 |
| `/portal/casts` | キャスト管理（追加・編集・削除） |
| `/portal/casts/new` | 新規キャスト追加 |
| `/portal/casts/[id]/edit` | キャスト編集 |
| `/portal/menus` | メニュー管理（追加・編集・削除・スマレジ同期） |
| `/portal/menus/new` | 新規メニュー追加 |
| `/portal/menus/[id]/edit` | メニュー編集 |
| `/portal/menu-categories` | メニューカテゴリ管理 |
| `/portal/settings` | スマレジ連携設定 |
| `/portal/reports/:period` | 売上・スタッフドリンク CSV |
| `/menu/[table_id]` | 来店客メニュー＋カート＋会計 |

### PWA

- `app/menu/layout.tsx` で Workbox SW 登録
- OfflineCache: メニュー JSON・画像・CSS を precache

---

## 7  Seed スクリプト（抜粋）

```ts
const { data: store } = await db
  .from("stores")
  .insert({ store_code: "GB001", name: "GirlsBar One" })
  .select()
  .single();

const { user } = await admin.auth.admin.createUser({
  email: "test@test.com",
  password: "testtest"
});

await db.from("store_users").insert({
  store_id: store.store_id,
  user_id: user.id,
  role: "admin"
});
```

---

## 8  テスト計画

| レイヤ | ツール | 代表ケース |
| :-- | :-- | :-- |
| Unit | Vitest | `charge.ts` 切上げ境界値 |
| API | Supertest | `/api/login` 403 / 200 |
| E2E | Playwright | ①来店客 `/menu` オフライン→復帰送信<br>②Portal Kanban 2 ブラウザ同期 |
| Perf | k6 | 50 VU p95 < 300 ms |
| Sec | OWASP ZAP | 自動スキャン Gate |

---

## 9  CI / CD

1. GitHub Actions
   - lint → unit → api → `supabase db push` (stg)
   - `next build` → Vercel deploy
   - Playwright smoke on Preview
2. Nightly k6 + ZAP
3. Instant Rollback (Vercel) + `supabase migration down`

---

## 10  性能・セキュリティ指標

| 項目 | 指標 |
| :-- | :-- |
| 同時接続 | 50 VU p95 < 300 ms |
| 可用性 | 営業時間 99.9 % |
| Realtime 遅延 | ≤ 1 s |
| リアルタイム更新 | Supabase Realtime + Broadcast Channel |
| 監査ログ保持 | 90 日 |
| XSS/CSRF | RSC 自動エスケープ＋SameSite=Lax Cookie |
</file>

<file path="docs/要件定義書.md">
# QRオーダー & 会計連携システム
## 要件定義書 ― *v2025-08-02 Rev 7.2*

### 1  目的・ゴール
- 卓上 **QR** から来店客スマホでメニュー閲覧・注文
- 会計は **スマレジ API** へ明細送信
- 実装は **Next.js 15 (App Router／Server Actions)** 単体
- ガールズバー特有機能
  - 30 分切り上げチャージ
  - スタッフドリンク（キャスト指名）
  - 席移動／席種変更
- **管理者・キャストは同一 UI**。機能は DB 上の権限で ON/OFF
- 店舗ごと完全分離（マルチテナント）・リアルタイム同期遅延 1 s 以内

---

### 2  アクター & ロール

| ロール | 認証方法 | 主な権限 |
| :-- | :-- | :-- |
| 来店客 | ― | メニュー閲覧／注文／取消／会計 |
| キャスト | メール + パスワード | 自店舗卓一覧・代理注文・ステータス更新・会計 |
| 管理者 | メール + パスワード | 全卓操作・テーブル/メニュー/ユーザ管理・チャージ切替・売上閲覧 |
| システム管理者(root) | メール + パスワード | 複数店舗運用・マスタ管理 |

- **ログイン URL**：`/login/{store_code}`（パス必須）
- 画面冒頭に店舗名を表示し誤接続を防止
- ログイン成功時、`store_users(user_id, store_id)` に該当行が無ければ **403 Forbidden**

---

### 3  機能要件

#### 3.1 共通 UI / UX
| ID | 内容 |
| :- | :- |
| **FR-A01** | シングル UI + 権限制御（`AuthGuard<requiredRole>`） |
| **FR-A02** | `/login/{store_code}` で店舗名を SSR 表示 |
| **FR-A03** | 認証はメール + パスワードのみ（JWT は標準 claim のみ） |
| **FR-A04** | 所属店舗に一致しないログイン試行は 403 |

#### 3.2 メニュー & 注文
| ID | 内容 | 備考 |
| :- | :- | :- |
| **FR-M01** | スマレジ → メニュー同期ボタン（管理者） | Cron なし・即時反映 |
| **FR-M02** | **メニューカテゴリの管理機能** | カテゴリのCRUD・表示順管理 |
| **FR-O01** | キャスト／管理者は **注文ステータスをリアルタイム更新・閲覧** | Kanban DnD、遅延 < 1 s |
| **FR-O02** | キャスト／管理者は **代理注文機能で来店客の代わりに注文可能** | 代理注文はフラグ付きで表示 |

#### 3.3 テーブル & QR
| ID | 内容 |
| :- | :- |
| **FR-T01** | テーブル CRUD + **QR 自動生成** (`/menu/{table_id}`) |
| **FR-T02** | 席移動履歴保持・チャージ切替トグル |
| **FR-T03** | **席種単価 (`price_per_unit`) は管理者が UI から随時変更** |
| **FR-T04** | 席種変更が行われた場合、<br>**変更前の注文・チャージ額（旧単価）と<br>変更後の注文・チャージ額（新単価）を合算**して会計 |

#### 3.4 店舗設定
| ID | 内容 |
| :- | :- |
| **FR-S01** | **店舗ごとにキャスト管理機能の有効/無効を設定可能** |
| **FR-S02** | **店舗ごとにスマレジ連携機能の有効/無効を設定可能** |
| **FR-S03** | **スマレジ連携が有効な場合、クライアントIDとシークレットを設定可能** |
| **FR-S04** | **設定変更は管理者のみ可能** |

#### 3.5 キャスト管理
| ID | 内容 |
| :- | :- |
| **FR-C01** | **キャストの追加・編集・削除が可能** |
| **FR-C02** | **キャスト管理機能が有効な場合のみ利用可能** |
| **FR-C03** | **管理者のみキャスト管理画面にアクセス可能** |

#### 3.6 チャージ
| ID | 内容 |
| :- | :- |
| **FR-CH01** | 会計確定時 `(now – charge_started_at)` を 30 分単位へ丸め課金（Cron 無）<br>区間ごとに `session_seat_events` の **単価スナップショット**を使用し合算 |

#### 3.7 セッション表示
| ID | 内容 |
| :- | :- |
| **FR-T01** | 管理者・キャストは **各テーブルの着席経過時間** をリアルタイム確認 |
| **FR-T02** | **ダッシュボード、注文ボード、テーブル管理画面はリアルタイムに更新** |

---

### 4  非機能要件

| 区分 | 要件 |
| :-- | :-- |
| デプロイ | Vercel (Edge Runtime)、単一 `package.json` |
| リアルタイム | Supabase Realtime & Broadcast：遅延 ≤ 1 s |
| PWA | オフライン時メニュー閲覧・再接続時自動送信 |
| シード | `scripts/seed.ts`：店舗 “GB001” と管理者 `test@test.com / testtest` |
| 監査ログ | 注文／取消／会計／席移動 90 日保持 |
| セキュリティ | Supabase RLS + JWT(標準)・OWASP Top 10 対策 |

---

### 5  データモデル概要（主要テーブル）

```mermaid
erDiagram
    stores {
        uuid store_id PK
        string store_code UNIQUE
        string name
        boolean enable_cast_management
        boolean enable_smaregi_integration
        string smaregi_client_id
        string smaregi_client_secret
        string smaregi_contract_id
    }
    users {
        uuid user_id PK
        string email UNIQUE
        string password_hash
    }
    store_users {
        uuid id PK
        uuid store_id FK
        uuid user_id FK
        string role "admin|cast"
        string display_name
    }
    menu_categories {
        uuid category_id PK
        uuid store_id FK
        string name
        int display_order
    }
    seat_types {
        int seat_type_id PK
        uuid store_id FK
        string code
        string display_name
        int price_per_unit
    }
    tables {
        uuid table_id PK
        uuid store_id FK
        string name
        int seat_type_id FK
    }
    sessions {
        uuid session_id PK
        uuid store_id FK
        uuid table_id FK
        timestamptz start_at
        timestamptz charge_started_at
    }
    session_seat_events {
        uuid event_id PK
        uuid session_id FK
        int seat_type_id FK
        int price_snapshot
        timestamptz changed_at
    }
    orders {
        uuid order_id PK
        uuid store_id FK
        uuid session_id FK
        string status
        string created_by_role
        bool proxy
    }
```

- **権限管理はすべて `store_users` 経由**
- 各業務テーブルに `store_id` を保持し、RLS で
  `store_id ∈ (SELECT store_id FROM store_users WHERE user_id = auth.uid())`

---

### 6  画面一覧

| 画面 | 来店客 | キャスト | 管理者 | 主な機能 |
| :-- | :--: | :--: | :--: | :-- |
| QRメニュー | ✅ | – | – | メニュー閲覧／注文／会計 |
| 注文ボード (Kanban) | – | ✅ | ✅ | ステータス DnD／リアルタイム同期 |
| ダッシュボード | – | △ | ✅ | 全卓＋経過タイマー＋チャージ切替 |
| 代理注文 | – | ✅ | ✅ | テーブル選択／メニュー表示／代理注文 |
| テーブル設定 & QR | – | – | ✅ | テーブル CRUD + QR 生成 |
| 席種設定 | – | – | ✅ | 単価編集 |
| キャスト管理 | – | – | ✅ | キャスト追加・編集・削除 |
| メニュー管理 | – | – | ✅ | メニュー追加・編集・削除・スマレジ同期 |
| カテゴリ管理 | – | – | ✅ | カテゴリ追加・編集・削除・表示順変更 |
| スマレジ連携設定 | – | – | ✅ | スマレジ連携の有効/無効設定 |
| レポート | – | – | ✅ | 売上・スタッフドリンク集計 |

（△ = 読み取りのみ）

---

### 7  外部連携（スマレジ）

| 項目 | 仕様 |
| :-- | :-- |
| 認証 | OAuth 2.0 |
| メニュー同期 | `GET /products` → `menus` 上書き |
| 会計連携 | `POST /sales` (明細 + チャージ) |
| リトライ | 3 回失敗で UI にエラー表示 |

---

### 8  将来拡張
- キャスト出退勤連携
- LINE 通知／厨房ディスプレイ
- 割引・サービス料プラグイン
- オフライン決済キュー

---

### 9  マイルストーン（1 店舗）

| Phase | 成果物 | 期間 (M) |
| :-- | :-- | :-- |
| 要件確定 | 本ドキュメント | 0.5 |
| 基盤 | Next.js + Auth + RLS + Seed | 1.0 |
| コア機能 | 注文・チャージ・会計 | 1.5 |
| 管理＋QR | テーブル CRUD + QR + メニュー同期 | 1.0 |
| テスト & 導入 | Playwright E2E + UAT | 0.5 |

---

### 10  サンプル `.env.example`

```dotenv
NEXT_PUBLIC_SUPABASE_URL=https://xyz.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=public-anon
SUPABASE_SERVICE_ROLE_KEY=service-role
NEXTAUTH_URL=https://app.example.com
NEXTAUTH_SECRET=changeme
SMARTREGISTER_CLIENT_ID=...
SMARTREGISTER_CLIENT_SECRET=...
PUBLIC_URL=https://app.example.com
```

---
</file>

<file path="supabase/migrations/20250815000000_add_smaregi_product_id_to_seat_types.sql">
-- seat_typesテーブルにsmaregi_product_idカラムを追加
ALTER TABLE public.seat_types
ADD COLUMN smaregi_product_id TEXT;

-- 既存のレコードにはNULLを設定（デフォルト値）

-- RLSポリシーの更新
CREATE POLICY "管理者のみsmaregi_product_idを更新可能" ON public.seat_types
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND store_id = seat_types.store_id
      AND role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND store_id = seat_types.store_id
      AND role = 'admin'
    )
  );
</file>

<file path="supabase/migrations/20250816000000_add_tax_rate_to_stores.sql">
-- stores テーブルに tax_rate カラムを追加
ALTER TABLE public.stores
ADD COLUMN tax_rate NUMERIC(5, 2) DEFAULT 10.0 NOT NULL;

-- 既存のレコードには 10.0% をデフォルト値として設定

-- RLSポリシーの更新
CREATE POLICY "管理者のみtax_rateを更新可能" ON public.stores
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND store_id = stores.store_id
      AND role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND store_id = stores.store_id
      AND role = 'admin'
    )
  );
</file>

<file path="__tests__/api/menu-categories/delete.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';
import { DELETE } from '@/app/api/menu-categories/[category_id]/route';

// モック
vi.mock('next/headers', () => ({
  cookies: vi.fn(),
}));

vi.mock('@/lib/supabase', () => ({
  createServerSupabaseClient: vi.fn(),
  createServerComponentClient: vi.fn(),
}));

vi.mock('@/lib/auth', () => ({
  getUserRoleInStore: vi.fn(),
}));

describe('カテゴリ削除API', () => {
  const mockCookieStore = {
    get: vi.fn(),
  };

  const mockSupabase = {
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    gt: vi.fn().mockReturnThis(),
    delete: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    single: vi.fn(),
  };

  const mockAuthClient = {
    auth: {
      getUser: vi.fn(),
    },
  };

  beforeEach(() => {
    vi.clearAllMocks();
    
    // cookiesのモック
    (cookies as any).mockReturnValue(mockCookieStore);
    mockCookieStore.get.mockReturnValue({ value: 'store-123' });
    
    // Supabaseクライアントのモック
    (createServerSupabaseClient as any).mockResolvedValue(mockSupabase);
    (createServerComponentClient as any).mockResolvedValue(mockAuthClient);
    
    // 認証情報のモック
    mockAuthClient.auth.getUser.mockResolvedValue({
      data: { user: { id: 'user-123' } },
    });
    
    // ユーザーロールのモック
    (getUserRoleInStore as any).mockResolvedValue('admin');
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('カテゴリを削除し、表示順を更新する', async () => {
    // カテゴリ情報のモック
    mockSupabase.single.mockResolvedValueOnce({
      data: {
        category_id: 'category-123',
        store_id: 'store-123',
        name: 'テストカテゴリ',
        display_order: 2,
      },
    });
    
    // メニュー数のモック（0件）
    mockSupabase.select.mockReturnValueOnce({
      count: 0,
      error: null,
    });
    
    // 削除のモック
    mockSupabase.delete.mockReturnValueOnce({
      error: null,
    });
    
    // 表示順更新のモック
    mockSupabase.update.mockReturnValueOnce({
      error: null,
    });

    // リクエストの作成
    const request = new NextRequest('http://localhost/api/menu-categories/category-123', {
      method: 'DELETE',
    });
    
    // パラメータの作成
    const params = Promise.resolve({ category_id: 'category-123' });
    
    // APIの実行
    const response = await DELETE(request, { params });
    const responseData = await response.json();
    
    // レスポンスの検証
    expect(response.status).toBe(200);
    expect(responseData).toEqual({ success: true });
    
    // カテゴリ情報の取得が呼ばれたことを確認
    expect(mockSupabase.from).toHaveBeenCalledWith('menu_categories');
    expect(mockSupabase.select).toHaveBeenCalledWith('*');
    expect(mockSupabase.eq).toHaveBeenCalledWith('category_id', 'category-123');
    
    // メニュー数の確認が呼ばれたことを確認
    expect(mockSupabase.from).toHaveBeenCalledWith('menus');
    
    // カテゴリの削除が呼ばれたことを確認
    expect(mockSupabase.from).toHaveBeenCalledWith('menu_categories');
    expect(mockSupabase.delete).toHaveBeenCalled();
    expect(mockSupabase.eq).toHaveBeenCalledWith('category_id', 'category-123');
    
    // 表示順の更新が呼ばれたことを確認
    expect(mockSupabase.from).toHaveBeenCalledWith('menu_categories');
    expect(mockSupabase.update).toHaveBeenCalled();
    expect(mockSupabase.eq).toHaveBeenCalledWith('store_id', 'store-123');
    expect(mockSupabase.gt).toHaveBeenCalledWith('display_order', 2);
  });

  it('メニューが存在する場合はカテゴリを削除できない', async () => {
    // カテゴリ情報のモック
    mockSupabase.single.mockResolvedValueOnce({
      data: {
        category_id: 'category-123',
        store_id: 'store-123',
        name: 'テストカテゴリ',
        display_order: 2,
      },
    });
    
    // メニュー数のモック（1件以上）
    mockSupabase.select.mockReturnValueOnce({
      count: 1,
      error: null,
    });

    // リクエストの作成
    const request = new NextRequest('http://localhost/api/menu-categories/category-123', {
      method: 'DELETE',
    });
    
    // パラメータの作成
    const params = Promise.resolve({ category_id: 'category-123' });
    
    // APIの実行
    const response = await DELETE(request, { params });
    const responseData = await response.json();
    
    // レスポンスの検証
    expect(response.status).toBe(400);
    expect(responseData).toEqual({ error: 'このカテゴリに属するメニューが存在するため削除できません' });
    
    // 削除が呼ばれていないことを確認
    expect(mockSupabase.delete).not.toHaveBeenCalled();
    
    // 表示順の更新が呼ばれていないことを確認
    expect(mockSupabase.update).not.toHaveBeenCalled();
  });
});
</file>

<file path=".augment-guidelines">
# .cursorrules ─ QRオーダー & 会計連携システム

## 01 – Authoritative Sources
- **Always cite the _latest_ Supabase docs registered in Cursor as “Supabase” and the newest official Next-js docs stored in Cursor.**  
- If an API isn’t covered, file a “doc-update” task instead of guessing.

## 02 – Supabase Access
- **All Supabase calls must flow through backend Route Handlers or Server Actions.** Front-end direct calls are forbidden; flag a PR if detected.

## 03 – Learning from Feedback
- Any reviewer comment that begins with `RULE:` becomes a new rule appended to this file automatically.

## 04 – Component Factorisation
- Extract shared UI/logic into `/components/ui/**` or `/features/**` per Atomic + Feature-Slice.

## 05 – Design Patterns
- Follow the Presentation → State → Domain → Data → Infrastructure layering.  
- Warn if a new PR skips layers.

## 06 – Document & Progress Sync
- Changes that alter behaviour/public contracts **must update 要件定義書 & 詳細設計書** in the same PR.  
- New features not in the docs require prior reviewer approval.  
- Update the **進捗管理表** check-list whenever a task completes.

## 07 – Test-First
- Every production file added/changed must ship with matching tests; block PRs that lower coverage.

## 08 – Windows CLI Compatibility  ← NEW
- **All code snippets and setup commands must run on Windows (CMD or PowerShell).**  
  - Use `copy` or `xcopy` instead of `cp` :contentReference[oaicite:0]{index=0}.  
  - Use `Remove-Item` instead of `rm` :contentReference[oaicite:1]{index=1}.  
  - Show `npm install` and `node app.js` exactly as they appear in Windows docs :contentReference[oaicite:2]{index=2}.  
  - Installation/setup links should reference official Windows guides (Git for Windows, Node installer, etc.) :contentReference[oaicite:3]{index=3}.  
- If a cross-platform shell command _must_ be included, also supply the Windows variant or a PowerShell one-liner.

## 09 – Lint & Style
- Enforce ESLint, Prettier; CI fails on violations.

## 10 – Communication
- If unclear or conflicting, ask for clarification instead of assuming.

## 11 - Chat
- Always output in japanese.
</file>

<file path=".cursorrules">
# .cursorrules ─ QRオーダー & 会計連携システム

## 01 – Authoritative Sources
- **Always cite the _latest_ Supabase docs registered in Cursor as “Supabase” and the newest official Next-js docs stored in Cursor.**  
- If an API isn’t covered, file a “doc-update” task instead of guessing.

## 02 – Supabase Access
- **All Supabase calls must flow through backend Route Handlers or Server Actions.** Front-end direct calls are forbidden; flag a PR if detected.

## 03 – Learning from Feedback
- Any reviewer comment that begins with `RULE:` becomes a new rule appended to this file automatically.

## 04 – Component Factorisation
- Extract shared UI/logic into `/components/ui/**` or `/features/**` per Atomic + Feature-Slice.

## 05 – Design Patterns
- Follow the Presentation → State → Domain → Data → Infrastructure layering.  
- Warn if a new PR skips layers.

## 06 – Document & Progress Sync
- Changes that alter behaviour/public contracts **must update 要件定義書 & 詳細設計書** in the same PR.  
- New features not in the docs require prior reviewer approval.  
- Update the **進捗管理表** check-list whenever a task completes.

## 07 – Test-First
- Every production file added/changed must ship with matching tests; block PRs that lower coverage.

## 08 – Windows CLI Compatibility  ← NEW
- **All code snippets and setup commands must run on Windows (CMD or PowerShell).**  
  - Use `copy` or `xcopy` instead of `cp` :contentReference[oaicite:0]{index=0}.  
  - Use `Remove-Item` instead of `rm` :contentReference[oaicite:1]{index=1}.  
  - Show `npm install` and `node app.js` exactly as they appear in Windows docs :contentReference[oaicite:2]{index=2}.  
  - Installation/setup links should reference official Windows guides (Git for Windows, Node installer, etc.) :contentReference[oaicite:3]{index=3}.  
- If a cross-platform shell command _must_ be included, also supply the Windows variant or a PowerShell one-liner.

## 09 – Lint & Style
- Enforce ESLint, Prettier; CI fails on violations.

## 10 – Communication
- If unclear or conflicting, ask for clarification instead of assuming.
</file>

<file path=".env.example">
NEXT_PUBLIC_SUPABASE_URL=https://xyz.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=public-anon
SUPABASE_SERVICE_ROLE_KEY=service-role
NEXTAUTH_URL=https://app.example.com
NEXTAUTH_SECRET=changeme
PUBLIC_URL=https://app.example.com
</file>

<file path=".gitignore">
node_modules
.next
.env.local
</file>

<file path="app/api/auth/login/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

// 共通の設定
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;

export async function POST(request: NextRequest) {
  try {
    const { email, password, storeCode } = await request.json();

    if (!email || !password || !storeCode) {
      return NextResponse.json(
        { error: 'メールアドレス、パスワード、店舗コードは必須です' },
        { status: 400 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗コードから店舗情報を取得
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('store_id, name')
      .eq('store_code', storeCode)
      .single();

    if (storeError || !store) {
      return NextResponse.json(
        { error: '店舗が見つかりません' },
        { status: 404 }
      );
    }

    // ログイン処理
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (authError) {
      return NextResponse.json(
        { error: 'ログインに失敗しました。メールアドレスとパスワードを確認してください' },
        { status: 401 }
      );
    }

    // Cookieを設定
    const cookieStore = await cookies();

    // 店舗IDをCookieに設定
    cookieStore.set('store-id', store.store_id, {
      path: '/',
      maxAge: 60 * 60 * 24 * 30, // 30日間
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
    });

    // Supabaseのセッションクッキーを設定
    const supabaseAuthCookie = `sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`;
    cookieStore.set(supabaseAuthCookie, JSON.stringify(authData.session), {
      path: '/',
      maxAge: 60 * 60 * 24 * 7, // 1週間
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
    });

    const allCookies = cookieStore.getAll();

    return NextResponse.json({
      success: true,
      store: {
        id: store.store_id,
        name: store.name,
      },
    });
  } catch (error) {
    console.error('ログインエラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/auth/user/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;



    // 優先順位: ヘッダー > Cookieストア
    const storeId = storeIdFromHeader || storeIdFromStore;

    if (!storeId) {
      console.error('GET /api/auth/user: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const allCookies = cookieStore.getAll();

    // リクエストのCookieを使用してSupabaseクライアントを作成
    // リクエストヘッダーからSupabase認証トークンを抽出
    const authTokenMatch = requestCookies?.match(/sb-[^-]+-auth-token=([^;]+)/);
    const authToken = authTokenMatch ? decodeURIComponent(authTokenMatch[1]) : null;



    if (!authToken) {
      console.error('GET /api/auth/user: 認証トークンがCookieに見つかりません');
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // 認証トークンをパースしてみる
    try {
      // base64-プレフィックスがある場合は削除
      let tokenValue = authToken;
      if (tokenValue.startsWith('base64-')) {
        tokenValue = tokenValue.substring(7); // 'base64-'の長さは7
        // base64デコード
        try {
          tokenValue = Buffer.from(tokenValue, 'base64').toString();

        } catch (decodeError) {
          console.error('GET /api/auth/user: base64デコードに失敗しました:', decodeError);
        }
      }

      // JSONとしてパース
      const parsedToken = JSON.parse(tokenValue);

    } catch (e) {
      console.error('GET /api/auth/user: 認証トークンのパースに失敗しました:', e);

      // パースに失敗しても処理を続行する
    }

    const supabase = await createServerComponentClient();


    // ユーザー情報を取得
    const { data: { user }, error } = await supabase.auth.getUser();


    if (error) {
      console.error('GET /api/auth/user: 認証エラー:', error);
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    if (!user) {
      console.error('GET /api/auth/user: ユーザー情報が取得できません');
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }



    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    if (!userRole) {
      console.error('GET /api/auth/user: ユーザーに店舗の権限がありません:', { userId: user.id, storeId });
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }



    return NextResponse.json({
      user: {
        id: user.id,
        email: user.email,
        role: userRole
      }
    });
  } catch (error) {
    console.error('ユーザー情報取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/casts/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const url = new URL(request.url);
    const queryStoreId = url.searchParams.get('storeId');

    const cookieStore = await cookies();
    const cookieStoreId = cookieStore.get('store-id')?.value;
    const cookieStoreIdLegacy = cookieStore.get('storeId')?.value;

    // 優先順位: クエリパラメータ > Cookieストア
    const storeId = queryStoreId || cookieStoreId || cookieStoreIdLegacy;

    console.log('GET /api/casts/[id]: 店舗ID比較:', {
      queryStoreId,
      cookieStoreId,
      cookieStoreIdLegacy,
      finalStoreId: storeId
    });

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_cast_management')
      .eq('store_id', storeId)
      .single();

    if (!store || !store.enable_cast_management) {
      return NextResponse.json(
        { error: 'キャスト管理機能が無効です' },
        { status: 403 }
      );
    }

    // キャスト情報を取得
    const { data: cast, error } = await supabase
      .from('store_users')
      .select(`
        id,
        role,
        user_id,
        auth.users (
          email
        )
      `)
      .eq('id', id)
      .eq('store_id', storeId)
      .eq('role', 'cast')
      .single();

    if (error) {
      console.error('キャスト取得エラー:', error);
      return NextResponse.json(
        { error: 'キャスト情報の取得に失敗しました' },
        { status: 404 }
      );
    }

    return NextResponse.json(cast);
  } catch (error) {
    console.error('キャスト取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const url = new URL(request.url);
    const queryStoreId = url.searchParams.get('storeId');

    const cookieStore = await cookies();
    const cookieStoreId = cookieStore.get('store-id')?.value;
    const cookieStoreIdLegacy = cookieStore.get('storeId')?.value;

    // 優先順位: クエリパラメータ > Cookieストア
    const storeId = queryStoreId || cookieStoreId || cookieStoreIdLegacy;

    console.log('PATCH /api/casts/[id]: 店舗ID比較:', {
      queryStoreId,
      cookieStoreId,
      cookieStoreIdLegacy,
      finalStoreId: storeId
    });

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_cast_management')
      .eq('store_id', storeId)
      .single();

    if (!store || !store.enable_cast_management) {
      return NextResponse.json(
        { error: 'キャスト管理機能が無効です' },
        { status: 403 }
      );
    }

    const data = await request.json();

    // バリデーション
    if (!data.email || !data.display_name) {
      return NextResponse.json(
        { error: 'メールアドレスと名前は必須です' },
        { status: 400 }
      );
    }

    // キャスト情報を取得
    const { data: cast, error: castError } = await supabase
      .from('store_users')
      .select('id, user_id')
      .eq('id', id)
      .eq('store_id', storeId)
      .eq('role', 'cast')
      .single();

    if (castError || !cast) {
      return NextResponse.json(
        { error: 'キャストが見つかりません' },
        { status: 404 }
      );
    }

    // ユーザー情報を更新
    const updateData: any = {
      email: data.email,
      email_confirm: true,
    };

    // パスワードが指定されている場合のみ更新
    if (data.password) {
      updateData.password = data.password;
    }

    const { error: updateError } = await supabase.auth.admin.updateUserById(
      cast.user_id,
      updateData
    );

    if (updateError) {
      console.error('ユーザー更新エラー:', updateError);
      return NextResponse.json(
        { error: 'ユーザー情報の更新に失敗しました' },
        { status: 500 }
      );
    }

    // 表示名を更新
    const { error: displayNameError } = await supabase
      .from('store_users')
      .update({ display_name: data.display_name })
      .eq('id', cast.id);

    if (displayNameError) {
      console.error('表示名更新エラー:', displayNameError);
      return NextResponse.json(
        { error: '表示名の更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('キャスト更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const url = new URL(request.url);
    const queryStoreId = url.searchParams.get('storeId');

    const cookieStore = await cookies();
    const cookieStoreId = cookieStore.get('store-id')?.value;
    const cookieStoreIdLegacy = cookieStore.get('storeId')?.value;

    // 優先順位: クエリパラメータ > Cookieストア
    const storeId = queryStoreId || cookieStoreId || cookieStoreIdLegacy;

    console.log('DELETE /api/casts/[id]: 店舗ID比較:', {
      queryStoreId,
      cookieStoreId,
      cookieStoreIdLegacy,
      finalStoreId: storeId
    });

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_cast_management')
      .eq('store_id', storeId)
      .single();

    if (!store || !store.enable_cast_management) {
      return NextResponse.json(
        { error: 'キャスト管理機能が無効です' },
        { status: 403 }
      );
    }

    // キャスト情報を取得
    const { data: cast, error: castError } = await supabase
      .from('store_users')
      .select('user_id')
      .eq('id', id)
      .eq('store_id', storeId)
      .eq('role', 'cast')
      .single();

    if (castError || !cast) {
      return NextResponse.json(
        { error: 'キャストが見つかりません' },
        { status: 404 }
      );
    }

    // 店舗ユーザー関連付けを削除
    const { error: deleteError } = await supabase
      .from('store_users')
      .delete()
      .eq('id', id)
      .eq('store_id', storeId);

    if (deleteError) {
      console.error('店舗ユーザー関連付け削除エラー:', deleteError);
      return NextResponse.json(
        { error: '店舗ユーザー関連付けの削除に失敗しました' },
        { status: 500 }
      );
    }

    // ユーザーを削除
    const { error: userDeleteError } = await supabase.auth.admin.deleteUser(
      cast.user_id
    );

    if (userDeleteError) {
      console.error('ユーザー削除エラー:', userDeleteError);
      // ユーザー削除に失敗しても、関連付けは削除されているので成功とする
      console.warn('ユーザー削除に失敗しましたが、関連付けは削除されました');
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('キャスト削除エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/casts/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const queryStoreId = url.searchParams.get('store_id');
    const queryStoreIdNew = url.searchParams.get('storeId');
    const cookieStore = await cookies();
    const cookieStoreId = cookieStore.get('store-id')?.value;
    const cookieStoreIdLegacy = cookieStore.get('storeId')?.value;

    // 優先順位: クエリパラメータ > Cookieストア
    const storeId = queryStoreId || queryStoreIdNew || cookieStoreId || cookieStoreIdLegacy;

    console.log('GET /api/casts: 店舗ID比較:', {
      queryStoreId,
      queryStoreIdNew,
      cookieStoreId,
      cookieStoreIdLegacy,
      finalStoreId: storeId
    });

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // クエリパラメータでstore_idまたはstoreIdが指定されている場合は認証チェックをスキップ
    // これにより、メニュー画面からのキャスト一覧取得が可能になる
    if (!queryStoreId && !queryStoreIdNew) {
      // 認証用クライアント（Cookieベース）
      const authClient = await createServerComponentClient();

      // ユーザー情報を取得
      const { data: { user } } = await authClient.auth.getUser();

      if (!user) {
        return NextResponse.json(
          { error: '認証されていません' },
          { status: 401 }
        );
      }

      // ユーザーの役割を取得
      const userRole = await getUserRoleInStore(user.id, storeId);

      // 管理者でなければエラー
      if (userRole !== 'admin') {
        return NextResponse.json(
          { error: '権限がありません' },
          { status: 403 }
        );
      }
    }

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_cast_management')
      .eq('store_id', storeId)
      .single();

    if (!store || !store.enable_cast_management) {
      return NextResponse.json(
        { error: 'キャスト管理機能が無効です' },
        { status: 403 }
      );
    }

    // キャスト一覧を取得
    const { data: casts, error } = await supabase
      .from('store_users')
      .select(`
        id,
        role,
        user_id,
        display_name
      `)
      .eq('store_id', storeId)
      .eq('role', 'cast');

    if (error) {
      console.error('キャスト一覧取得エラー:', error);
      return NextResponse.json(
        { error: 'キャスト一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(casts);
  } catch (error) {
    console.error('キャスト一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_cast_management')
      .eq('store_id', storeId)
      .single();

    if (!store || !store.enable_cast_management) {
      return NextResponse.json(
        { error: 'キャスト管理機能が無効です' },
        { status: 403 }
      );
    }

    const data = await request.json();

    // バリデーション
    if (!data.email || !data.password || !data.store_id || !data.display_name) {
      return NextResponse.json(
        { error: '必須項目が不足しています' },
        { status: 400 }
      );
    }

    // メールアドレスが既に存在するか確認
    const { data: existingUser } = await supabase
      .from('auth.users')
      .select('id')
      .eq('email', data.email)
      .maybeSingle();

    if (existingUser) {
      return NextResponse.json(
        { error: 'このメールアドレスは既に使用されています' },
        { status: 409 }
      );
    }

    // 新規ユーザーを作成
    const { data: newUser, error: userError } = await supabase.auth.admin.createUser({
      email: data.email,
      password: data.password,
      email_confirm: true,
    });

    if (userError) {
      console.error('ユーザー作成エラー:', userError);
      return NextResponse.json(
        { error: 'ユーザーの作成に失敗しました' },
        { status: 500 }
      );
    }

    // 店舗ユーザー関連付けを作成
    const { data: storeUser, error: storeUserError } = await supabase
      .from('store_users')
      .insert({
        store_id: data.store_id,
        user_id: newUser.user.id,
        role: 'cast',
        display_name: data.display_name
      })
      .select()
      .single();

    if (storeUserError) {
      console.error('店舗ユーザー関連付けエラー:', storeUserError);

      // ユーザー作成に成功したが関連付けに失敗した場合、ユーザーを削除
      await supabase.auth.admin.deleteUser(newUser.user.id);

      return NextResponse.json(
        { error: '店舗ユーザー関連付けの作成に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(storeUser, { status: 201 });
  } catch (error) {
    console.error('キャスト作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/checkout/[session_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { getSmaregiAccessToken, registerSmaregiTransaction } from '@/lib/smaregi';

export async function POST(
  request: NextRequest,
  { params }: { params: { session_id: string } }
) {
  try {
    const { session_id } = params;
    const data = await request.json();
    const { table_id } = data;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッション情報を取得
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select(`
        session_id,
        store_id,
        table_id,
        charge_started_at,
        tables (
          table_id,
          seat_type_id,
          seat_types (
            seat_type_id,
            price_per_unit,
            time_unit_minutes
          )
        )
      `)
      .eq('session_id', session_id)
      .single();



    if (sessionError || !session) {
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 注文合計を計算
    const { data: orders, error: ordersError } = await supabase
      .from('orders')
      .select(`
        order_id,
        order_items (
          order_item_id,
          price,
          quantity
        )
      `)
      .eq('session_id', session_id)
      .eq('status', 'new')
      .order('created_at', { ascending: true });



    if (ordersError) {
      console.error('注文取得エラー:', ordersError);
      return NextResponse.json(
        { error: '注文情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // 注文合計金額を計算
    let orderAmount = 0;
    if (orders && orders.length > 0) {
      for (const order of orders) {
        if (order.order_items && order.order_items.length > 0) {
          for (const item of order.order_items) {
            orderAmount += item.price * item.quantity;
          }
        }
      }
    }

    // テーブル料金を計算（データベース関数を使用）
    // fn_calc_total_charge関数は既にis_table_move_charge=trueのイベントの料金を含めて計算している
    const { data: chargeAmount, error: chargeError } = await supabase
      .rpc('fn_calc_total_charge', { p_session_id: session_id });

    if (chargeError) {
      console.error('テーブル料金計算エラー:', chargeError);
      return NextResponse.json(
        { error: 'テーブル料金の計算に失敗しました' },
        { status: 500 }
      );
    }

    // 席移動による料金の内訳を取得（表示用）
    let moveChargeAmount = 0;
    try {
      // is_table_move_chargeフィールドが存在する場合
      const { data: moveCharges, error: moveChargeError } = await supabase
        .from('session_seat_events')
        .select('price_snapshot')
        .eq('session_id', session_id)
        .eq('is_table_move_charge', true);

      if (!moveChargeError && moveCharges && moveCharges.length > 0) {
        for (const charge of moveCharges) {
          moveChargeAmount += charge.price_snapshot;
        }
      }
    } catch (error) {
      console.error('席移動料金取得例外:', error);
      // エラーがあっても処理は続行
    }

    console.log('席移動料金:', moveChargeAmount);
    console.log('合計テーブル料金:', chargeAmount);

    // 税抜き合計金額を計算
    const subtotalAmount = orderAmount + (chargeAmount || 0);



    // 店舗情報を取得（スマレジ連携の確認と税率）
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('enable_smaregi_integration, smaregi_client_id, smaregi_client_secret, smaregi_contract_id, tax_rate')
      .eq('store_id', session.store_id)
      .single();

    if (storeError) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // 店舗の消費税率を取得
    const taxRate = store.tax_rate !== undefined ? store.tax_rate : 10.0;
    // 消費税額を計算
    const taxAmount = Math.floor(subtotalAmount * (taxRate / 100));
    // 税込み合計金額を計算
    const totalAmount = subtotalAmount + taxAmount;

    // 会計情報をcheckoutsテーブルに保存
    const { data: checkout, error: checkoutError } = await supabase
      .from('checkouts')
      .insert({
        store_id: session.store_id,
        session_id: session_id,
        total_amount: totalAmount,
        charge_amount: chargeAmount,
        order_amount: orderAmount,
        status: 'pending'
      })
      .select()
      .single();

    if (checkoutError) {
      console.error('会計情報保存エラー:', checkoutError);
      return NextResponse.json(
        { error: '会計情報の保存に失敗しました' },
        { status: 500 }
      );
    }

    // スマレジ連携が有効な場合、スマレジAPIに会計データを送信
    if (store.enable_smaregi_integration) {
      try {
        // スマレジAPIのアクセストークンを取得
        const accessToken = await getSmaregiAccessToken(
          store.smaregi_client_id,
          store.smaregi_client_secret,
          store.smaregi_contract_id,
          'pos.transactions:write'
        );

        // 現在の日時を取得（スマレジAPIの日時フォーマットに合わせる）
        const now = new Date();
        // スマレジAPIの日時フォーマット: ISO 8601形式（YYYY-MM-DDTHH:mm:ss+XX:XX）
        // ミリ秒部分を削除し、タイムゾーン部分を調整
        const isoString = now.toISOString();
        const transactionDateTime = isoString.substring(0, 19) + '+09:00'; // 日本時間（+09:00）

        // 取引IDを生成（10文字以下にする必要がある）
        // 秒単位の時間（Unix時間の下4桁）+ 3桁のランダム数字で7桁の一意なIDを生成
        const timeComponent = Math.floor(now.getTime() / 1000).toString().slice(-4);
        const randomNum = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const terminalTranId = timeComponent + randomNum;

        // 注文明細を作成
        const details = [];
        let detailId = 1;

        if (orders && orders.length > 0) {
          for (const order of orders) {
            if (order.order_items && order.order_items.length > 0) {
              for (const item of order.order_items) {
                // 商品情報を取得
                const { data: menuItem } = await supabase
                  .from('menus')
                  .select('product_id, name')
                  .eq('store_id', session.store_id)
                  .eq('menu_id', item.menu_id)
                  .single();

                const detailIdStr = detailId.toString().padStart(3, '0');

                // スマレジAPIはproductIdが整数値である必要がある
                // product_idが数値でない場合は、一意の数値IDを生成
                let productId = "1"; // デフォルト値
                if (menuItem?.product_id) {
                  // product_idが数値の場合はそのまま使用
                  if (/^\d+$/.test(menuItem.product_id)) {
                    productId = menuItem.product_id;
                  } else {
                    // 数値でない場合は、メニューIDのハッシュから数値を生成
                    // 単純な方法として、文字列の各文字のコードポイントを合計
                    const hash = Array.from(item.menu_id)
                      .reduce((sum, char) => sum + char.charCodeAt(0), 0) % 9000 + 1000;
                    productId = hash.toString();
                  }
                }

                details.push({
                  transactionDetailId: detailIdStr,
                  parentTransactionDetailId: detailIdStr,
                  transactionDetailDivision: "1", // 通常商品
                  productId: productId,
                  productName: menuItem?.name || "商品名不明",
                  printReceiptProductName: menuItem?.name || "商品名不明",
                  taxDivision: "1", // 税抜
                  price: item.price.toString(),
                  salesPrice: item.price.toString(),
                  quantity: item.quantity.toString()
                });

                detailId++;
              }
            }
          }
        }

        // テーブル料金を追加（サービス料として）
        if (chargeAmount && chargeAmount > 0) {
          const detailIdStr = detailId.toString().padStart(3, '0');

          // テーブルIDからテーブル料金用の商品IDを生成
          // テーブルIDのハッシュから数値を生成（8000-8999の範囲）
          const tableHash = Array.from(table_id)
            .reduce((sum, char) => sum + char.charCodeAt(0), 0) % 1000 + 8000;

          // テーブル情報を取得
          const { data: tableData } = await supabase
            .from('tables')
            .select('name, seat_type_id')
            .eq('table_id', table_id)
            .single();

          const tableName = tableData?.name || 'テーブル';

          // 席種情報を取得（スマレジ商品IDがあれば使用）
          let productId = tableHash.toString(); // デフォルトはテーブルハッシュ
          let productName = `${tableName}料金`;
          let skipTableCharge = false; // テーブル料金をスキップするかどうか

          if (tableData?.seat_type_id) {
            const { data: seatTypeData } = await supabase
              .from('seat_types')
              .select('display_name, smaregi_product_id')
              .eq('seat_type_id', tableData.seat_type_id)
              .single();

            if (seatTypeData?.smaregi_product_id) {
              // 席種設定で選択した商品IDをそのまま使用
              productId = seatTypeData.smaregi_product_id;
              productName = `${seatTypeData.display_name || tableName}料金`;
            } else if (seatTypeData?.smaregi_product_id === '') {
              // 席種設定で商品IDが空文字列の場合（明示的に選択解除された場合）
              // テーブル料金をスキップする
              skipTableCharge = true;
            }
          }

          // 席種設定で商品IDが明示的に選択解除されていない場合のみテーブル料金を追加
          if (!skipTableCharge) {
            details.push({
              transactionDetailId: detailIdStr,
              parentTransactionDetailId: detailIdStr,
              transactionDetailDivision: "1", // 通常商品
              productId: productId,
              productName: productName,
              printReceiptProductName: productName,
              taxDivision: "1", // 税抜
              price: chargeAmount.toString(),
              salesPrice: chargeAmount.toString(),
              quantity: "1"
            });
          } else {
            console.log('テーブル料金のスマレジ連携をスキップします（席種設定で商品IDが選択解除されています）');
          }
        }

        // 店舗の消費税率を取得（デフォルトは10%）
        const smaregiTaxRate = store.tax_rate !== undefined ? store.tax_rate / 100 : 0.1;
        // 消費税を計算
        const smaregiTaxAmount = Math.floor(subtotalAmount * smaregiTaxRate);
        // 税込み合計金額を計算
        const totalWithTax = subtotalAmount + smaregiTaxAmount;

        // スマレジAPIに送信するデータを作成
        const transactionData = {
          transactionHeadDivision: "1", // 通常取引
          cancelDivision: "0", // 取消区分：通常
          subtotal: subtotalAmount.toString(),
          taxExclude: smaregiTaxAmount.toString(), // 消費税
          total: totalWithTax.toString(), // 税込み合計金額
          storeId: "1", // 店舗ID（スマレジ側の店舗ID）
          terminalId: "1", // 端末ID（スマレジ側の端末ID）
          terminalTranId: terminalTranId,
          terminalTranDateTime: transactionDateTime,
          details: details
        };

        // スマレジAPIに取引データを送信
        const smaregiResponse = await registerSmaregiTransaction(
          accessToken,
          store.smaregi_contract_id,
          transactionData
        );

        console.log('スマレジ取引登録レスポンス:', smaregiResponse);

        // 会計ステータスを完了に更新し、スマレジのレシートIDを保存
        const { error: updateError } = await supabase
          .from('checkouts')
          .update({
            status: 'completed',
            smaregi_receipt_id: smaregiResponse.id || terminalTranId
          })
          .eq('checkout_id', checkout.checkout_id);

        if (updateError) {
          console.error('会計ステータス更新エラー:', updateError);
          return NextResponse.json(
            { error: '会計ステータスの更新に失敗しました' },
            { status: 500 }
          );
        }
      } catch (error) {
        console.error('スマレジ連携エラー:', error);

        // スマレジ連携に失敗しても会計自体は完了させる
        const { error: updateError } = await supabase
          .from('checkouts')
          .update({
            status: 'completed'
          })
          .eq('checkout_id', checkout.checkout_id);

        if (updateError) {
          console.error('会計ステータス更新エラー:', updateError);
          return NextResponse.json(
            { error: '会計ステータスの更新に失敗しました' },
            { status: 500 }
          );
        }
      }
    } else {
      // スマレジ連携が無効の場合は、そのまま会計完了とする
      const { error: updateError } = await supabase
        .from('checkouts')
        .update({
          status: 'completed'
        })
        .eq('checkout_id', checkout.checkout_id);

      if (updateError) {
        console.error('会計ステータス更新エラー:', updateError);
        return NextResponse.json(
          { error: '会計ステータスの更新に失敗しました' },
          { status: 500 }
        );
      }
    }

    // 注文ステータスを更新（closedに変更）
    if (orders && orders.length > 0) {
      const orderIds = orders.map(order => order.order_id);
      const { error: orderUpdateError } = await supabase
        .from('orders')
        .update({
          status: 'closed'
        })
        .in('order_id', orderIds);

      if (orderUpdateError) {
        console.error('注文ステータス更新エラー:', orderUpdateError);
        // エラーがあっても処理は続行
      }
    }

    // レスポンスデータを準備
    const responseData = {
      checkout_id: checkout.checkout_id,
      total_amount: totalAmount, // 税込み合計金額
      charge_amount: chargeAmount,
      order_amount: orderAmount,
      tax_amount: taxAmount,
      tax_rate: taxRate,
      subtotal_amount: subtotalAmount, // 税抜き合計金額
      status: 'completed'
    };


    return NextResponse.json(responseData);
  } catch (error) {
    console.error('会計API: 予期せぬエラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/dashboard/sessions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;



    // 優先順位: ヘッダー > Cookieストア
    const storeId = storeIdFromHeader || storeIdFromStore;

    if (!storeId) {
      console.error('GET /api/dashboard/sessions: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // リクエストヘッダーからSupabase認証トークンを抽出
    const authTokenMatch = requestCookies?.match(/sb-[^-]+-auth-token=([^;]+)/);
    const authToken = authTokenMatch ? decodeURIComponent(authTokenMatch[1]) : null;



    if (!authToken) {
      // 認証トークンがなくても続行（サービスロールを使用するため）
    }

    const supabase = await createServerSupabaseClient();

    // アクティブなセッションを取得
    const { data: sessions, error } = await supabase
      .from('sessions')
      .select(`
        session_id,
        start_at,
        charge_started_at,
        charge_paused_at,
        tables (
          table_id,
          name,
          seat_types (
            seat_type_id,
            display_name,
            price_per_unit,
            time_unit_minutes
          )
        )
      `)
      .eq('store_id', storeId)
      .not('charge_started_at', 'is', null)
      .order('start_at', { ascending: false });

    if (error) {
      console.error('セッション取得エラー:', error);
      return NextResponse.json(
        { error: 'セッション情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(sessions);
  } catch (error) {
    console.error('セッション取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/logout/route.ts">
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

// 共通の設定
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;

export async function POST(request: NextRequest) {
  try {
    // Cookieベースのクライアント
    const authClient = await createServerComponentClient();

    // ログアウト処理
    await authClient.auth.signOut();

    // Cookieの削除
    const cookieStore = await cookies();

    const allCookies = cookieStore.getAll();

    // すべての関連Cookieを削除
    const supabaseAuthCookie = `sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`;
    cookieStore.delete(supabaseAuthCookie);
    cookieStore.delete('store-id');



    // ホームページにリダイレクト
    return NextResponse.redirect(new URL('/', request.url));

  } catch (error) {
    console.error('Logout error:', error);
    return NextResponse.json(
      { error: 'ログアウト処理中にエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/menu-categories/[category_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';

// カテゴリ取得API
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ category_id: string }> }
) {
  try {
    const { category_id } = await params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // カテゴリー情報を取得
    const { data: category, error } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('category_id', category_id)
      .eq('store_id', storeId)
      .single();

    if (error) {
      console.error('カテゴリー取得エラー:', error);
      return NextResponse.json(
        { error: 'カテゴリー情報の取得に失敗しました' },
        { status: 404 }
      );
    }

    return NextResponse.json(category);
  } catch (error) {
    console.error('カテゴリー取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

// カテゴリ更新API
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ category_id: string }> }
) {
  try {
    const { category_id } = await params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // カテゴリ情報を取得
    const { data: category } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('category_id', category_id)
      .eq('store_id', storeId)
      .single();

    if (!category) {
      return NextResponse.json(
        { error: 'カテゴリが見つかりません' },
        { status: 404 }
      );
    }

    // リクエストボディを取得
    const data = await request.json();

    // バリデーション
    if (!data.name) {
      return NextResponse.json(
        { error: 'カテゴリ名は必須です' },
        { status: 400 }
      );
    }

    // カテゴリを更新
    const { data: updatedCategory, error: updateError } = await supabase
      .from('menu_categories')
      .update({
        name: data.name,
        display_order: data.display_order !== undefined ? data.display_order : category.display_order,
        smaregi_category_id: data.smaregi_category_id !== undefined ? data.smaregi_category_id : category.smaregi_category_id,
        allow_treat_cast: data.allow_treat_cast !== undefined ? data.allow_treat_cast : category.allow_treat_cast
      })
      .eq('category_id', category_id)
      .select()
      .single();

    if (updateError) {
      // 一意制約違反の場合
      if (updateError.code === '23505') {
        return NextResponse.json(
          { error: '同じ名前のカテゴリが既に存在します' },
          { status: 400 }
        );
      }

      console.error('カテゴリ更新エラー:', updateError);
      return NextResponse.json(
        { error: 'カテゴリの更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(updatedCategory);
  } catch (error) {
    console.error('カテゴリ更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

// カテゴリ削除API
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ category_id: string }> }
) {
  try {
    const { category_id } = await params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // カテゴリ情報を取得
    const { data: category } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('category_id', category_id)
      .eq('store_id', storeId)
      .single();

    if (!category) {
      return NextResponse.json(
        { error: 'カテゴリが見つかりません' },
        { status: 404 }
      );
    }

    // このカテゴリに属するメニュー数を確認
    const { count, error: countError } = await supabase
      .from('menus')
      .select('*', { count: 'exact', head: true })
      .eq('category_id', category_id);

    if (countError) {
      console.error('メニュー数取得エラー:', countError);
      return NextResponse.json(
        { error: 'メニュー数の取得に失敗しました' },
        { status: 500 }
      );
    }

    // メニューが存在する場合は削除不可
    if (count && count > 0) {
      return NextResponse.json(
        { error: 'このカテゴリに属するメニューが存在するため削除できません' },
        { status: 400 }
      );
    }

    // 削除前の全カテゴリを取得（デバッグ用）
    const { data: beforeCategories } = await supabase
      .from('menu_categories')
      .select('category_id, name, display_order')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true });

    console.log('削除前のカテゴリ一覧:', beforeCategories);

    // 削除するカテゴリの表示順を保存
    const deletedCategoryOrder = category.display_order;
    console.log('削除するカテゴリの表示順:', deletedCategoryOrder);

    // カテゴリを削除
    const { error: deleteError } = await supabase
      .from('menu_categories')
      .delete()
      .eq('category_id', category_id);

    if (deleteError) {
      console.error('カテゴリ削除エラー:', deleteError);
      return NextResponse.json(
        { error: 'カテゴリの削除に失敗しました' },
        { status: 500 }
      );
    }

    console.log('カテゴリを削除しました。カテゴリID:', category_id);

    // 全カテゴリを取得
    const { data: allCategories, error: fetchError } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true });

    if (fetchError) {
      console.error('カテゴリ取得エラー:', fetchError);
      // エラーがあっても、カテゴリ自体は削除されているので成功として返す
    } else {
      console.log('全カテゴリ:', allCategories);

      if (allCategories && allCategories.length > 0) {
        console.log('カテゴリ数:', allCategories.length);

        // 更新が必要なカテゴリのリストを作成
        const categoriesToUpdate = [];

        for (let i = 0; i < allCategories.length; i++) {
          const category = allCategories[i];
          const newOrder = i + 1; // 1から始まる連番

          // 表示順が変わる場合のみリストに追加
          if (category.display_order !== newOrder) {
            console.log(`カテゴリ "${category.name}" の表示順を ${category.display_order} から ${newOrder} に更新します`);
            categoriesToUpdate.push({
              ...category,
              display_order: newOrder
            });
          }
        }

        // 更新が必要なカテゴリがある場合
        if (categoriesToUpdate.length > 0) {
          console.log('更新するカテゴリ数:', categoriesToUpdate.length);

          // 一括更新
          for (const category of categoriesToUpdate) {
            const { error: updateError } = await supabase
              .from('menu_categories')
              .update({ display_order: category.display_order })
              .eq('category_id', category.category_id);

            if (updateError) {
              console.error(`カテゴリ "${category.name}" の表示順更新エラー:`, updateError);
            } else {
              console.log(`カテゴリ "${category.name}" の表示順を ${category.display_order} に更新しました`);
            }

            // 更新間隔を空ける（競合を避けるため）
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        } else {
          console.log('更新が必要なカテゴリはありません');
        }
      } else {
        console.log('カテゴリがありません');
      }
    }

    // 更新後の全カテゴリを取得（デバッグ用）
    const { data: afterCategories } = await supabase
      .from('menu_categories')
      .select('category_id, name, display_order')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true });

    console.log('更新後のカテゴリ一覧:', afterCategories);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('カテゴリ削除エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/menus/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // メニュー情報を取得
    const { data: menu, error } = await supabase
      .from('menus')
      .select('*')
      .eq('menu_id', id)
      .eq('store_id', storeId)
      .single();

    if (error) {
      console.error('メニュー取得エラー:', error);
      return NextResponse.json(
        { error: 'メニュー情報の取得に失敗しました' },
        { status: 404 }
      );
    }

    return NextResponse.json(menu);
  } catch (error) {
    console.error('メニュー取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    const data = await request.json();

    // バリデーション
    if (!data.name || data.price < 0) {
      return NextResponse.json(
        { error: '必須項目が不足しているか、無効な値です' },
        { status: 400 }
      );
    }

    // メニューが存在するか確認
    const { data: existingMenu, error: checkError } = await supabase
      .from('menus')
      .select('menu_id')
      .eq('menu_id', id)
      .eq('store_id', storeId)
      .single();

    if (checkError || !existingMenu) {
      return NextResponse.json(
        { error: 'メニューが見つかりません' },
        { status: 404 }
      );
    }

    // メニュー情報を更新
    const { data: updatedMenu, error: updateError } = await supabase
      .from('menus')
      .update({
        name: data.name,
        description: data.description || null,
        price: data.price,
        image_url: data.image_url || null,
        category: data.category || null,
        category_id: data.category_id || null,
        is_available: data.is_available !== false,
      })
      .eq('menu_id', id)
      .eq('store_id', storeId)
      .select()
      .single();

    if (updateError) {
      console.error('メニュー更新エラー:', updateError);
      return NextResponse.json(
        { error: 'メニュー情報の更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(updatedMenu);
  } catch (error) {
    console.error('メニュー更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // メニューが存在するか確認
    const { data: existingMenu, error: checkError } = await supabase
      .from('menus')
      .select('menu_id')
      .eq('menu_id', id)
      .eq('store_id', storeId)
      .single();

    if (checkError || !existingMenu) {
      return NextResponse.json(
        { error: 'メニューが見つかりません' },
        { status: 404 }
      );
    }

    // メニューを削除
    const { error: deleteError } = await supabase
      .from('menus')
      .delete()
      .eq('menu_id', id)
      .eq('store_id', storeId);

    if (deleteError) {
      console.error('メニュー削除エラー:', deleteError);
      return NextResponse.json(
        { error: 'メニューの削除に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('メニュー削除エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/order-items/[order_item_id]/route.ts">
import { createServerSupabaseClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

// 注文アイテムを削除するAPI
export async function DELETE(
  request: NextRequest,
  context: { params: Promise<{ order_item_id: string }> }
) {
  try {
    const { order_item_id: orderItemId } = await context.params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const supabase = await createServerSupabaseClient();

    // 注文アイテムが存在し、正しい店舗に属しているか確認
    const { data: orderItem, error: orderItemError } = await supabase
      .from('order_items')
      .select(`
        order_item_id,
        orders (
          order_id,
          store_id
        )
      `)
      .eq('order_item_id', orderItemId)
      .single();

    if (orderItemError || !orderItem || !orderItem.orders || orderItem.orders.store_id !== storeId) {
      return NextResponse.json(
        { error: '注文アイテムが見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    // 注文アイテムを削除
    const { error: deleteError } = await supabase
      .from('order_items')
      .delete()
      .eq('order_item_id', orderItemId);

    if (deleteError) {
      return NextResponse.json(
        { error: '注文アイテムの削除に失敗しました' },
        { status: 500 }
      );
    }

    // Broadcast Channelにメッセージを送信
    await supabase.from('broadcast').insert({
      channel: 'broadcast:orders',
      payload: {
        type: 'order_item:delete',
        order_item_id: orderItemId,
      },
    });

    // 成功レスポンスを返す
    return NextResponse.json({
      success: true,
      order_item_id: orderItemId
    });

  } catch (error) {
    console.error('Order item delete error:', error);
    return NextResponse.json(
      { error: '注文アイテムの削除中にエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/order-items/[order_item_id]/status/route.ts">
import { createServerSupabaseClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

// PATCHメソッドでステータスを更新
export async function PATCH(
  request: NextRequest,
  context: { params: Promise<{ order_item_id: string }> }
) {
  try {
    const { order_item_id: orderItemId } = await context.params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const formData = await request.formData();
    const status = formData.get('status') as string;

    if (!status) {
      return NextResponse.json(
        { error: 'ステータスは必須です' },
        { status: 400 }
      );
    }

    // 有効なステータス値かチェック
    const validStatuses = ['new', 'ack', 'prep', 'served', 'closed', 'cancel'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: '無効なステータス値です' },
        { status: 400 }
      );
    }

    const supabase = await createServerSupabaseClient();

    // 注文アイテムが存在し、正しい店舗に属しているか確認
    const { data: orderItem, error: orderItemError } = await supabase
      .from('order_items')
      .select(`
        order_item_id,
        orders (
          order_id,
          store_id
        )
      `)
      .eq('order_item_id', orderItemId)
      .single();

    if (orderItemError || !orderItem || !orderItem.orders || orderItem.orders.store_id !== storeId) {
      return NextResponse.json(
        { error: '注文アイテムが見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    // 注文アイテムのステータスを更新
    console.log(`注文アイテム ${orderItemId} のステータスを ${status} に更新します`);
    const { error: updateError } = await supabase
      .from('order_items')
      .update({ status })
      .eq('order_item_id', orderItemId);

    if (updateError) {
      console.error('注文アイテムステータス更新エラー:', updateError);
      return NextResponse.json(
        { error: `注文アイテムステータスの更新に失敗しました: ${updateError.message}` },
        { status: 500 }
      );
    }

    // Broadcast Channelにメッセージを送信
    await supabase.from('broadcast').insert({
      channel: 'broadcast:orders',
      payload: {
        type: 'order_item:update',
        order_item_id: orderItemId,
        status,
      },
    });

    // 成功レスポンスを返す
    return NextResponse.json({
      success: true,
      order_item_id: orderItemId,
      status: status
    });

  } catch (error) {
    console.error('Order item status update error:', error);
    const errorMessage = error instanceof Error ? error.message : '不明なエラー';
    const errorStack = error instanceof Error ? error.stack : '';
    console.error('エラースタック:', errorStack);
    return NextResponse.json(
      { error: `注文アイテムステータスの更新中にエラーが発生しました: ${errorMessage}` },
      { status: 500 }
    );
  }
}

// POSTメソッドでも同じ処理を行う
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ order_item_id: string }> }
) {
  return PATCH(request, context);
}
</file>

<file path="app/api/orders/[order_id]/items/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ order_id: string }> }
) {
  try {
    const { order_id } = await params;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 注文が存在し、正しい店舗に属しているか確認
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('order_id, store_id, status, created_at, created_by_role, proxy')
      .eq('order_id', order_id)
      .eq('store_id', storeId)
      .single();

    if (orderError || !order) {
      return NextResponse.json(
        { error: '注文が見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    // 注文アイテムを取得
    const { data: orderItems, error: itemsError } = await supabase
      .from('order_items')
      .select(`
        order_item_id,
        product_id,
        product_name,
        quantity,
        price,
        target_cast_id
      `)
      .eq('order_id', order_id);

    if (itemsError) {
      console.error('注文アイテム取得エラー:', itemsError);
      return NextResponse.json(
        { error: '注文アイテムの取得に失敗しました' },
        { status: 500 }
      );
    }

    // ターゲットキャストの情報を取得
    const castIds = orderItems
      .filter(item => item.target_cast_id)
      .map(item => item.target_cast_id);

    // キャストIDと表示名のマッピング
    interface CastMap {
      [key: string]: string;
    }

    let casts: CastMap = {};

    if (castIds.length > 0) {
      // 重複を排除
      const uniqueCastIds = castIds.filter((id, index) => castIds.indexOf(id) === index);

      // store_usersテーブルからキャスト情報を取得
      const { data: castData, error: castError } = await supabase
        .from('store_users')
        .select('user_id, display_name')
        .eq('store_id', storeId)
        .eq('role', 'cast')
        .in('user_id', uniqueCastIds);

      if (!castError && castData) {
        casts = castData.reduce((acc: CastMap, cast) => {
          // display_nameがnullの場合は「キャスト」という名前を使用
          acc[cast.user_id] = cast.display_name || `キャスト${cast.user_id.substring(0, 4)}`;
          return acc;
        }, {});
      } else {
        console.error('キャスト情報取得エラー:', castError);
      }
    }

    // 注文アイテムを整形
    const formattedItems = orderItems.map(item => {
      return {
        order_item_id: item.order_item_id,
        product_id: item.product_id,
        name: item.product_name,
        quantity: item.quantity,
        price: item.price,
        total: item.price * item.quantity,
        target_cast_id: item.target_cast_id,
        target_cast_name: item.target_cast_id ? casts[item.target_cast_id] || '不明なキャスト' : null
      };
    });

    // 合計金額を計算
    const totalPrice = formattedItems.reduce((sum, item) => sum + item.total, 0);

    // テーブル情報を取得
    const { data: orderWithSession, error: sessionError } = await supabase
      .from('orders')
      .select(`
        sessions (
          session_id,
          tables (
            table_id,
            name
          )
        )
      `)
      .eq('order_id', order_id)
      .single();

    let tableName = null;
    if (!sessionError && orderWithSession && orderWithSession.sessions && orderWithSession.sessions.tables) {
      tableName = orderWithSession.sessions.tables.name;
    }

    return NextResponse.json({
      order: {
        order_id: order.order_id,
        status: order.status,
        created_at: order.created_at,
        created_by_role: order.created_by_role,
        proxy: order.proxy,
        table_name: tableName
      },
      items: formattedItems,
      totalPrice
    });
  } catch (error) {
    console.error('注文詳細取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/orders/[order_id]/status/route.ts">
import { createServerSupabaseClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

// PATCHメソッドとPOSTメソッドの両方をサポート
export async function PATCH(
  request: NextRequest,
  context: { params: Promise<{ order_id: string }> }
) {
  try {
    const { order_id: orderId } = await context.params;
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const formData = await request.formData();
    const status = formData.get('status') as string;

    if (!status) {
      return NextResponse.json(
        { error: 'ステータスは必須です' },
        { status: 400 }
      );
    }

    // 有効なステータス値かチェック
    const validStatuses = ['new', 'ack', 'prep', 'served', 'closed', 'cancel'];
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: '無効なステータス値です' },
        { status: 400 }
      );
    }

    const supabase = await createServerSupabaseClient();

    // 注文が存在し、正しい店舗に属しているか確認
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('order_id, store_id')
      .eq('order_id', orderId)
      .eq('store_id', storeId)
      .single();

    if (orderError || !order) {
      return NextResponse.json(
        { error: '注文が見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    // 注文ステータスを更新
    const { error: updateError } = await supabase
      .from('orders')
      .update({ status })
      .eq('order_id', orderId);

    if (updateError) {
      return NextResponse.json(
        { error: '注文ステータスの更新に失敗しました' },
        { status: 500 }
      );
    }

    // Broadcast Channelにメッセージを送信
    await supabase.from('broadcast').insert({
      channel: 'broadcast:orders',
      payload: {
        type: 'order:update',
        order_id: orderId,
        status,
      },
    });

    // 成功レスポンスを返す（リダイレクトではなく）
    return NextResponse.json({
      success: true,
      order_id: orderId,
      status: status
    });

  } catch (error) {
    console.error('Order status update error:', error);
    return NextResponse.json(
      { error: '注文ステータスの更新中にエラーが発生しました' },
      { status: 500 }
    );
  }
}

// POSTメソッドでも同じ処理を行う
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ order_id: string }> }
) {
  return PATCH(request, context);
}
</file>

<file path="app/api/orders/active-items/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;



    // 優先順位: ヘッダー > Cookieストア
    const storeId = storeIdFromHeader || storeIdFromStore;

    if (!storeId) {
      console.error('GET /api/orders/active-items: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const allCookies = cookieStore.getAll();

    const supabase = await createServerSupabaseClient();

    // アクティブな注文を取得
    const { data: orders, error } = await supabase
      .from('orders')
      .select(`
        order_id,
        status,
        created_by_role,
        proxy,
        created_at,
        sessions (
          session_id,
          tables (
            table_id,
            name
          )
        ),
        order_items (
          order_item_id,
          product_id,
          product_name,
          quantity,
          price,
          target_cast_id,
          status
        )
      `)
      .eq('store_id', storeId)
      .not('status', 'eq', 'closed')
      .not('status', 'eq', 'cancel')
      .order('created_at', { ascending: true });

    if (error) {
      console.error('注文取得エラー:', error);
      return NextResponse.json(
        { error: '注文情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // ターゲットキャストの情報を取得
    const castIds = orders
      .flatMap(order => order.order_items || [])
      .filter(item => item.target_cast_id)
      .map(item => item.target_cast_id);

    // キャストIDと表示名のマッピング
    interface CastMap {
      [key: string]: string;
    }

    let casts: CastMap = {};

    if (castIds.length > 0) {
      // 重複を排除
      const uniqueCastIds = castIds.filter((id, index) => castIds.indexOf(id) === index);

      // store_usersテーブルからキャスト情報を取得
      const { data: castData, error: castError } = await supabase
        .from('store_users')
        .select('user_id, display_name')
        .eq('store_id', storeId)
        .eq('role', 'cast')
        .in('user_id', uniqueCastIds);

      if (!castError && castData) {
        casts = castData.reduce((acc: CastMap, cast) => {
          // display_nameがnullの場合は「キャスト」という名前を使用
          acc[cast.user_id] = cast.display_name || `キャスト${cast.user_id.substring(0, 4)}`;
          return acc;
        }, {});
      } else {
        console.error('キャスト情報取得エラー:', castError);
      }
    }

    // 注文アイテムを含む注文データを整形
    const formattedOrderItems = orders.flatMap(order => {
      if (!order.order_items || order.order_items.length === 0) {
        return [];
      }

      // すべての注文アイテムを処理
      return order.order_items
        .map(item => {
          return {
            order_id: order.order_id,
            order_item_id: item.order_item_id,
            // 注文アイテム自身のステータスを使用（存在しない場合は親注文のステータスをフォールバックとして使用）
            status: item.status || order.status,
            created_at: order.created_at,
            created_by_role: order.created_by_role,
            proxy: order.proxy,
            table_name: order.sessions?.tables?.name || '不明なテーブル',
            product_id: item.product_id,
            product_name: item.product_name,
            quantity: item.quantity,
            price: item.price,
            total: item.price * item.quantity,
            target_cast_id: item.target_cast_id,
            target_cast_name: item.target_cast_id ? casts[item.target_cast_id] || '不明なキャスト' : null
          };
        });
    });

    return NextResponse.json(formattedOrderItems);
  } catch (error) {
    console.error('注文取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/orders/active/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;



    // 優先順位: ヘッダー > Cookieストア
    const storeId = storeIdFromHeader || storeIdFromStore;

    if (!storeId) {
      console.error('GET /api/orders/active: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const allCookies = cookieStore.getAll();

    const supabase = await createServerSupabaseClient();

    // アクティブな注文を取得
    const { data: orders, error } = await supabase
      .from('orders')
      .select(`
        order_id,
        status,
        created_by_role,
        proxy,
        created_at,
        sessions (
          session_id,
          tables (
            table_id,
            name
          )
        )
      `)
      .eq('store_id', storeId)
      .not('status', 'eq', 'closed')
      .not('status', 'eq', 'cancel')
      .order('created_at', { ascending: false });

    if (error) {
      console.error('注文取得エラー:', error);
      return NextResponse.json(
        { error: '注文情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(orders);
  } catch (error) {
    console.error('注文取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/orders/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function POST(request: NextRequest) {
  try {
    // リクエストボディを取得
    const data = await request.json();

    // バリデーション
    if (!data.session_id || !data.items || !Array.isArray(data.items) || data.items.length === 0) {
      return NextResponse.json(
        { error: '必須項目が不足しているか、無効な値です' },
        { status: 400 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッション情報を取得して店舗IDを特定
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select('store_id')
      .eq('session_id', data.session_id)
      .single();

    if (sessionError || !session) {
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 注文を作成
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        store_id: session.store_id,
        session_id: data.session_id,
        status: 'new',
        created_by_role: data.created_by_role || 'customer',
        proxy: data.proxy || false
      })
      .select()
      .single();

    if (orderError) {
      console.error('注文作成エラー:', orderError);
      return NextResponse.json(
        { error: '注文の作成に失敗しました' },
        { status: 500 }
      );
    }

    // 注文明細を作成
    interface OrderItem {
      product_id: string;
      name: string;
      quantity: number;
      price: number;
      target_cast_id?: string | null;
    }

    const orderItems = data.items.map((item: OrderItem) => ({
      order_id: order.order_id,
      product_id: item.product_id,
      product_name: item.name,
      quantity: item.quantity,
      price: item.price,
      target_cast_id: item.target_cast_id || null,
      status: 'new' // 新規注文アイテムのステータスを設定
    }));

    const { error: itemsError } = await supabase
      .from('order_items')
      .insert(orderItems);

    if (itemsError) {
      console.error('注文明細作成エラー:', itemsError);

      // 注文明細の作成に失敗した場合、注文自体を削除
      await supabase
        .from('orders')
        .delete()
        .eq('order_id', order.order_id);

      return NextResponse.json(
        { error: '注文明細の作成に失敗しました' },
        { status: 500 }
      );
    }

    // Broadcast Channelにメッセージを送信
    await supabase.from('broadcast').insert({
      channel: 'broadcast:orders',
      payload: {
        type: 'order:new',
        order_id: order.order_id,
        table_id: data.table_id,
        status: 'new',
      },
    });

    return NextResponse.json({
      order_id: order.order_id,
      status: order.status,
      created_at: order.created_at
    }, { status: 201 });
  } catch (error) {
    console.error('注文作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/proxy-order/active-tables/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;



    // 優先順位: ヘッダー > Cookieストア
    const storeId = storeIdFromHeader || storeIdFromStore;

    const allCookies = cookieStore.getAll();

    if (!storeId) {
      console.error('GET /api/proxy-order/active-tables: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const supabase = await createServerSupabaseClient();

    // まず、アクティブなセッションを取得
    const { data: sessions, error: sessionsError } = await supabase
      .from('sessions')
      .select('session_id, table_id, charge_started_at')
      .eq('store_id', storeId)
      .not('charge_started_at', 'is', null)
      .order('start_at', { ascending: false });

    if (sessionsError) {
      console.error('セッション取得エラー:', sessionsError);
      return NextResponse.json(
        { error: 'セッション情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // セッションがない場合は空の配列を返す
    if (!sessions || sessions.length === 0) {
      return NextResponse.json([]);
    }

    // セッションに関連するテーブル情報を取得
    const tableIds = sessions.map(session => session.table_id);

    const { data: tables, error: tablesError } = await supabase
      .from('tables')
      .select(`
        table_id,
        name,
        seat_type_id,
        seat_types (
          seat_type_id,
          display_name
        )
      `)
      .in('table_id', tableIds);

    if (tablesError) {
      console.error('テーブル取得エラー:', tablesError);
      return NextResponse.json(
        { error: 'テーブル情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // テーブルIDをキーにしたマップを作成
    const tableMap = new Map();
    tables?.forEach(table => {
      tableMap.set(table.table_id, table);
    });

    // セッションとテーブル情報を組み合わせる
    const activeTables = sessions.map(session => {
      const table = tableMap.get(session.table_id);
      if (!table) return null;

      return {
        table_id: table.table_id,
        name: table.name,
        session_id: session.session_id,
        seat_type: table.seat_types?.display_name || '不明'
      };
    }).filter(Boolean);

    return NextResponse.json(activeTables);
  } catch (error) {
    console.error('アクティブテーブル取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/seat-types/[id]/route.ts">
import { createServerSupabaseClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    // UUIDとして処理（数値変換は不要）
    const seatTypeId = id;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const supabase = await createServerSupabaseClient();

    // 席種情報を取得
    const { data: seatType, error } = await supabase
      .from('seat_types')
      .select('*')
      .eq('seat_type_id', seatTypeId)
      .eq('store_id', storeId)
      .single();

    if (error || !seatType) {
      return NextResponse.json(
        { error: '席種が見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    return NextResponse.json(seatType);
  } catch (error) {
    console.error('席種取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    // UUIDとして処理（数値変換は不要）
    const seatTypeId = id;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const data = await request.json();

    // デバッグ用に受け取ったデータをログに出力
    console.log('PATCH /api/seat-types/[id] 受信データ:', data);

    // バリデーション
    const price = data.price_per_unit;
    if (!data.display_name || price === undefined || price < 0 || !data.time_unit_minutes || data.time_unit_minutes <= 0) {
      return NextResponse.json(
        { error: '必須項目が不足しているか、無効な値です' },
        { status: 400 }
      );
    }

    // 既存の席種のコードを取得して使用
    const supabase = await createServerSupabaseClient();

    // 席種が存在し、正しい店舗に属しているか確認
    const { data: existingSeatType, error: fetchError } = await supabase
      .from('seat_types')
      .select('*')
      .eq('seat_type_id', seatTypeId)
      .eq('store_id', storeId)
      .single();

    if (fetchError || !existingSeatType) {
      return NextResponse.json(
        { error: '席種が見つからないか、アクセス権がありません' },
        { status: 404 }
      );
    }

    // マイグレーション後はcodeカラムは存在しないため、この処理は不要
    // data.code = existingSeatType.code;

    // マイグレーション後はcodeカラムは存在しないため、重複チェックは不要

    // 席種を更新
    const { data: updatedSeatType, error: updateError } = await supabase
      .from('seat_types')
      .update({
        display_name: data.display_name,
        price_per_unit: data.price_per_unit,
        time_unit_minutes: data.time_unit_minutes || 30, // デフォルトは30分
        smaregi_product_id: data.smaregi_product_id || null
      })
      .eq('seat_type_id', seatTypeId)
      .eq('store_id', storeId)
      .select()
      .single();

    if (updateError) {
      console.error('席種更新エラー:', updateError);
      return NextResponse.json(
        { error: '席種の更新に失敗しました' },
        { status: 500 }
      );
    }

    // デバッグ用に更新結果をログに出力
    console.log('席種更新結果:', updatedSeatType);

    return NextResponse.json(updatedSeatType);
  } catch (error) {
    console.error('席種更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/seat-types/route.ts">
import { createServerSupabaseClient } from '@/lib/supabase';
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // URLからクエリパラメータを取得
    const url = new URL(request.url);
    const storeIdFromQuery = url.searchParams.get('storeId');

    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;
    const storeIdFromStoreLegacy = cookieStore.get('storeId')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;

    // リクエストヘッダーからstoreIdを抽出（レガシー形式）
    const storeIdLegacyMatch = requestCookies?.match(/storeId=([^;]+)/);
    const storeIdLegacyFromHeader = storeIdLegacyMatch ? storeIdLegacyMatch[1] : null;



    // 優先順位: クエリパラメータ > ヘッダー > Cookieストア、新形式 > レガシー形式
    const storeId = storeIdFromQuery || storeIdFromHeader || storeIdLegacyFromHeader || storeIdFromStore || storeIdFromStoreLegacy;

    // const allCookies = cookieStore.getAll(); // 未使用のため削除

    if (!storeId) {
      console.error('GET /api/seat-types: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }



    const supabase = await createServerSupabaseClient();

    // 店舗に紐づいた席種一覧を取得
    const { data: seatTypes, error } = await supabase
      .from('seat_types')
      .select('*')
      .eq('store_id', storeId)
      .order('display_name');

    if (error) {
      console.error('席種一覧取得エラー:', error);
      return NextResponse.json(
        { error: '席種一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(seatTypes);
  } catch (error) {
    console.error('席種一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    const data = await request.json();

    // バリデーション
    const price = data.price_per_unit;
    if (!data.display_name || price === undefined || price < 0 || !data.time_unit_minutes || data.time_unit_minutes <= 0) {
      return NextResponse.json(
        { error: '必須項目が不足しているか、無効な値です' },
        { status: 400 }
      );
    }

    // コードはデータベース側で自動生成されるため、ここでは何もしない
    // 既存のコードがある場合（編集時など）はそれを使用

    // store_idを確実に設定
    data.store_id = storeId;

    const supabase = await createServerSupabaseClient();

    // コードはデータベース側で自動生成されるため、重複チェックは不要

    // 席種を作成（codeはデータベース側で自動生成）
    const { data: newSeatType, error } = await supabase
      .from('seat_types')
      .insert({
        display_name: data.display_name,
        price_per_unit: data.price_per_unit,
        time_unit_minutes: data.time_unit_minutes || 30, // デフォルトは30分
        store_id: storeId,
        smaregi_product_id: data.smaregi_product_id || null
      })
      .select()
      .single();

    if (error) {
      console.error('席種作成エラー:', error);
      return NextResponse.json(
        { error: '席種の作成に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(newSeatType, { status: 201 });
  } catch (error) {
    console.error('席種作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sessions/[session_id]/move/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function POST(
  request: NextRequest,
  { params }: { params: { session_id: string } }
) {
  try {
    const { session_id } = params;
    const data = await request.json();
    const { target_table_id } = data;

    if (!target_table_id) {
      return NextResponse.json(
        { error: '移動先テーブルIDが指定されていません' },
        { status: 400 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 移動元セッション情報を取得
    const { data: sourceSession, error: sessionError } = await supabase
      .from('sessions')
      .select(`
        session_id,
        store_id,
        table_id,
        start_at,
        charge_started_at,
        charge_paused_at,
        selected_cast_id,
        is_new_customer,
        tables (
          table_id,
          seat_type_id,
          seat_types (
            seat_type_id,
            display_name,
            price_per_unit,
            time_unit_minutes
          )
        )
      `)
      .eq('session_id', session_id)
      .single();

    if (sessionError || !sourceSession) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 移動先テーブル情報を取得
    const { data: targetTable, error: tableError } = await supabase
      .from('tables')
      .select(`
        table_id,
        store_id,
        seat_type_id,
        seat_types (
          seat_type_id,
          display_name,
          price_per_unit,
          time_unit_minutes
        )
      `)
      .eq('table_id', target_table_id)
      .single();

    if (tableError || !targetTable) {
      console.error('テーブル取得エラー:', tableError);
      return NextResponse.json(
        { error: '移動先テーブルが見つかりません' },
        { status: 404 }
      );
    }

    // 同じ店舗内での移動かチェック
    if (sourceSession.store_id !== targetTable.store_id) {
      return NextResponse.json(
        { error: '異なる店舗のテーブルには移動できません' },
        { status: 400 }
      );
    }

    // 移動先テーブルに既存のアクティブなセッションがないか確認
    const { data: existingTargetSession, error: targetSessionError } = await supabase
      .from('sessions')
      .select('session_id')
      .eq('table_id', target_table_id)
      .not('charge_started_at', 'is', null)
      .maybeSingle();

    if (existingTargetSession) {
      return NextResponse.json(
        { error: '移動先テーブルは既に使用中です' },
        { status: 400 }
      );
    }

    // 席種が変わる場合の処理
    const sourceTableSeatTypeId = sourceSession.tables?.seat_type_id;
    const targetTableSeatTypeId = targetTable.seat_type_id;

    // 現在時刻を取得
    const now = new Date();

    // 移動元テーブルでの滞在時間に応じた料金を計算
    let currentTableCharge = 0;
    if (sourceSession.charge_started_at) {
      // 移動元テーブルでの滞在時間に応じた料金のみを計算
      // 既存の移動料金を含めないようにするため、直接計算する

      // 最後のsession_seat_eventを取得（通常のイベント、is_table_move_charge=falseのもの）
      const { data: lastEvent, error: lastEventError } = await supabase
        .from('session_seat_events')
        .select('seat_type_id, price_snapshot, changed_at')
        .eq('session_id', session_id)
        .eq('is_table_move_charge', false)
        .order('changed_at', { ascending: false })
        .limit(1)
        .single();

      if (lastEventError) {
        console.error('最後のイベント取得エラー:', lastEventError);
        return NextResponse.json(
          { error: '料金計算に必要な情報の取得に失敗しました' },
          { status: 500 }
        );
      }

      // 席種の時間単位を取得
      const { data: seatType, error: seatTypeError } = await supabase
        .from('seat_types')
        .select('time_unit_minutes')
        .eq('seat_type_id', lastEvent.seat_type_id)
        .single();

      if (seatTypeError) {
        console.error('席種情報取得エラー:', seatTypeError);
        return NextResponse.json(
          { error: '席種情報の取得に失敗しました' },
          { status: 500 }
        );
      }

      // 時間単位（デフォルトは30分）
      const timeUnitMinutes = seatType.time_unit_minutes > 0 ? seatType.time_unit_minutes : 30;

      // 最後のイベントからの経過時間を計算（分単位）
      const lastEventTime = new Date(lastEvent.changed_at);
      const elapsedMs = now.getTime() - lastEventTime.getTime();
      const elapsedMinutes = elapsedMs / (1000 * 60);

      // 0分時点での移動の場合は特別処理
      if (elapsedMinutes < 1) {
        // 0分時点での移動の場合、最低料金を適用（1単位分）
        currentTableCharge = lastEvent.price_snapshot;
        console.log('0分時点での移動: 最低料金を適用', currentTableCharge);
      } else {
        // 通常の計算（1分以上経過している場合）
        // 時間単位で切り上げ
        const roundedMinutes = Math.ceil(elapsedMinutes / timeUnitMinutes) * timeUnitMinutes;

        // 時間単位の数を計算
        const timeUnits = roundedMinutes / timeUnitMinutes;

        // 現在のテーブルでの料金を計算
        currentTableCharge = timeUnits * lastEvent.price_snapshot;
      }
    }

    // 移動先テーブルの席種情報を取得
    const targetSeatPrice = targetTable.seat_types?.price_per_unit || 0;

    // 現在時刻から1ミリ秒前の時刻を計算（移動元テーブルの料金記録用）
    const moveChargeTime = new Date(now.getTime() - 1);

    // 移動元テーブルの料金を記録するためのsession_seat_eventを作成（料金が0より大きい場合のみ）
    if (currentTableCharge > 0) {
      try {
        // 特別なsession_seat_eventを作成（移動前の料金を記録）
        // is_table_move_chargeフラグをtrueに設定して移動前の料金を記録
        const { error: eventError } = await supabase
          .from('session_seat_events')
          .insert({
            session_id: session_id,
            seat_type_id: sourceTableSeatTypeId, // 移動元の席種ID
            price_snapshot: currentTableCharge, // 現在のテーブルでの料金のみを記録
            changed_at: moveChargeTime.toISOString(), // 現在時刻より少し前の時刻を設定
            is_table_move_charge: true // 席移動料金フラグをtrueに設定
          });

        if (eventError) {
          console.error('移動前料金記録エラー:', eventError);
          return NextResponse.json(
            { error: '移動前料金の記録に失敗しました' },
            { status: 500 }
          );
        }
      } catch (error) {
        console.error('移動前料金記録例外:', error);
        // エラーがあっても処理は続行
      }
    }

    // 新しいsession_seat_eventを作成（席種が変わる場合も変わらない場合も）
    // 必ず移動元テーブルの料金記録の後に作成する
    const { error: eventError } = await supabase
      .from('session_seat_events')
      .insert({
        session_id: session_id,
        seat_type_id: targetTableSeatTypeId, // 移動先の席種ID
        price_snapshot: targetSeatPrice, // 移動先テーブルの席種の料金
        changed_at: now.toISOString(), // 現在時刻を設定
        is_table_move_charge: false // 通常のイベントとして記録
      });

    if (eventError) {
      console.error('席種イベント作成エラー:', eventError);
      return NextResponse.json(
        { error: '席種イベントの作成に失敗しました' },
        { status: 500 }
      );
    }

    // セッションのテーブルIDを更新し、課金開始時間を現在時刻に設定
    const updateData: any = {
      table_id: target_table_id
    };

    // 課金開始時間を設定（元のセッションで課金が開始されていなくても、移動後は課金を開始する）
    updateData.charge_started_at = now.toISOString();

    // 一時停止中だった場合は、一時停止状態を解除
    if (sourceSession.charge_paused_at) {
      updateData.charge_paused_at = null;
    }

    const { data: updatedSession, error: updateError } = await supabase
      .from('sessions')
      .update(updateData)
      .eq('session_id', session_id)
      .select()
      .single();

    if (updateError) {
      console.error('セッション更新エラー:', updateError);
      return NextResponse.json(
        { error: 'セッションの更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: '席移動が完了しました',
      session: updatedSession,
      previous_charge: currentTableCharge
    });
  } catch (error) {
    console.error('席移動エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sessions/[session_id]/orders/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ session_id: string }> }
) {
  try {
    const { session_id } = await params;


    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッションが存在するか確認
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select('session_id')
      .eq('session_id', session_id)
      .single();

    if (sessionError || !session) {
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 注文データを取得（statusがnewのもののみ）
    const { data: orders, error: ordersError } = await supabase
      .from('orders')
      .select(`
        order_id,
        status,
        created_at,
        order_items (
          order_item_id,
          product_id,
          product_name,
          quantity,
          price,
          target_cast_id
        )
      `)
      .eq('session_id', session_id)
      .eq('status', 'new')
      .order('created_at', { ascending: true });

    if (ordersError) {
      console.error('注文データ取得エラー:', ordersError);
      return NextResponse.json(
        { error: '注文データの取得に失敗しました' },
        { status: 500 }
      );
    }

    // セッションから店舗IDを取得
    const { data: sessionData, error: sessionStoreError } = await supabase
      .from('sessions')
      .select('store_id')
      .eq('session_id', session_id)
      .single();

    if (sessionStoreError) {
      console.error('セッション店舗ID取得エラー:', sessionStoreError);
      return NextResponse.json(
        { error: 'セッション情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    const storeId = sessionData.store_id;

    // ターゲットキャストの情報を取得
    const castIds = orders
      .flatMap(order => order.order_items)
      .filter(item => item.target_cast_id)
      .map(item => item.target_cast_id);

    // キャストIDと表示名のマッピング
    interface CastMap {
      [key: string]: string;
    }

    let casts: CastMap = {};
    if (castIds.length > 0) {
      // 重複を排除する別の方法
      const uniqueCastIds = castIds.filter((id, index) => castIds.indexOf(id) === index);

      // store_usersテーブルからキャスト情報を取得
      // 注: user_idはstore_usersテーブルのカラムなので、そのまま取得できる
      const { data: castsData, error: castsError } = await supabase
        .from('store_users')
        .select('*')
        .eq('store_id', storeId)
        .eq('role', 'cast')
        .in('user_id', uniqueCastIds);



      if (!castsError && castsData) {
        casts = castsData.reduce((acc, cast) => {
          // display_nameがnullの場合は「キャスト」という名前を使用
          acc[cast.user_id] = cast.display_name || `キャスト${cast.id.substring(0, 4)}`;
          return acc;
        }, {});
      }
    }

    // 注文データを整形
    const formattedOrders = orders.flatMap(order =>
      order.order_items.map(item => {


        return {
          order_id: order.order_id,
          product_id: item.product_id,
          name: item.product_name,
          quantity: item.quantity,
          price: item.price,
          total: item.price * item.quantity,
          target_cast_id: item.target_cast_id,
          target_cast_name: item.target_cast_id ? casts[item.target_cast_id] || '不明なキャスト' : null
        };
      })
    );

    // 合計金額を計算
    const totalPrice = formattedOrders.reduce((sum, item) => sum + item.total, 0);

    return NextResponse.json({
      orders: formattedOrders,
      totalPrice
    });
  } catch (error) {
    console.error('注文データ取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sessions/[session_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

// セッション削除API
export async function DELETE(
  request: NextRequest,
  { params }: { params: { session_id: string } }
) {
  try {
    const { session_id } = params;
    console.log('セッション削除API: リクエスト受信', { session_id });

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッションが存在するか確認
    const { data: existingSession, error: sessionError } = await supabase
      .from('sessions')
      .select('*')
      .eq('session_id', session_id)
      .single();

    if (sessionError || !existingSession) {
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // セッションを削除
    const { error: deleteError } = await supabase
      .from('sessions')
      .delete()
      .eq('session_id', session_id);

    if (deleteError) {
      console.error('セッション削除エラー:', deleteError);
      return NextResponse.json(
        { error: 'セッションの削除に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'セッションが正常に削除されました'
    });
  } catch (error) {
    console.error('セッション削除処理エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sessions/active/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // URLからクエリパラメータを取得
    const url = new URL(request.url);
    const storeIdFromQuery = url.searchParams.get('storeId');

    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;
    const storeIdFromStoreLegacy = cookieStore.get('storeId')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;

    // リクエストヘッダーからstoreIdを抽出（レガシー形式）
    const storeIdLegacyMatch = requestCookies?.match(/storeId=([^;]+)/);
    const storeIdLegacyFromHeader = storeIdLegacyMatch ? storeIdLegacyMatch[1] : null;



    // 優先順位: クエリパラメータ > ヘッダー > Cookieストア、新形式 > レガシー形式
    const storeId = storeIdFromQuery || storeIdFromHeader || storeIdLegacyFromHeader || storeIdFromStore || storeIdFromStoreLegacy;

    const allCookies = cookieStore.getAll();

    if (!storeId) {
      console.error('GET /api/sessions/active: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }



    const supabase = await createServerSupabaseClient();

    // アクティブなセッション情報を取得（charge_started_atがnullでないものを取得）
    const { data: sessions, error: sessionsError } = await supabase
      .from('sessions')
      .select(`
        session_id,
        table_id,
        start_at,
        charge_started_at,
        charge_paused_at
      `)
      .eq('store_id', storeId)
      .not('charge_started_at', 'is', null)
      .order('start_at', { ascending: false });

    if (sessionsError) {
      console.error('セッション取得エラー:', sessionsError);
      return NextResponse.json(
        { error: 'セッション情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(sessions);
  } catch (error) {
    console.error('セッション取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/smaregi-sync/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';
import { getSmaregiAccessToken, fetchSmaregiProducts, fetchSmaregiCategories, fetchSmaregiAllProductImages } from '@/lib/smaregi';

// スマレジAPIから商品情報を取得して整形する関数
async function getFormattedSmaregiProducts(storeId: string, clientId: string, clientSecret: string, contractId: string) {
  try {
    // スマレジAPIのアクセストークンを取得
    const accessToken = await getSmaregiAccessToken(clientId, clientSecret, contractId);

    // スマレジAPIから商品情報と部門情報を取得
    const products = await fetchSmaregiProducts(accessToken, contractId);
    const categories = await fetchSmaregiCategories(accessToken, contractId);

    // スマレジAPIから全商品画像情報を一括取得
    const allProductImages = await fetchSmaregiAllProductImages(accessToken, contractId);

    // 商品IDと画像URLのマッピングを作成
    const productImageMap = new Map();
    allProductImages.forEach((image: any) => {
      // APIレスポンスには imageUrl または url のどちらかで画像URLが含まれる可能性がある
      const imageUrl = image.imageUrl || image.url;
      if (image.productId && imageUrl) {
        // 同じ商品IDに複数の画像がある場合は上書きされるが、
        // 今回は最初の画像を使用するので問題ない
        productImageMap.set(image.productId, imageUrl);
      }
    });

    // 画像マッピング結果をログ出力
    console.log(`商品画像マッピング作成結果: ${productImageMap.size}件の商品に画像URLをマッピング`);

    // 部門IDと部門名のマッピングを作成
    const categoryMap = new Map();
    categories.forEach((category: any) => {
      categoryMap.set(category.categoryId, category.categoryName);
    });

    // スマレジの部門情報を返す
    const smaregiCategories = categories.map((category: any) => ({
      categoryId: category.categoryId,
      name: category.categoryName,
    }));

    // 商品情報を整形（画像情報を含む）
    const formattedProducts = [];

    // 各商品の情報を整形
    for (const product of products) {
      const categoryName = categoryMap.get(product.categoryId) || null;
      const categoryId = product.categoryId || null;

      // 商品画像を取得
      let imageUrl = product.url || null;

      // 商品画像マッピングから画像URLを取得
      if (product.productId && productImageMap.has(product.productId)) {
        imageUrl = productImageMap.get(product.productId);
      }

      formattedProducts.push({
        productId: product.productCode,
        name: product.productName,
        price: parseInt(product.price, 10),
        categoryName: categoryName,
        categoryId: categoryId,
        description: product.description || null,
        imageUrl: imageUrl,
      });
    }

    return {
      products: formattedProducts,
      categories: smaregiCategories
    };
  } catch (error) {
    console.error('スマレジ商品情報取得エラー:', error);
    throw new Error('スマレジからの商品情報取得に失敗しました');
  }
}

export async function POST(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // APIからユーザー情報を取得
    const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
      headers: {
        Cookie: request.headers.get('cookie') || ''
      }
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    const { user } = await userResponse.json();

    // 管理者でなければエラー
    if (user.role !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗情報を取得
    const { data: store } = await supabase
      .from('stores')
      .select('enable_smaregi_integration, smaregi_client_id, smaregi_client_secret, smaregi_contract_id')
      .eq('store_id', storeId)
      .single();

    if (!store) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 404 }
      );
    }

    // スマレジ連携が無効の場合はエラー
    if (!store.enable_smaregi_integration) {
      return NextResponse.json(
        { error: 'スマレジ連携が無効になっています' },
        { status: 403 }
      );
    }

    // スマレジAPIの認証情報が設定されていない場合はエラー
    if (!store.smaregi_client_id || !store.smaregi_client_secret || !store.smaregi_contract_id) {
      return NextResponse.json(
        { error: 'スマレジAPIの認証情報が設定されていません' },
        { status: 400 }
      );
    }

    // 契約IDを店舗設定から取得
    const contractId = store.smaregi_contract_id;

    // スマレジAPIからメニュー情報を取得
    const smaregiData = await getFormattedSmaregiProducts(
      storeId,
      store.smaregi_client_id,
      store.smaregi_client_secret,
      contractId
    );

    const { products: smaregiProducts, categories: smaregiCategories } = smaregiData;

    // 1. カテゴリを同期
    // 既存のカテゴリを取得
    const { data: existingCategories } = await supabase
      .from('menu_categories')
      .select('category_id, name, smaregi_category_id')
      .eq('store_id', storeId);

    // スマレジカテゴリIDでマッピング（優先）とカテゴリ名でマッピング（後方互換性）
    const existingCategoryMap = new Map();
    const existingCategoryNameMap = new Map();
    existingCategories?.forEach(category => {
      if (category.smaregi_category_id) {
        existingCategoryMap.set(category.smaregi_category_id, category.category_id);
      }
      existingCategoryNameMap.set(category.name, category.category_id);
    });

    // スマレジから取得したカテゴリを登録
    const categoriesToUpsert = [];
    const categoryIdMap = new Map(); // スマレジカテゴリIDとDBカテゴリIDのマッピング

    for (const category of smaregiCategories) {
      if (category.name && category.categoryId) {
        // 既にスマレジカテゴリIDが登録されている場合はそのIDを使用
        if (existingCategoryMap.has(category.categoryId)) {
          categoryIdMap.set(category.categoryId, existingCategoryMap.get(category.categoryId));

          // カテゴリ名が変更されている場合は更新
          const existingCategoryId = existingCategoryMap.get(category.categoryId);
          const existingCategory = existingCategories?.find(c => c.category_id === existingCategoryId);
          if (existingCategory && existingCategory.name !== category.name) {
            await supabase
              .from('menu_categories')
              .update({ name: category.name })
              .eq('category_id', existingCategoryId);
          }
        }
        // 同じ名前のカテゴリが存在する場合は、スマレジカテゴリIDを更新
        else if (existingCategoryNameMap.has(category.name)) {
          const existingCategoryId = existingCategoryNameMap.get(category.name);
          await supabase
            .from('menu_categories')
            .update({ smaregi_category_id: category.categoryId })
            .eq('category_id', existingCategoryId);

          categoryIdMap.set(category.categoryId, existingCategoryId);
        }
        // 新規カテゴリの場合は追加
        else {
          const { data: newCategory, error } = await supabase
            .from('menu_categories')
            .insert({
              store_id: storeId,
              name: category.name,
              smaregi_category_id: category.categoryId,
              display_order: categoriesToUpsert.length + 1
            })
            .select()
            .single();

          if (error) {
            console.error('カテゴリ作成エラー:', error);
            // エラーがあっても処理は続行
          } else if (newCategory) {
            categoryIdMap.set(category.categoryId, newCategory.category_id);
          }
        }
      }
    }

    // 2. メニューを同期
    // 一括更新用のデータを準備
    const menusToUpsert = smaregiProducts.map(product => {
      // カテゴリIDをマッピング
      const dbCategoryId = product.categoryId ? categoryIdMap.get(product.categoryId) : null;

      return {
        store_id: storeId,
        product_id: product.productId,
        name: product.name,
        description: product.description || null,
        price: product.price,
        image_url: product.imageUrl || null,
        category: product.categoryName || null, // 後方互換性のために残す
        category_id: dbCategoryId,
        is_available: true,
      };
    });

    // 画像URL設定結果をログ出力
    const menusWithImage = menusToUpsert.filter(menu => menu.image_url).length;
    console.log(`メニュー画像設定結果: 合計${menusToUpsert.length}件中、画像有り${menusWithImage}件`);

    // 画像URLが設定された最初の5件をサンプルとしてログ出力
    const menuSamples = menusToUpsert.filter(menu => menu.image_url).slice(0, 5);
    if (menuSamples.length > 0) {
      console.log('画像URL設定サンプル:');
      menuSamples.forEach(menu => {
        console.log(`- ${menu.name}: ${menu.image_url}`);
      });
    }

    // メニューを一括更新（upsert）
    const { error: upsertError } = await supabase
      .from('menus')
      .upsert(menusToUpsert, {
        onConflict: 'store_id,product_id',
        ignoreDuplicates: false,
      });

    if (upsertError) {
      console.error('メニュー一括更新エラー:', upsertError);
      return NextResponse.json(
        { error: 'メニューの一括更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      count: menusToUpsert.length,
      message: `${menusToUpsert.length}件のメニューを同期しました`,
    });
  } catch (error) {
    console.error('スマレジ同期エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stores/[store_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ store_id: string }> }
) {
  try {
    const { store_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗情報を取得
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('*')
      .eq('store_id', store_id)
      .single();

    if (storeError || !store) {
      return NextResponse.json(
        { error: '店舗が見つかりません' },
        { status: 404 }
      );
    }

    return NextResponse.json(store);
  } catch (error) {
    console.error('店舗情報取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stores/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(request: NextRequest) {
  try {
    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // 店舗一覧を取得
    const { data: stores, error } = await supabase
      .from('stores')
      .select('store_id, store_code, name')
      .order('name');

    if (error) {
      console.error('店舗一覧取得エラー:', error);
      return NextResponse.json(
        { error: '店舗一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(stores);
  } catch (error) {
    console.error('店舗一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stores/settings/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';

export async function PATCH(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    const data = await request.json();

    // バリデーション
    if (typeof data.enable_smaregi_integration !== 'boolean') {
      return NextResponse.json(
        { error: '無効なデータ形式です' },
        { status: 400 }
      );
    }

    // 消費税率のバリデーション
    if (data.tax_rate !== undefined) {
      const taxRate = parseFloat(data.tax_rate);
      if (isNaN(taxRate) || taxRate < 0 || taxRate > 100) {
        return NextResponse.json(
          { error: '消費税率は0〜100の範囲で入力してください' },
          { status: 400 }
        );
      }
    }

    // スマレジ連携キーのバリデーション
    if (data.enable_smaregi_integration) {
      // スマレジ連携が有効な場合、クライアントID、シークレット、契約IDが必要
      if (!data.smaregi_client_id || !data.smaregi_client_secret || !data.smaregi_contract_id) {
        return NextResponse.json(
          { error: 'スマレジ連携を有効にする場合は、クライアントID、シークレット、契約IDが必要です' },
          { status: 400 }
        );
      }
    }

    // 更新データの準備
    const updateData: any = {
      enable_smaregi_integration: data.enable_smaregi_integration
    };

    // 消費税率が指定されている場合は更新
    if (data.tax_rate !== undefined) {
      updateData.tax_rate = parseFloat(data.tax_rate);
    }

    // スマレジ連携が有効な場合、キー情報も更新
    if (data.enable_smaregi_integration) {
      updateData.smaregi_client_id = data.smaregi_client_id;
      updateData.smaregi_client_secret = data.smaregi_client_secret;
      updateData.smaregi_contract_id = data.smaregi_contract_id;
    }

    // 店舗設定を更新
    const { error: updateError } = await supabase
      .from('stores')
      .update(updateData)
      .eq('store_id', storeId);

    if (updateError) {
      console.error('店舗設定更新エラー:', updateError);
      return NextResponse.json(
        { error: '店舗設定の更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('店舗設定更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/menus/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string }> }
) {
  try {
    const { table_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // テーブル情報を取得して店舗IDを特定
    const { data: table, error: tableError } = await supabase
      .from('tables')
      .select('store_id')
      .eq('table_id', table_id)
      .single();

    if (tableError || !table) {
      return NextResponse.json(
        { error: 'テーブルが見つかりません' },
        { status: 404 }
      );
    }

    // カテゴリ一覧を取得
    const { data: categoryData, error: categoryError } = await supabase
      .from('menu_categories')
      .select('category_id, name, display_order, allow_treat_cast')
      .eq('store_id', table.store_id)
      .order('display_order', { ascending: true })
      .order('name', { ascending: true });

    if (categoryError) {
      console.error('カテゴリ一覧取得エラー:', categoryError);
      return NextResponse.json(
        { error: 'カテゴリ一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    // カテゴリIDとカテゴリ情報のマッピングを作成
    const categoryMap = new Map();
    const categoryAllowTreatMap = new Map();
    categoryData?.forEach(category => {
      categoryMap.set(category.category_id, category.name);
      categoryAllowTreatMap.set(category.category_id, category.allow_treat_cast);
    });

    // 店舗IDに紐づくメニュー一覧を取得（利用可能なもののみ）
    const { data: menuData, error: menusError } = await supabase
      .from('menus')
      .select('menu_id, product_id, name, description, price, image_url, category, category_id, is_available')
      .eq('store_id', table.store_id)
      .eq('is_available', true)
      .order('name', { ascending: true });

    if (menusError) {
      console.error('メニュー一覧取得エラー:', menusError);
      return NextResponse.json(
        { error: 'メニュー一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    // 必要なデータのみを抽出して新しい配列を作成
    const menus = (menuData || []).map(item => ({
      menu_id: item.menu_id,
      product_id: item.product_id,
      name: item.name,
      description: item.description,
      price: item.price,
      image_url: item.image_url,
      category: item.category_id ? categoryMap.get(item.category_id) || item.category || '未分類' : (item.category || '未分類'),
      category_id: item.category_id,
      is_available: item.is_available,
      allow_treat_cast: item.category_id ? categoryAllowTreatMap.get(item.category_id) || false : false
    }));

    // カテゴリーごとにメニューをグループ化
    const menusByCategory: Record<string, any[]> = {};

    // まず、カテゴリテーブルに基づいて空の配列を作成（表示順を保持するため）
    const categoryInfoMap = new Map();
    categoryData?.forEach(category => {
      menusByCategory[category.name] = [];
      categoryInfoMap.set(category.name, {
        category_id: category.category_id,
        allow_treat_cast: category.allow_treat_cast
      });
    });

    // 未分類カテゴリを追加
    if (!menusByCategory['未分類']) {
      menusByCategory['未分類'] = [];
    }

    // メニューをカテゴリごとに振り分け
    menus.forEach(menu => {
      const categoryName = menu.category;
      if (!menusByCategory[categoryName]) {
        menusByCategory[categoryName] = [];
      }
      menusByCategory[categoryName].push(menu);
    });

    return NextResponse.json({
      menus,
      menusByCategory,
      categories: categoryData || []
    });
  } catch (error) {
    console.error('メニュー一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string }> }
) {
  try {
    const { table_id } = await params;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // テーブル情報を取得
    const { data: table, error: tableError } = await supabase
      .from('tables')
      .select(`
        table_id,
        name,
        store_id,
        seat_types (
          seat_type_id,
          display_name,
          price_per_unit,
          time_unit_minutes
        ),
        stores (
          store_id,
          name
        )
      `)
      .eq('table_id', table_id)
      .single();

    if (tableError || !table) {
      console.error('テーブル取得エラー:', tableError);
      return NextResponse.json(
        { error: 'テーブルが見つかりません' },
        { status: 404 }
      );
    }

    // seat_typesの取得方法を修正
    let seatType = null;

    // テーブルのseat_type_idを取得
    const { data: tableData, error: tableDataError } = await supabase
      .from('tables')
      .select('seat_type_id')
      .eq('table_id', table_id)
      .single();

    if (!tableDataError && tableData && tableData.seat_type_id) {
      // seat_type_idを使用してseat_typesテーブルから直接取得
      const { data: seatTypeData, error: seatTypeError } = await supabase
        .from('seat_types')
        .select('seat_type_id, display_name, price_per_unit, time_unit_minutes')
        .eq('seat_type_id', tableData.seat_type_id)
        .single();

      if (!seatTypeError && seatTypeData) {
        seatType = {
          ...seatTypeData,
          price_per_unit: seatTypeData.price_per_unit
        };
      }
    }

    // 必要なデータのみを抽出して返す
    return NextResponse.json({
      table_id: table.table_id,
      name: table.name,
      store_id: table.store_id,
      seat_type: seatType,
      store: table.stores ? (
        Array.isArray(table.stores) ? (
          table.stores.length > 0 ? {
            store_id: table.stores[0].store_id,
            name: table.stores[0].name
          } : null
        ) : {
          store_id: table.stores.store_id,
          name: table.stores.name
        }
      ) : null
    });
  } catch (error) {
    console.error('テーブル情報取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string }> }
) {
  try {
    const { table_id } = await params;

    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // リクエストボディを取得
    const data = await request.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // テーブルが存在するか確認
    const { data: existingTable, error: checkError } = await supabase
      .from('tables')
      .select('table_id')
      .eq('table_id', table_id)
      .eq('store_id', storeId)
      .single();

    if (checkError || !existingTable) {
      return NextResponse.json(
        { error: 'テーブルが見つかりません' },
        { status: 404 }
      );
    }

    // バリデーション
    if (!data.name || !data.seat_type_id) {
      return NextResponse.json(
        { error: '必須項目が不足しています' },
        { status: 400 }
      );
    }

    // テーブル情報を更新
    const { data: updatedTable, error: updateError } = await supabase
      .from('tables')
      .update({
        name: data.name,
        seat_type_id: data.seat_type_id
      })
      .eq('table_id', table_id)
      .eq('store_id', storeId)
      .select()
      .single();

    if (updateError) {
      console.error('テーブル更新エラー:', updateError);
      return NextResponse.json(
        { error: 'テーブルの更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(updatedTable);
  } catch (error) {
    console.error('テーブル更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/sessions/[session_id]/pause/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string; session_id: string }> }
) {
  try {
    const { table_id, session_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッションが存在するか確認
    const { data: existingSession, error: sessionError } = await supabase
      .from('sessions')
      .select('session_id, table_id, charge_started_at, charge_paused_at')
      .eq('session_id', session_id)
      .eq('table_id', table_id)
      .single();

    if (sessionError || !existingSession) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // すでに一時停止中の場合はエラー
    if (existingSession.charge_paused_at) {
      return NextResponse.json(
        { error: 'すでに課金が一時停止されています' },
        { status: 400 }
      );
    }

    // 課金が開始されていない場合はエラー
    if (!existingSession.charge_started_at) {
      return NextResponse.json(
        { error: '課金が開始されていません' },
        { status: 400 }
      );
    }

    // 課金を一時停止
    const { data: updatedSession, error: updateError } = await supabase
      .from('sessions')
      .update({
        charge_paused_at: new Date().toISOString(),
      })
      .eq('session_id', session_id)
      .select()
      .single();

    if (updateError) {
      console.error('セッション更新エラー:', updateError);
      return NextResponse.json(
        { error: '課金の一時停止に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: '課金を一時停止しました',
      session: updatedSession,
    });
  } catch (error) {
    console.error('課金一時停止エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/sessions/[session_id]/resume/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string; session_id: string }> }
) {
  try {
    const { table_id, session_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッションが存在するか確認
    const { data: existingSession, error: sessionError } = await supabase
      .from('sessions')
      .select('session_id, table_id, charge_started_at, charge_paused_at')
      .eq('session_id', session_id)
      .eq('table_id', table_id)
      .single();

    if (sessionError || !existingSession) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 一時停止されていない場合はエラー
    if (!existingSession.charge_paused_at) {
      return NextResponse.json(
        { error: '課金は一時停止されていません' },
        { status: 400 }
      );
    }

    // 課金が開始されていない場合はエラー
    if (!existingSession.charge_started_at) {
      return NextResponse.json(
        { error: '課金が開始されていません' },
        { status: 400 }
      );
    }

    // 一時停止していた時間を計算
    const pauseStartTime = new Date(existingSession.charge_paused_at);
    const now = new Date();
    const pauseDurationMs = now.getTime() - pauseStartTime.getTime();

    // 元の課金開始時間
    const originalStartTime = new Date(existingSession.charge_started_at);

    // 一時停止していた時間分だけ課金開始時間を調整（後ろにずらす）
    const newStartTime = new Date(originalStartTime.getTime() + pauseDurationMs);

    // 課金を再開（charge_paused_atをnullに設定し、charge_started_atを調整）
    const { data: updatedSession, error: updateError } = await supabase
      .from('sessions')
      .update({
        charge_paused_at: null,
        charge_started_at: newStartTime.toISOString(), // 調整後の新しい開始時間
      })
      .eq('session_id', session_id)
      .select()
      .single();

    if (updateError) {
      console.error('セッション更新エラー:', updateError);
      return NextResponse.json(
        { error: '課金の再開に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: '課金を再開しました',
      session: updatedSession,
    });
  } catch (error) {
    console.error('課金再開エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/sessions/[session_id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string; session_id: string }> }
) {
  try {
    const { table_id, session_id } = await params;

    // リクエストボディを取得
    const data = await request.json();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッションが存在するか確認
    const { data: existingSession, error: sessionError } = await supabase
      .from('sessions')
      .select('*')
      .eq('session_id', session_id)
      .eq('table_id', table_id)
      .single();

    if (sessionError || !existingSession) {
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 更新するフィールドを準備
    const updateData: any = {};

    // charge_started_atの更新
    if (data.charge_started_at !== undefined) {
      updateData.charge_started_at = data.charge_started_at;
    }

    // selected_cast_idの更新
    if (data.selected_cast_id !== undefined) {
      updateData.selected_cast_id = data.selected_cast_id;
    }

    // is_new_customerの更新
    if (data.is_new_customer !== undefined) {
      updateData.is_new_customer = data.is_new_customer;
    }

    // セッションを更新
    const { data: updatedSession, error: updateError } = await supabase
      .from('sessions')
      .update(updateData)
      .eq('session_id', session_id)
      .select()
      .single();

    if (updateError) {
      console.error('セッション更新エラー:', updateError);
      return NextResponse.json(
        { error: 'セッションの更新に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      session_id: updatedSession.session_id,
      table_id: updatedSession.table_id,
      store_id: updatedSession.store_id,
      start_at: updatedSession.start_at,
      charge_started_at: updatedSession.charge_started_at,
      selected_cast_id: updatedSession.selected_cast_id,
      is_new_customer: updatedSession.is_new_customer
    });
  } catch (error) {
    console.error('セッション更新エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/[table_id]/sessions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ table_id: string }> }
) {
  try {
    const { table_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // テーブル情報を取得して店舗IDを特定
    const { data: table, error: tableError } = await supabase
      .from('tables')
      .select('store_id')
      .eq('table_id', table_id)
      .single();

    if (tableError || !table) {
      return NextResponse.json(
        { error: 'テーブルが見つかりません' },
        { status: 404 }
      );
    }

    // アクティブなセッションを取得（課金が開始されているセッションを優先）
    const { data: existingSession, error: sessionError } = await supabase
      .from('sessions')
      .select('*')
      .eq('table_id', table_id)
      .not('charge_started_at', 'is', null)
      .order('start_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    // 課金が開始されているセッションがない場合は、最新のセッションを取得
    if (!existingSession) {
      const { data: latestSession, error: latestSessionError } = await supabase
        .from('sessions')
        .select('*')
        .eq('table_id', table_id)
        .order('start_at', { ascending: false })
        .limit(1)
        .maybeSingle();

      if (latestSessionError) {
        console.error('最新セッション取得エラー:', latestSessionError);
      } else if (latestSession) {
        return NextResponse.json(latestSession);
      }
    }

    if (sessionError) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッション情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // セッションが存在する場合はそれを返す
    if (existingSession) {
      return NextResponse.json({
        session_id: existingSession.session_id,
        table_id: existingSession.table_id,
        store_id: existingSession.store_id,
        start_at: existingSession.start_at,
        charge_started_at: existingSession.charge_started_at,
        charge_paused_at: existingSession.charge_paused_at,
        selected_cast_id: existingSession.selected_cast_id,
        is_new_customer: existingSession.is_new_customer
      });
    }

    // セッションが存在しない場合は新規作成
    const { data: newSession, error: createError } = await supabase
      .from('sessions')
      .insert({
        table_id,
        store_id: table.store_id,
        start_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (createError) {
      console.error('セッション作成エラー:', createError);
      return NextResponse.json(
        { error: 'セッションの作成に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      session_id: newSession.session_id,
      table_id: newSession.table_id,
      store_id: newSession.store_id,
      start_at: newSession.start_at,
      charge_started_at: newSession.charge_started_at,
      charge_paused_at: newSession.charge_paused_at,
      selected_cast_id: newSession.selected_cast_id,
      is_new_customer: newSession.is_new_customer
    });
  } catch (error) {
    console.error('セッション管理エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/tables/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';
import { cookies } from 'next/headers';

export async function POST(request: NextRequest) {
  try {
    // URLからクエリパラメータを取得
    const url = new URL(request.url);
    const storeIdFromQuery = url.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // リクエストボディを取得
    const data = await request.json();

    // バリデーション
    if (!data.name || !data.seat_type_id) {
      return NextResponse.json(
        { error: '必須項目が不足しています' },
        { status: 400 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // テーブルを作成
    const { data: newTable, error: createError } = await supabase
      .from('tables')
      .insert({
        name: data.name,
        seat_type_id: data.seat_type_id,
        store_id: storeId
      })
      .select()
      .single();

    if (createError) {
      console.error('テーブル作成エラー:', createError);
      return NextResponse.json(
        { error: 'テーブルの作成に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(newTable, { status: 201 });
  } catch (error) {
    console.error('テーブル作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // URLからクエリパラメータを取得
    const url = new URL(request.url);
    const storeIdFromQuery = url.searchParams.get('storeId');

    // リクエストヘッダーからCookieを取得
    const requestCookies = request.headers.get('cookie');


    // Cookieストアからも取得（比較用）
    const cookieStore = await cookies();
    const storeIdFromStore = cookieStore.get('store-id')?.value;
    const storeIdFromStoreLegacy = cookieStore.get('storeId')?.value;

    // リクエストヘッダーからstore-idを抽出
    const storeIdMatch = requestCookies?.match(/store-id=([^;]+)/);
    const storeIdFromHeader = storeIdMatch ? storeIdMatch[1] : null;

    // リクエストヘッダーからstoreIdを抽出（レガシー形式）
    const storeIdLegacyMatch = requestCookies?.match(/storeId=([^;]+)/);
    const storeIdLegacyFromHeader = storeIdLegacyMatch ? storeIdLegacyMatch[1] : null;



    // 優先順位: クエリパラメータ > ヘッダー > Cookieストア、新形式 > レガシー形式
    const storeId = storeIdFromQuery || storeIdFromHeader || storeIdLegacyFromHeader || storeIdFromStore || storeIdFromStoreLegacy;

    const allCookies = cookieStore.getAll();

    if (!storeId) {
      console.error('GET /api/tables: 店舗IDがCookieに見つかりません');
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }



    const supabase = await createServerSupabaseClient();

    // テーブル一覧を取得
    const { data: tables, error: tablesError } = await supabase
      .from('tables')
      .select(`
        table_id,
        name,
        seat_types (
          seat_type_id,
          display_name,
          price_per_unit
        )
      `)
      .eq('store_id', storeId)
      .order('name');

    if (tablesError) {
      console.error('テーブル一覧取得エラー:', tablesError);
      return NextResponse.json(
        { error: 'テーブル一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(tables);
  } catch (error) {
    console.error('テーブル一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/upload/menu-image/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';
import { v4 as uuidv4 } from 'uuid';

export async function POST(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const storeId = cookieStore.get('store-id')?.value;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // FormDataからファイルを取得
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json(
        { error: 'ファイルが見つかりません' },
        { status: 400 }
      );
    }

    // ファイルタイプの検証
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { error: '許可されていないファイル形式です。JPEG、PNG、WebP、GIF形式のみ許可されています。' },
        { status: 400 }
      );
    }

    // ファイルサイズの検証（5MB以下）
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      return NextResponse.json(
        { error: 'ファイルサイズが大きすぎます。5MB以下のファイルを選択してください。' },
        { status: 400 }
      );
    }

    // ファイル名の生成（UUIDを使用して一意性を保証）
    const fileExtension = file.name.split('.').pop();
    const uuid = uuidv4();
    const fileName = `${storeId}/${uuid}.${fileExtension}`;

    // ファイルをArrayBufferに変換
    const arrayBuffer = await file.arrayBuffer();
    const fileBuffer = new Uint8Array(arrayBuffer);

    // バケットの存在確認
    const { data: buckets } = await supabase
      .storage
      .listBuckets();

    const bucketExists = buckets?.some(bucket => bucket.name === 'menu-images');

    // バケットが存在しない場合は作成
    if (!bucketExists) {
      console.log('バケットが存在しないため作成します: menu-images');
      const { error: createBucketError } = await supabase
        .storage
        .createBucket('menu-images', {
          public: true,
          fileSizeLimit: 5 * 1024 * 1024, // 5MB
          allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp', 'image/gif']
        });

      if (createBucketError) {
        console.error('バケット作成エラー:', createBucketError);
        return NextResponse.json(
          { error: `バケットの作成に失敗しました: ${createBucketError.message}` },
          { status: 500 }
        );
      }

      // 注意: RLSポリシーはサービスロールでも自動設定できないため、
      // Supabaseダッシュボードから手動で設定する必要があります
      console.log('バケットを作成しました。RLSポリシーはダッシュボードから設定してください。');
    }

    // Supabaseストレージにアップロード
    const { data, error } = await supabase
      .storage
      .from('menu-images')
      .upload(fileName, fileBuffer, {
        contentType: file.type,
        upsert: true
      });

    if (error) {
      console.error('画像アップロードエラー:', error);
      return NextResponse.json(
        { error: `画像のアップロードに失敗しました: ${error.message}` },
        { status: 500 }
      );
    }

    // 公開URLを取得
    const { data: { publicUrl } } = supabase
      .storage
      .from('menu-images')
      .getPublicUrl(fileName);

    return NextResponse.json({ url: publicUrl });
  } catch (error) {
    console.error('画像アップロードエラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="app/layout.tsx">
import './globals.css';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'QRオーダー & 会計連携システム',
  description: 'ガールズバー向けQRオーダーシステム',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja" suppressHydrationWarning>
      <body>{children}</body>
    </html>
  );
}
</file>

<file path="app/login/[store_code]/login-form.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { useState } from 'react';

// ログインアクションの型定義
type LoginActionResult = 
  | { error: string }
  | { success: true; redirectTo: string };

// ログインフォームコンポーネント
export default function LoginForm({ 
  storeCode, 
  storeName,
  loginAction
}: { 
  storeCode: string; 
  storeName: string;
  loginAction: (formData: FormData) => Promise<LoginActionResult>;
}) {
  const router = useRouter();
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = async (formData: FormData) => {
    const result = await loginAction(formData);
    
    if ('error' in result) {
      setError(result.error);
    } else if (result.success && result.redirectTo) {
      router.push(result.redirectTo);
    }
  };
  
  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-md">
      <h1 className="text-2xl font-bold mb-6 text-center">{storeName}</h1>
      
      {error && (
        <div className="mb-4 p-3 bg-red-100 text-red-700 rounded-md">
          {error}
        </div>
      )}
      
      <form action={handleSubmit}>
        <input type="hidden" name="store_code" value={storeCode} />
        
        <div className="mb-4">
          <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-1">
            メールアドレス
          </label>
          <input
            type="email"
            id="email"
            name="email"
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
          />
        </div>
        
        <div className="mb-6">
          <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1">
            パスワード
          </label>
          <input
            type="password"
            id="password"
            name="password"
            required
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
          />
        </div>
        
        <button
          type="submit"
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
        >
          ログイン
        </button>
      </form>
    </div>
  );
}
</file>

<file path="app/login/[store_code]/page.tsx">
import { getStoreByCode } from '@/lib/auth';
import { redirect } from 'next/navigation';
import LoginForm from './login-form';

// ログインアクション
async function loginAction(formData: FormData) {
  'use server';

  try {
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;
    const storeCode = formData.get('store_code') as string;

    if (!email || !password || !storeCode) {
      return { error: 'メールアドレス、パスワード、店舗コードは必須です' };
    }

    // APIを使用してログイン処理を実行
    const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password,
        storeCode,
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error('Login error details:', result.error);
      return { error: result.error || 'ログインに失敗しました' };
    }

    console.log('Login successful');

    // ダッシュボードにリダイレクト
    return { success: true as const, redirectTo: '/portal/dashboard' };
  } catch (error) {
    console.error('Login error:', error);
    return { error: 'ログイン処理中にエラーが発生しました' };
  }
}

// ページコンポーネント
export default async function LoginPage({ params }: { params: Promise<{ store_code: string }> }) {
  const { store_code } = await params;

  // 店舗コードから店舗情報を取得
  const store = await getStoreByCode(store_code);

  // 店舗が見つからない場合はホームページにリダイレクト
  if (!store) {
    redirect('/');
  }

  return (
    <div className="min-h-screen bg-gray-100 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
          {store.name}
        </h2>
        <p className="mt-2 text-center text-sm text-gray-600">
          スタッフログイン
        </p>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <LoginForm
          storeCode={store_code}
          storeName={store.name}
          loginAction={loginAction}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/cart-context.tsx">
'use client';

import { createContext, useContext, useState, ReactNode, useEffect } from 'react';

// カート内の商品アイテムの型定義
export interface CartItem {
  menu_id: string;
  product_id: string;
  name: string;
  price: number;
  quantity: number;
  target_cast_id?: string | null;
  target_cast_name?: string;
}

// カートコンテキストの型定義
interface CartContextType {
  items: CartItem[];
  addItem: (item: Omit<CartItem, 'quantity'>, quantity?: number) => void;
  removeItem: (menu_id: string, target_cast_id?: string | null) => void;
  updateQuantity: (menu_id: string, quantity: number, target_cast_id?: string | null) => void;
  updateTargetCast: (menu_id: string, cast_id: string, cast_name: string) => void;
  clearCart: () => void;
  totalItems: number;
  totalPrice: number;
}

// カートコンテキストの作成
const CartContext = createContext<CartContextType | undefined>(undefined);

// カートプロバイダーコンポーネント
export function CartProvider({ children, table_id }: { children: ReactNode, table_id: string }) {
  // カート内の商品アイテムの状態
  const [items, setItems] = useState<CartItem[]>([]);

  // ローカルストレージからカート情報を読み込む
  useEffect(() => {
    // クライアントサイドでのみ実行
    if (typeof window !== 'undefined') {
      const storedCart = localStorage.getItem(`cart_${table_id}`);
      if (storedCart) {
        try {
          const parsedCart = JSON.parse(storedCart);
          setItems(parsedCart);
        } catch (error) {
          console.error('カート情報の読み込みに失敗しました:', error);
        }
      }
    }
  }, [table_id]);

  // カート情報をローカルストレージに保存
  useEffect(() => {
    // クライアントサイドでのみ実行
    if (typeof window !== 'undefined' && items.length > 0) {
      localStorage.setItem(`cart_${table_id}`, JSON.stringify(items));
    } else if (typeof window !== 'undefined') {
      localStorage.removeItem(`cart_${table_id}`);
    }
  }, [items, table_id]);

  // カートに商品を追加する関数
  const addItem = (item: Omit<CartItem, 'quantity'>, quantity = 1) => {
    setItems(prevItems => {
      // 既に同じ商品がカートにあるか確認
      // メニューIDとターゲットキャストIDの両方で一致するアイテムを検索
      const existingItemIndex = prevItems.findIndex(i => {
        // メニューIDが一致するか確認
        if (i.menu_id !== item.menu_id) return false;

        // ターゲットキャストIDの比較
        // 両方ともnullの場合
        if (i.target_cast_id === null && item.target_cast_id === null) return true;

        // 両方とも文字列で同じ値の場合
        if (typeof i.target_cast_id === 'string' && typeof item.target_cast_id === 'string') {
          return i.target_cast_id === item.target_cast_id;
        }

        // それ以外の場合は一致しない
        return false;
      });

      if (existingItemIndex >= 0) {
        // 既存の商品の数量を増やす
        const currentQuantity = prevItems[existingItemIndex].quantity;

        // 新しい配列を作成
        const updatedItems = [...prevItems];

        // 指定された数量を追加
        updatedItems[existingItemIndex] = {
          ...prevItems[existingItemIndex],
          quantity: currentQuantity + quantity
        };

        return updatedItems;
      } else {
        // 新しい商品をカートに追加
        return [...prevItems, { ...item, quantity }];
      }
    });
  };

  // カートから商品を削除する関数
  const removeItem = (menu_id: string, target_cast_id?: string | null) => {
    setItems(prevItems => prevItems.filter(item => {
      // menu_idが一致しない場合は残す
      if (item.menu_id !== menu_id) return true;

      // target_cast_idが文字列の場合は、それも一致する場合のみ削除
      if (typeof target_cast_id === 'string') {
        return item.target_cast_id !== target_cast_id;
      }

      // target_cast_idがnullの場合は、item.target_cast_idがnullの商品のみ削除
      if (target_cast_id === null) {
        return item.target_cast_id !== null;
      }

      // target_cast_idがundefinedの場合は、すべてのitem.target_cast_idを削除（古い動作との互換性のため）
      return false;
    }));
  };

  // 商品の数量を更新する関数
  const updateQuantity = (menu_id: string, quantity: number, target_cast_id?: string | null) => {
    if (quantity <= 0) {
      removeItem(menu_id, target_cast_id);
      return;
    }

    setItems(prevItems =>
      prevItems.map(item => {
        // menu_idが一致するか確認
        if (item.menu_id !== menu_id) return item;

        // ターゲットキャストIDの比較
        // 両方ともnullの場合
        if (item.target_cast_id === null && target_cast_id === null) {
          return { ...item, quantity };
        }

        // 両方とも文字列で同じ値の場合
        if (typeof item.target_cast_id === 'string' && typeof target_cast_id === 'string') {
          if (item.target_cast_id === target_cast_id) {
            return { ...item, quantity };
          }
        }

        // target_cast_idがundefinedの場合は、item.target_cast_idがnullのアイテムを更新（古い動作との互換性のため）
        if (target_cast_id === undefined && item.target_cast_id === null) {
          return { ...item, quantity };
        }

        return item;
      })
    );
  };



  // カートをクリアする関数
  const clearCart = () => {
    setItems([]);
  };

  // カート内の商品の合計数
  const totalItems = items.reduce((total, item) => total + item.quantity, 0);

  // カート内の商品の合計金額
  const totalPrice = items.reduce((total, item) => total + (item.price * item.quantity), 0);

  // スタッフドリンクのターゲットキャストを更新する関数
  const updateTargetCast = (menu_id: string, cast_id: string, cast_name: string) => {
    setItems(prevItems =>
      prevItems.map(item =>
        item.menu_id === menu_id
          ? { ...item, target_cast_id: cast_id, target_cast_name: cast_name }
          : item
      )
    );
  };

  // コンテキストの値
  const value = {
    items,
    addItem,
    removeItem,
    updateQuantity,
    updateTargetCast,
    clearCart,
    totalItems,
    totalPrice
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

// カートコンテキストを使用するためのフック
export function useCart() {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
}
</file>

<file path="app/menu/[table_id]/cart-display.tsx">
'use client';

import { useState } from 'react';
import { useCart, CartItem } from './cart-context';

interface CartDisplayProps {
  sessionId: string;
  tableId: string;
}

export default function CartDisplay({ sessionId, tableId }: CartDisplayProps) {
  const { items, removeItem, updateQuantity, clearCart, totalItems, totalPrice } = useCart();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [orderSuccess, setOrderSuccess] = useState(false);
  const [orderError, setOrderError] = useState<string | null>(null);

  // 注文を送信する関数
  const submitOrder = async () => {
    if (items.length === 0) return;

    setIsSubmitting(true);
    setOrderError(null);

    try {
      // 注文データを準備
      const orderData = {
        session_id: sessionId,
        table_id: tableId,
        items: items.map(item => ({
          menu_id: item.menu_id,
          product_id: item.product_id,
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          target_cast_id: item.target_cast_id
        }))
      };

      // 注文APIを呼び出し
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '注文の送信に失敗しました');
      }

      // 注文成功
      setOrderSuccess(true);

      // カートをクリア
      clearCart();

      // 2秒後に成功メッセージをリセット
      setTimeout(() => {
        setOrderSuccess(false);
      }, 2000);

    } catch (err) {
      setOrderError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
      console.error('注文エラー:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 数量変更ボタン
  const QuantityControl = ({ item }: { item: CartItem }) => (
    <div className="flex items-center">
      <button
        type="button"
        className="w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center"
        onClick={() => updateQuantity(item.menu_id, item.quantity - 1)}
      >
        <span>-</span>
      </button>
      <span className="mx-2">{item.quantity}</span>
      <button
        type="button"
        className="w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center"
        onClick={() => updateQuantity(item.menu_id, item.quantity + 1)}
      >
        <span>+</span>
      </button>
    </div>
  );

  if (orderSuccess) {
    return (
      <div className="text-center py-8">
        <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
          <p>注文が完了しました！</p>
        </div>
      </div>
    );
  }

  if (items.length === 0) {
    return (
      <div className="text-center text-gray-500 py-8">
        カートは空です。メニューから商品を追加してください。
      </div>
    );
  }

  return (
    <div>
      {orderError && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          <p>{orderError}</p>
        </div>
      )}

      <div className="divide-y">
        {items.map((item) => (
          <div key={item.menu_id} className="py-4 flex justify-between items-center">
            <div className="flex-1">
              <h3 className="text-lg font-medium">{item.name}</h3>
              <p className="text-sm text-gray-500">
                {item.price.toLocaleString()}円 × {item.quantity}
              </p>
              {item.target_cast_name && (
                <p className="text-sm text-blue-600">
                  {item.target_cast_name}に奢る
                </p>
              )}

            </div>

            <div className="flex items-center space-x-4">
              <QuantityControl item={item} />

              <button
                type="button"
                className="text-red-500"
                onClick={() => removeItem(item.menu_id)}
              >
                <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
              </button>
            </div>
          </div>
        ))}
      </div>

      <div className="mt-6 border-t pt-4">
        <div className="flex justify-between mb-2">
          <span>小計 ({totalItems}点)</span>
          <span>{totalPrice.toLocaleString()}円</span>
        </div>

        <div className="mt-6 text-center">
          <button
            type="button"
            className={`bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 w-full ${
              isSubmitting ? 'opacity-50 cursor-not-allowed' : ''
            }`}
            onClick={submitOrder}
            disabled={isSubmitting}
          >
            {isSubmitting ? '処理中...' : '注文する'}
          </button>
          <p className="mt-2 text-sm text-gray-500">
            注文後、右側の会計画面から会計処理ができます
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/cart-modal.tsx">
'use client';

import { useState } from 'react';
import Modal from './modal';
import { useCart, CartItem } from './cart-context';

interface CartModalProps {
  isOpen: boolean;
  onClose: () => void;
  sessionId: string;
  tableId: string;
}

export default function CartModal({
  isOpen,
  onClose,
  sessionId,
  tableId
}: CartModalProps) {
  const { items, removeItem, updateQuantity, clearCart, totalItems, totalPrice } = useCart();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [orderSuccess, setOrderSuccess] = useState(false);
  const [orderError, setOrderError] = useState<string | null>(null);

  // 注文を送信する関数
  const submitOrder = async () => {
    if (items.length === 0) return;

    setIsSubmitting(true);
    setOrderError(null);

    try {
      // 注文データを準備
      const orderData = {
        session_id: sessionId,
        table_id: tableId,
        items: items.map(item => ({
          menu_id: item.menu_id,
          product_id: item.product_id,
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          target_cast_id: item.target_cast_id
        }))
      };

      // 注文APIを呼び出し
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '注文の送信に失敗しました');
      }

      // 注文成功
      setOrderSuccess(true);

      // カートをクリア
      clearCart();

      // 2秒後に成功メッセージをリセット
      setTimeout(() => {
        setOrderSuccess(false);
        onClose(); // モーダルを閉じる
      }, 2000);

    } catch (err) {
      setOrderError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
      console.error('注文エラー:', err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // 数量変更ボタン
  const QuantityControl = ({ item }: { item: CartItem }) => (
    <div className="flex items-center">
      <button
        type="button"
        className="w-8 h-8 rounded-full bg-gray-200 hover:bg-gray-300 active:bg-gray-400 focus:bg-gray-200 flex items-center justify-center focus:outline-none"
        onClick={() => updateQuantity(item.menu_id, item.quantity - 1, item.target_cast_id || null)}
      >
        <span>-</span>
      </button>
      <span className="mx-2">{item.quantity}</span>
      <button
        type="button"
        className="w-8 h-8 rounded-full bg-gray-200 hover:bg-gray-300 active:bg-gray-400 focus:bg-gray-200 flex items-center justify-center focus:outline-none"
        onClick={() => updateQuantity(item.menu_id, item.quantity + 1, item.target_cast_id || null)}
      >
        <span>+</span>
      </button>
    </div>
  );

  const cartContent = () => {
    if (orderSuccess) {
      return (
        <div className="text-center py-8">
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
            <p>注文が完了しました！</p>
          </div>
        </div>
      );
    }

    if (items.length === 0) {
      return (
        <div className="text-center text-gray-500 py-8">
          カートは空です。メニューから商品を追加してください。
        </div>
      );
    }

    return (
      <div>
        {orderError && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            <p>{orderError}</p>
          </div>
        )}

        <div className="divide-y">
          {items.map((item) => (
            <div key={`${item.menu_id}-${item.target_cast_id || 'self'}`} className="py-4 flex justify-between items-center">
              <div className="flex-1">
                <h3 className="text-lg font-medium">{item.name}</h3>
                <p className="text-sm text-gray-500">
                  {item.price.toLocaleString()}円 × {item.quantity}
                </p>
                {item.target_cast_name && (
                  <p className="text-sm text-blue-600">
                    {item.target_cast_name}に奢る
                  </p>
                )}
              </div>

              <div className="flex items-center space-x-4">
                <QuantityControl item={item} />

                <button
                  type="button"
                  className="text-red-500 hover:text-red-600 active:text-red-700 focus:text-red-500 focus:outline-none"
                  onClick={() => removeItem(item.menu_id, item.target_cast_id || null)}
                >
                  <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                  </svg>
                </button>
              </div>
            </div>
          ))}
        </div>

        <div className="mt-6 border-t pt-4">
          <div className="flex justify-between mb-2">
            <span>小計 ({totalItems}点)</span>
            <span>{totalPrice.toLocaleString()}円</span>
          </div>

          <div className="mt-6 text-center">
            <button
              type="button"
              className={`bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 active:bg-blue-800 focus:bg-blue-600 focus:outline-none w-full ${
                isSubmitting ? 'opacity-50 cursor-not-allowed' : ''
              }`}
              onClick={submitOrder}
              disabled={isSubmitting}
            >
              {isSubmitting ? '処理中...' : '注文する'}
            </button>
            <p className="mt-2 text-sm text-gray-500">
              注文後、お会計ボタンから会計処理ができます
            </p>
          </div>
        </div>
      </div>
    );
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title="注文カート"
      maxWidth="max-w-lg"
    >
      {cartContent()}
    </Modal>
  );
}
</file>

<file path="app/menu/[table_id]/cast-select-modal.tsx">
'use client';

import { useState, useEffect } from 'react';

interface Cast {
  id: string;
  user_id: string;
  display_name: string;
}

interface CastSelectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (castId: string, castName: string) => void;
  storeId: string;
}

export default function CastSelectModal({ isOpen, onClose, onSelect, storeId }: CastSelectModalProps) {
  const [casts, setCasts] = useState<Cast[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // キャスト一覧を取得
  useEffect(() => {
    if (!isOpen) return;

    const fetchCasts = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/casts?store_id=${storeId}`);
        
        if (!response.ok) {
          throw new Error('キャスト情報の取得に失敗しました');
        }
        
        const data = await response.json();
        setCasts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
        console.error('キャスト取得エラー:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchCasts();
  }, [isOpen, storeId]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">キャストを選択</h2>
          <button
            type="button"
            className="text-gray-400 hover:text-gray-500"
            onClick={onClose}
          >
            <span className="sr-only">閉じる</span>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {loading ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">読み込み中...</p>
          </div>
        ) : error ? (
          <div className="py-8 text-center">
            <p className="text-red-500">{error}</p>
            <button
              type="button"
              className="mt-4 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              onClick={onClose}
            >
              閉じる
            </button>
          </div>
        ) : casts.length === 0 ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">キャストが登録されていません</p>
            <button
              type="button"
              className="mt-4 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              onClick={onClose}
            >
              閉じる
            </button>
          </div>
        ) : (
          <div className="mt-4 grid grid-cols-1 gap-4">
            {casts.map((cast) => (
              <button
                key={cast.id}
                className="flex items-center p-3 border rounded-lg hover:bg-gray-50"
                onClick={() => onSelect(cast.user_id, cast.display_name)}
              >
                <div className="w-10 h-10 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                  <span className="text-gray-500 text-sm">{cast.display_name.charAt(0)}</span>
                </div>
                <div className="flex-1 text-left">
                  <p className="font-medium">{cast.display_name}</p>
                </div>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/cast-selection.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

interface Cast {
  id: string;
  user_id: string;
  display_name: string;
}

interface CastSelectionProps {
  isOpen: boolean;
  onClose: () => void;
  tableId: string;
  sessionId: string;
  storeId: string;
}

export default function CastSelection({
  isOpen,
  onClose,
  tableId,
  sessionId,
  storeId
}: CastSelectionProps) {
  const [casts, setCasts] = useState<Cast[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const router = useRouter();

  // キャスト一覧を取得
  useEffect(() => {
    if (!isOpen) return;

    const fetchCasts = async () => {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(`/api/casts?store_id=${storeId}`);

        if (!response.ok) {
          throw new Error('キャスト情報の取得に失敗しました');
        }

        const data = await response.json();
        setCasts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
        console.error('キャスト取得エラー:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchCasts();
  }, [isOpen, storeId]);

  // キャスト選択処理
  const handleCastSelect = async (castId: string) => {
    try {
      setIsSubmitting(true);
      setError(null);

      // 指名キャストを記録
      const response = await fetch(`/api/tables/${tableId}/sessions/${sessionId}/`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          selected_cast_id: castId,
          is_new_customer: false,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || '指名の処理に失敗しました');
      }

      // モーダルを閉じて画面を更新
      onClose();
      router.refresh();
    } catch (err) {
      console.error('キャスト選択エラー:', err);
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">キャストを選択</h2>
          <button
            type="button"
            className="text-gray-400 hover:text-gray-500"
            onClick={onClose}
          >
            <span className="sr-only">閉じる</span>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        {loading ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">読み込み中...</p>
          </div>
        ) : casts.length === 0 ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">キャストが登録されていません</p>
            <button
              type="button"
              className="mt-4 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              onClick={onClose}
            >
              閉じる
            </button>
          </div>
        ) : (
          <div className="mt-4 grid grid-cols-1 gap-4">
            {casts.map((cast) => (
              <button
                key={cast.id}
                className="flex items-center p-3 border rounded-lg hover:bg-gray-50"
                onClick={() => handleCastSelect(cast.user_id)}
                disabled={isSubmitting}
              >
                <div className="w-10 h-10 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                  <span className="text-gray-500 text-sm">{cast.display_name.charAt(0)}</span>
                </div>
                <div className="flex-1 text-left">
                  <p className="font-medium">{cast.display_name}</p>
                </div>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/checkout-complete.tsx">
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';

interface CheckoutCompleteProps {
  storeName: string;
  tableName: string;
  totalAmount: number;
  subtotalAmount?: number;
  taxAmount?: number;
  taxRate?: number;
}

export default function CheckoutComplete({
  storeName,
  tableName,
  totalAmount,
  subtotalAmount = 0,
  taxAmount = 0,
  taxRate = 10.0
}: CheckoutCompleteProps) {
  const router = useRouter();

  // 30秒後にリロードして初期画面に戻る
  useEffect(() => {
    // クライアントサイドでのみ実行
    if (typeof window !== 'undefined') {


      const timer = setTimeout(() => {

        // クエリパラメータを削除してリロード
        window.location.href = window.location.pathname;
      }, 30000);

      return () => clearTimeout(timer);
    }
  }, [storeName, tableName, totalAmount]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-100 p-4">
      <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full text-center">
        <h1 className="text-2xl font-bold text-green-600 mb-6">
          お会計ありがとうございました
        </h1>

        <div className="mb-6">
          <p className="text-gray-700 mb-2">
            {storeName}
          </p>
          <p className="text-gray-700 mb-4">
            テーブル: {tableName}
          </p>

          <div className="mt-4 text-left">
            <div className="flex justify-between mb-1">
              <span className="text-gray-600">小計（税抜）:</span>
              <span className="text-gray-600">{subtotalAmount.toLocaleString()}円</span>
            </div>
            <div className="flex justify-between mb-1">
              <span className="text-gray-600">消費税（{taxRate}%）:</span>
              <span className="text-gray-600">{taxAmount.toLocaleString()}円</span>
            </div>
            <div className="flex justify-between text-xl font-semibold mt-2">
              <span>合計金額（税込）:</span>
              <span>{totalAmount.toLocaleString()}円</span>
            </div>
          </div>
        </div>

        <div className="border-t border-gray-200 pt-6">
          <p className="text-gray-500 text-sm mb-4">
            またのご来店をお待ちしております。
          </p>
          <p className="text-gray-400 text-xs">
            この画面は30秒後に自動的に閉じます。
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/checkout-display.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useCart } from './cart-context';
import { calculateElapsedMinutes, calculateCharge } from '@/lib/charge';

interface OrderItem {
  order_id: string;
  product_id: string;
  name: string;
  quantity: number;
  price: number;
  total: number;
  target_cast_id: string | null;
  target_cast_name: string | null;
}

interface CheckoutDisplayProps {
  sessionId: string;
  tableId: string;
  tableName: string;
  storeName: string;
  seatTypeName: string;
  pricePerHalfHour: number;
  chargeStartedAt: string | null;
  timeUnitMinutes?: number;
}

export default function CheckoutDisplay({
  sessionId,
  tableId,
  tableName,
  storeName,
  seatTypeName,
  pricePerHalfHour,
  chargeStartedAt,
  timeUnitMinutes = 30,
}: CheckoutDisplayProps) {
  const router = useRouter();
  const { clearCart } = useCart();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [checkoutSuccess, setCheckoutSuccess] = useState(false);
  const [checkoutError, setCheckoutError] = useState<string | null>(null);
  const [chargeAmount, setChargeAmount] = useState<number>(0);
  const [elapsedTime, setElapsedTime] = useState<string>('');
  const [checkoutData, setCheckoutData] = useState<any>(null);
  const [orderItems, setOrderItems] = useState<OrderItem[]>([]);
  const [orderTotalPrice, setOrderTotalPrice] = useState<number>(0);
  const [isLoadingOrders, setIsLoadingOrders] = useState<boolean>(true);



  // 注文データと最新の料金を取得
  useEffect(() => {
    const fetchData = async () => {
      try {
        // 注文データを取得
        setIsLoadingOrders(true);
        const response = await fetch(`/api/sessions/${sessionId}/orders`);

        if (!response.ok) {
          throw new Error('注文データの取得に失敗しました');
        }

        const data = await response.json();
        setOrderItems(data.orders);
        setOrderTotalPrice(data.totalPrice);

        // 初期表示時に最新の料金も取得
        if (chargeStartedAt && sessionId) {
          console.log('初期表示時に最新の料金を取得します');
          await fetchChargeAmount();
        }
      } catch (error) {
        console.error('データ取得エラー:', error);
      } finally {
        setIsLoadingOrders(false);
      }
    };

    if (sessionId) {
      fetchData();
    }
  }, [sessionId, chargeStartedAt]);

  // 経過時間の表示を更新する関数
  const updateElapsedTimeDisplay = () => {
    if (!chargeStartedAt) return;

    const startTime = new Date(chargeStartedAt);
    const now = new Date();

    // 経過時間を分単位で計算
    const elapsedMinutes = calculateElapsedMinutes(startTime, now);

    // 経過時間の表示形式を設定
    const hours = Math.floor(elapsedMinutes / 60);
    const minutes = elapsedMinutes % 60;
    const timeString = `${hours}時間${minutes}分`;

    setElapsedTime(timeString);
  };

  // クライアント側で料金を計算する関数（APIが失敗した場合のフォールバック）
  const calculateClientSideCharge = () => {
    if (!chargeStartedAt) return 0;

    const startTime = new Date(chargeStartedAt);
    const now = new Date();

    // 経過時間を分単位で計算
    const elapsedMinutes = calculateElapsedMinutes(startTime, now);

    // ライブラリ関数を使用して料金を計算
    const charge = calculateCharge(elapsedMinutes, pricePerHalfHour, timeUnitMinutes);

    // 計算された料金を設定
    setChargeAmount(charge);

    // デバッグ情報
    console.log('クライアント側で計算した料金:', {
      startTime,
      now,
      elapsedMs: now.getTime() - startTime.getTime(),
      elapsedMinutes,
      pricePerHalfHour,
      timeUnitMinutes,
      charge
    });

    return charge;
  };

  // サーバーから正確な料金を取得する関数
  const fetchChargeAmount = async () => {
    if (!chargeStartedAt || !sessionId) return 0;

    try {
      const response = await fetch(`/api/sessions/${sessionId}/calculate-charge`);

      if (!response.ok) {
        console.error('テーブル料金取得エラー:', response.status);
        // APIが失敗した場合はクライアント側で計算
        return calculateClientSideCharge();
      }

      const data = await response.json();
      console.log('テーブル料金取得成功:', data);

      // 席移動料金を含む合計料金を設定
      setChargeAmount(data.charge_amount || 0);

      // 経過時間の表示形式を設定（クライアント側で計算）
      updateElapsedTimeDisplay();

      return data.charge_amount || 0;
    } catch (error) {
      console.error('テーブル料金取得例外:', error);
      // エラーが発生した場合はクライアント側で計算
      return calculateClientSideCharge();
    }
  };

  // チャージ開始時間から経過時間を計算
  useEffect(() => {
    if (!chargeStartedAt || !sessionId) return;

    // 初回はサーバーから料金を取得
    fetchChargeAmount();

    // 1分ごとに再計算（経過時間の表示のみ更新、料金はサーバーから取得しない）
    const interval = setInterval(updateElapsedTimeDisplay, 60 * 1000);

    return () => clearInterval(interval);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chargeStartedAt, pricePerHalfHour, timeUnitMinutes, sessionId]);

  // 会計処理を実行する関数
  const handleCheckout = async () => {
    if (orderItems.length === 0 && chargeAmount === 0) return;

    setIsSubmitting(true);
    setCheckoutError(null);

    try {
      // 会計処理の前に最新の料金を取得
      console.log('会計前に最新の料金を取得します');
      const latestChargeAmount = await fetchChargeAmount();
      console.log('最新の料金:', latestChargeAmount);

      // 最新の料金を状態に設定（表示を更新）
      setChargeAmount(latestChargeAmount);

      // 会計APIを呼び出し
      const response = await fetch(`/api/checkout/${sessionId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          table_id: tableId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '会計処理に失敗しました');
      }

      // 会計データを取得
      const data = await response.json();
      setCheckoutData(data);

      // 会計成功
      setCheckoutSuccess(true);
      clearCart();



      // 会計完了画面に遷移するためのクエリパラメータを準備
      // APIから返された合計金額を使用
      const params = new URLSearchParams({
        complete: 'true',
        total: data.total_amount.toString(), // APIから返された合計金額を使用
        store: storeName || '不明な店舗',
        table: tableName || '不明なテーブル'
      });

      // セッションを削除
      try {
        await fetch(`/api/sessions/${sessionId}`, {
          method: 'DELETE',
        });
      } catch (deleteError) {
        console.error('セッション削除エラー:', deleteError);
        // セッション削除に失敗しても処理は続行
      }

      // 2秒後に会計完了画面に遷移
      setTimeout(() => {
        window.location.href = `${window.location.pathname}?${params.toString()}`;
      }, 2000);
    } catch (error) {
      console.error('会計エラー:', error);
      setCheckoutError(error instanceof Error ? error.message : '会計処理に失敗しました');
    } finally {
      setIsSubmitting(false);
    }
  };

  // 合計金額（注文 + テーブル料金）
  const totalAmount = orderTotalPrice + chargeAmount;

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-xl font-bold mb-4">会計</h2>

      {checkoutSuccess ? (
        <div className="bg-green-50 border border-green-200 text-green-700 p-4 rounded-md mb-4">
          会計処理が完了しました。ありがとうございました。
        </div>
      ) : checkoutError ? (
        <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-md mb-4">
          {checkoutError}
        </div>
      ) : null}

      {pricePerHalfHour > 0 && (
        <div className="mb-6">
          <h3 className="font-semibold mb-2">テーブル料金</h3>
          <div className="bg-gray-50 p-4 rounded-md">
            <div className="flex justify-between mb-2">
              <span>席種:</span>
              <span>{seatTypeName}</span>
            </div>
            <div className="flex justify-between mb-2">
              <span>料金:</span>
              <span>{pricePerHalfHour}円/{timeUnitMinutes}分</span>
            </div>
            {chargeStartedAt && (
              <>
                <div className="flex justify-between mb-2">
                  <span>経過時間:</span>
                  <span>{elapsedTime}</span>
                </div>
                <div className="flex justify-between font-semibold">
                  <span>テーブル料金:</span>
                  <span>{chargeAmount.toLocaleString()}円</span>
                </div>
              </>
            )}
          </div>
        </div>
      )}

      <div className="mb-6">
        <h3 className="font-semibold mb-2">注文明細</h3>
        {isLoadingOrders ? (
          <p className="text-gray-500">注文データを読み込み中...</p>
        ) : orderItems.length > 0 ? (
          <div className="border-t border-gray-200">
            {orderItems.map((item, index) => (
              <div key={index} className="py-2 border-b border-gray-200 flex justify-between">
                <div>
                  <span className="font-medium">{item.name}</span>
                  {item.target_cast_name && (
                    <span className="ml-2 text-sm text-gray-500">
                      ({item.target_cast_name}へ)
                    </span>
                  )}
                  <span className="ml-2 text-sm text-gray-500">
                    ×{item.quantity}
                  </span>
                </div>
                <span>{item.total.toLocaleString()}円</span>
              </div>
            ))}
          </div>
        ) : (
          <p className="text-gray-500 italic">注文はありません</p>
        )}
      </div>

      <div className="border-t border-gray-200 pt-4">
        <div className="flex justify-between mb-2">
          <span>注文合計:</span>
          <span>{orderTotalPrice.toLocaleString()}円</span>
        </div>
        {pricePerHalfHour > 0 && (
          <div className="flex justify-between mb-2">
            <span>テーブル料金:</span>
            <span>{chargeAmount.toLocaleString()}円</span>
          </div>
        )}
        <div className="flex justify-between font-bold text-lg">
          <span>合計金額:</span>
          <span>{totalAmount.toLocaleString()}円</span>
        </div>
      </div>

      <div className="mt-6">
        <button
          type="button"
          className={`bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 w-full ${
            isSubmitting ? 'opacity-50 cursor-not-allowed' : ''
          }`}
          onClick={handleCheckout}
          disabled={isSubmitting || (orderItems.length === 0 && chargeAmount === 0)}
        >
          {isSubmitting ? '処理中...' : '会計する'}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/checkout-modal.tsx">
'use client';

import { useState, useEffect } from 'react';
import Modal from './modal';
import { useCart } from './cart-context';
import { calculateElapsedMinutes, calculateCharge, calculateChargeWithPause } from '@/lib/charge';

interface OrderItem {
  order_id: string;
  product_id: string;
  name: string;
  quantity: number;
  price: number;
  total: number;
  target_cast_id: string | null;
  target_cast_name: string | null;
}

interface CheckoutModalProps {
  isOpen: boolean;
  onClose: () => void;
  sessionId: string;
  tableId: string;
  tableName: string;
  storeName: string;
  seatTypeName: string;
  pricePerHalfHour: number;
  chargeStartedAt: string | null;
  chargePausedAt?: string | null;
  timeUnitMinutes?: number;
}

export default function CheckoutModal({
  isOpen,
  onClose,
  sessionId,
  tableId,
  tableName,
  storeName,
  seatTypeName,
  pricePerHalfHour,
  chargeStartedAt,
  chargePausedAt,
  timeUnitMinutes = 30,
}: CheckoutModalProps) {
  const { clearCart } = useCart();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [checkoutSuccess, setCheckoutSuccess] = useState(false);
  const [checkoutError, setCheckoutError] = useState<string | null>(null);
  const [chargeAmount, setChargeAmount] = useState<number>(0);
  const [elapsedTime, setElapsedTime] = useState<string>('');
  const [checkoutData, setCheckoutData] = useState<any>(null);
  const [orderItems, setOrderItems] = useState<OrderItem[]>([]);
  const [orderTotalPrice, setOrderTotalPrice] = useState<number>(0);
  const [taxRate, setTaxRate] = useState<number>(10.0); // デフォルト税率10%
  const [taxAmount, setTaxAmount] = useState<number>(0);
  const [isLoadingOrders, setIsLoadingOrders] = useState<boolean>(true);

  // 注文データと最新の料金を取得
  useEffect(() => {
    const fetchData = async () => {
      if (!isOpen) return;

      try {
        // 店舗情報を取得して税率を設定
        const storeResponse = await fetch(`/api/sessions/${sessionId}/store-info`);
        if (storeResponse.ok) {
          const storeData = await storeResponse.json();
          if (storeData.tax_rate !== undefined) {
            setTaxRate(storeData.tax_rate);
          }
        } else {
          console.error('店舗情報取得エラー:', await storeResponse.text());
        }

        // 注文データを取得
        console.log('注文データ取得開始:', { sessionId });
        setIsLoadingOrders(true);
        const response = await fetch(`/api/sessions/${sessionId}/orders`);
        console.log('注文データAPIレスポンス:', { status: response.status, ok: response.ok });

        if (!response.ok) {
          const errorData = await response.json();
          console.error('注文データ取得エラーレスポンス:', errorData);
          throw new Error('注文データの取得に失敗しました');
        }

        const data = await response.json();
        console.log('注文データ取得成功:', { orders: data.orders, totalPrice: data.totalPrice });
        setOrderItems(data.orders);
        setOrderTotalPrice(data.totalPrice);

        // モーダルが開かれたときに最新の料金も取得
        if (chargeStartedAt && sessionId) {
          console.log('モーダルオープン時に最新の料金を取得します');
          await fetchChargeAmount();
        }
      } catch (error) {
        console.error('データ取得エラー:', error);
      } finally {
        setIsLoadingOrders(false);
      }
    };

    if (sessionId && isOpen) {
      fetchData();
    }
  }, [sessionId, isOpen, chargeStartedAt]);

  // 経過時間の表示を更新する関数
  const updateElapsedTimeDisplay = () => {
    if (!chargeStartedAt) return;

    const startTime = new Date(chargeStartedAt);
    const now = new Date();
    const pauseTime = chargePausedAt ? new Date(chargePausedAt) : null;

    // 経過時間を分単位で計算（一時停止を考慮）
    const elapsedMinutes = calculateElapsedMinutes(startTime, now, pauseTime);

    // 経過時間の表示形式を設定
    const hours = Math.floor(elapsedMinutes / 60);
    const minutes = elapsedMinutes % 60;
    const timeString = `${hours}時間${minutes}分${pauseTime ? ' (停止中)' : ''}`;

    setElapsedTime(timeString);
  };

  // クライアント側で料金を計算する関数（APIが失敗した場合のフォールバック）
  const calculateClientSideCharge = () => {
    if (!chargeStartedAt) return 0;

    const startTime = new Date(chargeStartedAt);
    const now = new Date();
    const pauseTime = chargePausedAt ? new Date(chargePausedAt) : null;

    // ライブラリ関数を使用して料金を計算
    const charge = calculateChargeWithPause(
      startTime,
      now,
      pricePerHalfHour,
      timeUnitMinutes,
      pauseTime
    );

    // 計算された料金を設定
    setChargeAmount(charge);

    // デバッグ情報
    console.log('クライアント側で計算した料金:', {
      startTime,
      now,
      elapsedMs: now.getTime() - startTime.getTime(),
      elapsedMinutes: Math.floor((now.getTime() - startTime.getTime()) / (1000 * 60)),
      pricePerHalfHour,
      timeUnitMinutes,
      charge
    });

    return charge;
  };

  // サーバーから正確な料金を取得する関数
  const fetchChargeAmount = async () => {
    if (!chargeStartedAt || !sessionId) return 0;

    try {
      const response = await fetch(`/api/sessions/${sessionId}/calculate-charge`);

      if (!response.ok) {
        console.error('テーブル料金取得エラー:', response.status);
        // APIが失敗した場合はクライアント側で計算
        return calculateClientSideCharge();
      }

      const data = await response.json();
      console.log('テーブル料金取得成功:', data);

      // 席移動料金を含む合計料金を設定
      setChargeAmount(data.charge_amount || 0);

      // 経過時間の表示形式を設定（クライアント側で計算）
      updateElapsedTimeDisplay();

      return data.charge_amount || 0;
    } catch (error) {
      console.error('テーブル料金取得例外:', error);
      // エラーが発生した場合はクライアント側で計算
      return calculateClientSideCharge();
    }
  };

  // テーブル料金の計算
  useEffect(() => {
    if (!chargeStartedAt || !sessionId) return;

    // 初回はサーバーから料金を取得
    fetchChargeAmount();

    // 1分ごとに再計算（経過時間の表示のみ更新、料金はサーバーから取得しない）
    const interval = setInterval(updateElapsedTimeDisplay, 60 * 1000);

    return () => clearInterval(interval);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chargeStartedAt, chargePausedAt, pricePerHalfHour, timeUnitMinutes, sessionId]);

  // 会計処理
  const handleCheckout = async (e?: React.MouseEvent | React.FormEvent) => {
    // イベントがある場合は、デフォルトの動作とバブリングを防止
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    if (orderItems.length === 0 && chargeAmount === 0) {
      return;
    }

    setIsSubmitting(true);
    setCheckoutError(null);

    try {
      // 会計処理の前に最新の料金を取得
      console.log('会計前に最新の料金を取得します');
      const latestChargeAmount = await fetchChargeAmount();
      console.log('最新の料金:', latestChargeAmount);

      // 最新の料金を状態に設定（表示を更新）
      setChargeAmount(latestChargeAmount);

      // 会計APIを呼び出し
      const apiUrl = `/api/checkout/${sessionId}`;
      const requestBody = {
        table_id: tableId,
      };



      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });



      if (!response.ok) {
        let errorMessage = '会計処理に失敗しました';
        try {
          const errorData = await response.json();

          errorMessage = errorData.error || errorMessage;
        } catch (jsonError) {
          console.error('会計APIエラーレスポンスのJSONパースに失敗:', jsonError);
        }
        throw new Error(errorMessage);
      }

      // 会計データを取得
      const data = await response.json();
      setCheckoutData(data);

      // APIから返された料金を使用して表示を更新
      setChargeAmount(data.charge_amount || chargeAmount);

      // 会計成功
      setCheckoutSuccess(true);
      clearCart();

      // 会計完了画面に遷移するためのクエリパラメータを準備
      // APIからの金額を使用
      const params = new URLSearchParams({
        complete: 'true',
        total: data.total_amount.toString(), // APIから返された税込み合計金額を使用
        subtotal: data.subtotal_amount.toString(), // APIから返された税抜き合計金額を使用
        tax: data.tax_amount.toString(), // APIから返された消費税額を使用
        taxRate: data.tax_rate.toString(), // APIから返された消費税率を使用
        store: encodeURIComponent(storeName || '不明な店舗'),
        table: encodeURIComponent(tableName || '不明なテーブル')
      });

      // クライアントサイドでのみ実行
      if (typeof window !== 'undefined') {

      }

      // セッションを削除
      try {
        const deleteResponse = await fetch(`/api/sessions/${sessionId}`, {
          method: 'DELETE',
        });

        if (!deleteResponse.ok) {

        } else {

        }
      } catch (deleteError) {
        console.error('セッション削除エラー:', deleteError);
        // セッション削除に失敗しても処理は続行
      }

      // 2秒後に会計完了画面に遷移（クライアントサイドでのみ実行）
      if (typeof window !== 'undefined') {

        const redirectUrl = `${window.location.pathname}?${params.toString()}`;

        setTimeout(() => {

          window.location.href = redirectUrl;
        }, 2000);
      }
    } catch (error) {
      console.error('会計エラー:', error);
      // エラーメッセージをより詳細に表示
      let errorMessage = '会計処理に失敗しました';
      if (error instanceof Error) {
        errorMessage = error.message;
        console.error('エラー詳細:', error.stack);
      } else {
        console.error('不明なエラー形式:', typeof error, error);
      }
      setCheckoutError(errorMessage);


    } finally {
      setIsSubmitting(false);
    }
  };

  // 税抜き合計金額（注文 + テーブル料金）
  const subtotalAmount = orderTotalPrice + chargeAmount;

  // 消費税額を計算
  const calculatedTaxAmount = Math.floor(subtotalAmount * (taxRate / 100));

  // useEffectの外でもtaxAmountを更新
  useEffect(() => {
    setTaxAmount(calculatedTaxAmount);
  }, [calculatedTaxAmount]);

  // 税込み合計金額
  const totalAmount = subtotalAmount + calculatedTaxAmount;

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title="お会計"
      maxWidth="max-w-lg"
    >
      {checkoutSuccess ? (
        <div className="bg-green-50 border border-green-200 text-green-700 p-4 rounded-md mb-4">
          会計処理が完了しました。ありがとうございました。
        </div>
      ) : checkoutError ? (
        <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-md mb-4">
          {checkoutError}
        </div>
      ) : null}

      <div className="mb-6">
        <div className="bg-gray-50 p-4 rounded-md mb-4">
          <div className="flex justify-between mb-2">
            <span className="text-gray-600">席タイプ:</span>
            <span className="font-medium">{seatTypeName}</span>
          </div>
          {pricePerHalfHour > 0 && (
            <div className="flex justify-between mb-2">
              <span className="text-gray-600">料金:</span>
              <span className="font-medium">{pricePerHalfHour.toLocaleString()}円 / {timeUnitMinutes}分</span>
            </div>
          )}
          {chargeStartedAt && pricePerHalfHour > 0 && (
            <>
              <div className="flex justify-between mb-2">
                <span className="text-gray-600">経過時間:</span>
                <span className="font-medium">{elapsedTime}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-600">テーブル料金:</span>
                <span className="font-medium">{chargeAmount.toLocaleString()}円</span>
              </div>
            </>
          )}
        </div>

        <div className="mb-4">
          <h3 className="font-medium mb-2">注文内容</h3>
          {isLoadingOrders ? (
            <p className="text-gray-500">注文データを読み込み中...</p>
          ) : orderItems.length === 0 ? (
            <p className="text-gray-500">注文はありません</p>
          ) : (
            <ul className="divide-y">
              {orderItems.map((item, index) => (
                <li key={index} className="py-2 flex justify-between">
                  <div>
                    <span>{item.name}</span>
                    {item.target_cast_name && (
                      <span className="ml-2 text-sm text-blue-600">
                        ({item.target_cast_name}に奢る)
                      </span>
                    )}
                    <span className="ml-2 text-sm text-gray-500">
                      ×{item.quantity}
                    </span>
                  </div>
                  <span>
                    {item.total.toLocaleString()}円
                  </span>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>

      <div className="border-t border-gray-200 pt-4">
        <div className="flex justify-between mb-2">
          <span>注文合計:</span>
          <span>{orderTotalPrice.toLocaleString()}円</span>
        </div>
        {pricePerHalfHour > 0 && (
          <div className="flex justify-between mb-2">
            <span>テーブル料金:</span>
            <span>{chargeAmount.toLocaleString()}円</span>
          </div>
        )}
        <div className="flex justify-between mb-2">
          <span>小計（税抜）:</span>
          <span>{subtotalAmount.toLocaleString()}円</span>
        </div>
        <div className="flex justify-between mb-2">
          <span>消費税（{taxRate}%）:</span>
          <span>{calculatedTaxAmount.toLocaleString()}円</span>
        </div>
        <div className="flex justify-between font-bold text-lg">
          <span>合計金額（税込）:</span>
          <span>{totalAmount.toLocaleString()}円</span>
        </div>
      </div>

      <div className="mt-6">
        <form onSubmit={(e) => {
          e.preventDefault();
          handleCheckout(e);
        }}>
          <button
            type="submit"
            className={`bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 w-full ${
              isSubmitting ? 'opacity-50 cursor-not-allowed' : ''
            }`}
            disabled={isSubmitting || (orderItems.length === 0 && chargeAmount === 0)}
          >
            {isSubmitting ? '処理中...' : '会計する'}
          </button>
        </form>


      </div>
    </Modal>
  );
}
</file>

<file path="app/menu/[table_id]/client-customer-selection.tsx">
'use client';

import { useState } from 'react';
import CustomerTypeSelection from './customer-type-selection';
import CastSelection from './cast-selection';

export default function ClientSideCustomerTypeSelection({ 
  tableId, 
  sessionId, 
  storeId 
}: { 
  tableId: string, 
  sessionId: string, 
  storeId: string 
}) {
  const [showCastModal, setShowCastModal] = useState(false);

  return (
    <>
      <CustomerTypeSelection
        tableId={tableId}
        sessionId={sessionId}
        storeId={storeId}
        onShowCastSelection={() => setShowCastModal(true)}
      />
      
      <CastSelection
        isOpen={showCastModal}
        onClose={() => setShowCastModal(false)}
        tableId={tableId}
        sessionId={sessionId}
        storeId={storeId}
      />
    </>
  );
}
</file>

<file path="app/menu/[table_id]/client-menu-page.tsx">
'use client';

import { useState } from 'react';
import MenuDisplay from './menu-display';
import CartModal from './cart-modal';
import CheckoutModal from './checkout-modal';

interface ClientMenuPageProps {
  sessionId: string;
  tableId: string;
  tableName: string;
  storeName: string;
  seatTypeName: string;
  pricePerHalfHour: number;
  chargeStartedAt: string | null;
  chargePausedAt?: string | null;
  timeUnitMinutes?: number;
  menus: any[];
  menusByCategory: Record<string, any[]>;
  storeId: string;
  categories: any[];
}

export default function ClientMenuPage({
  sessionId,
  tableId,
  tableName,
  storeName,
  seatTypeName,
  pricePerHalfHour,
  chargeStartedAt,
  chargePausedAt,
  timeUnitMinutes = 30,
  menus,
  menusByCategory,
  storeId,
  categories,
  isSideMenuOpen = true, // 親コンポーネントから受け取る
  onToggleSideMenu = () => {} // 親コンポーネントから受け取る
}: ClientMenuPageProps & {
  isSideMenuOpen?: boolean;
  onToggleSideMenu?: () => void;
}) {
  const [isCartModalOpen, setIsCartModalOpen] = useState(false);
  const [isCheckoutModalOpen, setIsCheckoutModalOpen] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);

  // カテゴリーが選択されていない場合は最初のカテゴリーを選択
  const categoryList = Object.keys(menusByCategory);
  const currentCategory = selectedCategory || (categoryList.length > 0 ? categoryList[0] : null);

  return (
    <>

      <div className="flex h-full">
        {/* サイドメニュー（カテゴリ） - 開閉可能 */}
        <div
          className={`${
            isSideMenuOpen ? 'w-1/5 min-w-[120px] max-w-[150px]' : 'w-0 min-w-0'
          } bg-white shadow-md h-screen sticky top-[57px] left-0 overflow-y-auto transition-all duration-300 ease-in-out`}
        >
          <div className="py-4">
            <div className="flex flex-col">
              {categoryList.map((category) => (
                <button
                  key={category}
                  onClick={() => setSelectedCategory(category)}
                  className={`py-4 px-2 text-center text-sm font-medium transition-colors border-l-4 focus:outline-none ${
                    currentCategory === category
                      ? 'border-amber-500 bg-amber-50 text-amber-500'
                      : 'border-transparent text-gray-700 hover:bg-gray-50 active:bg-gray-100 focus:bg-white'
                  } ${!isSideMenuOpen ? 'hidden' : ''}`}
                >
                  {category}
                </button>
              ))}
            </div>
          </div>
        </div>

        {/* メインコンテンツ */}
        <div className={`w-full ${isSideMenuOpen ? 'pl-0' : 'pl-0'} transition-all duration-300 ease-in-out`}>
          <div className="bg-white p-4 md:p-6">
            <MenuDisplay
              menus={menus}
              menusByCategory={menusByCategory}
              storeId={storeId}
              categories={categories}
              selectedCategory={currentCategory}
              onCategoryChange={setSelectedCategory}
            />
          </div>
        </div>
      </div>

      {/* フローティングボタン */}
      <div className="fixed bottom-6 right-6 flex flex-col space-y-4">
        <button
          onClick={() => setIsCartModalOpen(true)}
          className="bg-amber-500 hover:bg-amber-600 active:bg-amber-700 focus:bg-amber-500 focus:outline-none text-white w-16 h-16 rounded-full flex items-center justify-center shadow-lg"
          aria-label="カートを表示"
        >
          <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path>
          </svg>
        </button>

        <button
          onClick={() => setIsCheckoutModalOpen(true)}
          className="bg-green-600 hover:bg-green-700 active:bg-green-800 focus:bg-green-600 focus:outline-none text-white w-16 h-16 rounded-full flex items-center justify-center shadow-lg"
          aria-label="お会計を表示"
        >
          <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path>
          </svg>
        </button>
      </div>

      {/* モーダル */}
      <CartModal
        isOpen={isCartModalOpen}
        onClose={() => setIsCartModalOpen(false)}
        sessionId={sessionId}
        tableId={tableId}
      />

      <CheckoutModal
        isOpen={isCheckoutModalOpen}
        onClose={() => setIsCheckoutModalOpen(false)}
        sessionId={sessionId}
        tableId={tableId}
        tableName={tableName}
        storeName={storeName}
        seatTypeName={seatTypeName}
        pricePerHalfHour={pricePerHalfHour}
        chargeStartedAt={chargeStartedAt}
        chargePausedAt={chargePausedAt}
        timeUnitMinutes={timeUnitMinutes}
      />
    </>
  );
}
</file>

<file path="app/menu/[table_id]/customer-type-selection.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface CustomerTypeSelectionProps {
  tableId: string;
  sessionId: string;
  storeId: string;
  onShowCastSelection: () => void;
}

export default function CustomerTypeSelection({
  tableId,
  sessionId,
  storeId,
  onShowCastSelection
}: CustomerTypeSelectionProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleNewCustomer = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 新規客として記録
      const response = await fetch(`/api/tables/${tableId}/sessions/${sessionId}/`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          is_new_customer: true,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || '処理に失敗しました');
      }

      // 画面を更新してメニュー表示に進む
      router.refresh();
    } catch (err) {
      console.error('新規客選択エラー:', err);
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDesignatedCustomer = () => {
    // キャスト選択モーダルを表示
    onShowCastSelection();
  };

  return (
    <div className="bg-white shadow rounded-lg p-6 mb-6">
      <h2 className="text-xl font-bold mb-4">ご利用タイプを選択</h2>
      <p className="mb-6">
        ご利用方法をお選びください
      </p>

      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <div className="grid grid-cols-1 gap-4">
        <button
          onClick={handleNewCustomer}
          disabled={isLoading}
          className="w-full bg-blue-600 text-white py-3 px-4 rounded-md hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed"
        >
          {isLoading ? '処理中...' : '新規（指名なし）'}
        </button>

        <button
          onClick={handleDesignatedCustomer}
          disabled={isLoading}
          className="w-full bg-purple-600 text-white py-3 px-4 rounded-md hover:bg-purple-700 disabled:bg-purple-300 disabled:cursor-not-allowed"
        >
          {isLoading ? '処理中...' : '指名あり'}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/header-with-menu-button.tsx">
'use client';

import { useState } from 'react';

interface HeaderWithMenuButtonProps {
  storeName: string;
  tableName: string;
  seatTypeName: string;
  pricePerUnit: number;
  timeUnitMinutes?: number;
  onToggleSideMenu: () => void;
}

export default function HeaderWithMenuButton({
  storeName,
  tableName,
  seatTypeName,
  pricePerUnit,
  timeUnitMinutes = 30,
  onToggleSideMenu
}: HeaderWithMenuButtonProps) {
  return (
    <header className="bg-white shadow-sm sticky top-0 z-10">
      <div className="max-w-full px-4 py-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-3">
            {/* ハンバーガーメニューアイコン */}
            <button
              onClick={onToggleSideMenu}
              className="bg-white hover:bg-gray-100 active:bg-gray-200 focus:bg-white focus:outline-none text-gray-700 p-2 rounded-md border border-gray-200"
              aria-label="メニューを開閉"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16"></path>
              </svg>
            </button>

            <div>
              <h1 className="text-xl font-bold text-gray-900">
                {storeName}
              </h1>
              <p className="text-sm text-gray-500">
                テーブル: {tableName} ({seatTypeName})
              </p>
            </div>
          </div>

          <div className="text-right">
            {pricePerUnit > 0 && (
              <p className="text-sm text-gray-500">
                料金: {pricePerUnit}円/{timeUnitMinutes}分
              </p>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="app/menu/[table_id]/menu-display.tsx">
'use client';

import { useState } from 'react';
import Image from 'next/image';
import { useCart } from './cart-context';
import CastSelectModal from './cast-select-modal';

interface Menu {
  menu_id: string;
  product_id: string;
  name: string;
  description: string | null;
  price: number;
  image_url: string | null;
  category: string | null;
  category_id: string | null;
  is_available: boolean;
  allow_treat_cast: boolean;
}

interface MenusByCategory {
  [category: string]: Menu[];
}

interface Category {
  category_id: string;
  name: string;
  display_order: number;
  allow_treat_cast: boolean;
}

interface MenuDisplayProps {
  menus: Menu[];
  menusByCategory: MenusByCategory;
  storeId: string;
  categories?: Category[];
  selectedCategory: string | null;
  onCategoryChange?: (category: string) => void;
}

export default function MenuDisplay({
  menus,
  menusByCategory,
  storeId,
  categories: categoryData,
  selectedCategory,
  onCategoryChange
}: MenuDisplayProps) {
  const [toast, setToast] = useState<{ visible: boolean; message: string }>({ visible: false, message: '' });
  const [selectedMenu, setSelectedMenu] = useState<Menu | null>(null);
  const [showCastModal, setShowCastModal] = useState(false);
  const { addItem } = useCart();

  // 表示するメニュー
  const displayMenus = selectedCategory ? menusByCategory[selectedCategory] : [];

  // トースト通知を表示する関数
  const showToast = (message: string) => {
    setToast({ visible: true, message });

    // 1秒後に非表示にする
    setTimeout(() => {
      setToast({ visible: false, message: '' });
    }, 1000);
  };

  // カートに商品を追加する関数
  const handleAddToCart = (menu: Menu, treatCast: boolean = false) => {
    if (treatCast) {
      // キャストに奢る場合、キャスト選択モーダルを表示
      setSelectedMenu(menu);
      setShowCastModal(true);
    } else {
      // 自分で注文する場合、そのままカートに追加（target_cast_idを明示的にnullに設定）
      addItem({
        menu_id: menu.menu_id,
        product_id: menu.product_id,
        name: menu.name,
        price: menu.price,
        target_cast_id: null
      }, 1); // 数量は常に1
      showToast(`${menu.name}をカートに追加しました`);
    }
  };

  // キャスト選択後の処理
  const handleCastSelect = (castId: string, castName: string) => {
    if (selectedMenu) {
      addItem({
        menu_id: selectedMenu.menu_id,
        product_id: selectedMenu.product_id,
        name: selectedMenu.name,
        price: selectedMenu.price,
        target_cast_id: castId,
        target_cast_name: castName
      }, 1); // 数量は常に1
      showToast(`${selectedMenu.name}を${castName}に奢りました`);
    }
    setShowCastModal(false);
    setSelectedMenu(null);
  };

  if (menus.length === 0) {
    return (
      <div className="text-center text-gray-500 py-8">
        メニューデータはまだ登録されていません。
        <br />
        管理者がスマレジから同期する必要があります。
      </div>
    );
  }

  return (
    <div className="relative">
      {/* トースト通知 */}
      {toast.visible && (
        <div className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-md shadow-md z-50 animate-fade-in-out">
          {toast.message}
        </div>
      )}

      {/* キャスト選択モーダル */}
      {showCastModal && (
        <CastSelectModal
          isOpen={showCastModal}
          onClose={() => setShowCastModal(false)}
          onSelect={handleCastSelect}
          storeId={storeId}
        />
      )}

      {/* メニュー一覧 */}
      <div className="divide-y divide-gray-100">
        {displayMenus.map((menu) => (
          <div
            key={menu.menu_id}
            className="py-3 flex items-center"
          >
            {/* 商品画像 */}
            {menu.image_url ? (
              <div className="w-16 h-16 relative mr-3 flex-shrink-0">
                <Image
                  src={menu.image_url}
                  alt={menu.name}
                  fill
                  sizes="64px"
                  className="object-cover rounded"
                />
              </div>
            ) : null}

            {/* 商品情報 */}
            <div className="flex-1 min-w-0">
              <h3 className="text-base font-medium text-gray-900 truncate">
                {menu.name}
              </h3>

              {menu.description ? (
                <p className="text-xs text-gray-500 mt-1 line-clamp-1">
                  {menu.description}
                </p>
              ) : null}

              <p className="text-base font-bold mt-1 text-gray-900">
                ¥{menu.price.toLocaleString()}
              </p>
            </div>

            {/* 注文ボタン */}
            <div className="flex items-center ml-3">
              <button
                type="button"
                className="bg-amber-500 hover:bg-amber-600 active:bg-amber-700 focus:bg-amber-500 text-white py-1 px-3 rounded-md text-sm focus:outline-none"
                onClick={() => handleAddToCart(menu, false)}
              >
                注文
              </button>

              {menu.allow_treat_cast && (
                <button
                  type="button"
                  className="bg-pink-500 hover:bg-pink-600 active:bg-pink-700 focus:bg-pink-500 text-white py-1 px-3 rounded-md text-sm ml-1 focus:outline-none"
                  onClick={() => handleAddToCart(menu, true)}
                >
                  奢る
                </button>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/menu-page-wrapper.tsx">
'use client';

import { useState } from 'react';
import ClientMenuPage from './client-menu-page';
import HeaderWithMenuButton from './header-with-menu-button';

interface MenuPageWrapperProps {
  sessionId: string;
  tableId: string;
  tableName: string;
  storeName: string;
  seatTypeName: string;
  pricePerHalfHour: number;
  chargeStartedAt: string | null;
  chargePausedAt?: string | null;
  timeUnitMinutes?: number;
  menus: any[];
  menusByCategory: Record<string, any[]>;
  storeId: string;
  categories: any[];
}

export default function MenuPageWrapper(props: MenuPageWrapperProps) {
  // サイドメニューの開閉状態を管理（デフォルトは開いた状態）
  const [isSideMenuOpen, setIsSideMenuOpen] = useState(true);

  // サイドメニューの開閉を切り替える関数
  const toggleSideMenu = () => {
    setIsSideMenuOpen(!isSideMenuOpen);
  };

  return (
    <div className="min-h-screen bg-gray-100">
      <HeaderWithMenuButton
        storeName={props.storeName}
        tableName={props.tableName}
        seatTypeName={props.seatTypeName}
        pricePerUnit={props.pricePerHalfHour}
        timeUnitMinutes={props.timeUnitMinutes}
        onToggleSideMenu={toggleSideMenu}
      />

      <main className="w-full px-0 py-0 md:py-6 md:px-0">
        <ClientMenuPage
          {...props}
          isSideMenuOpen={isSideMenuOpen}
          onToggleSideMenu={toggleSideMenu}
        />
      </main>

      <footer className="bg-white shadow-inner py-4 mt-8">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <p className="text-center text-sm text-gray-500">
            © 2025 {props.storeName} - QRオーダーシステム
          </p>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/modal.tsx">
'use client';

import { ReactNode } from 'react';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: ReactNode;
  maxWidth?: string;
}

export default function Modal({
  isOpen,
  onClose,
  title,
  children,
  maxWidth = 'max-w-md'
}: ModalProps) {
  if (!isOpen) return null;

  // モーダル外のクリックでモーダルを閉じる処理
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={handleBackdropClick}
    >
      <div
        className={`bg-white rounded-lg p-6 w-full ${maxWidth} mx-auto max-h-[90vh] overflow-y-auto`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">{title}</h2>
          <button
            type="button"
            className="text-gray-400 hover:text-gray-500"
            onClick={onClose}
          >
            <span className="sr-only">閉じる</span>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        <div>
          {children}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/menu/[table_id]/page.tsx">
import { notFound } from 'next/navigation';
import { ReactNode } from 'react';
import CheckoutComplete from './checkout-complete';
import { CartProvider } from './cart-context';
import SeatSelection from './seat-selection';
import ClientSideCustomerTypeSelection from './client-customer-selection';
import MenuPageWrapper from './menu-page-wrapper';

interface TableData {
  table_id: string;
  name: string;
  store_id: string;
  seat_type: {
    seat_type_id: string; // UUIDなので文字列型
    display_name: string;
    price_per_unit: number; // 時間単位あたりの料金
    time_unit_minutes?: number; // 時間単位（分）
  } | null;
  store: {
    store_id: string;
    name: string;
  } | null;
}

interface MenuData {
  menu_id: string;
  product_id: string;
  name: string;
  description: string | null;
  price: number;
  image_url: string | null;
  category: string | null;
  category_id: string | null;
  is_available: boolean;
  allow_treat_cast: boolean;
}

interface MenuResponse {
  menus: MenuData[];
  menusByCategory: Record<string, MenuData[]>;
  categories: any[];
}

interface SessionData {
  session_id: string;
  table_id: string;
  store_id: string;
  start_at: string;
  charge_started_at: string | null;
  charge_paused_at: string | null;
  selected_cast_id: string | null;
  is_new_customer: boolean | null;
}

export default async function MenuPage({
  params,
  searchParams
}: {
  params: Promise<{ table_id: string }>;
  searchParams: Promise<{
    complete?: string;
    total?: string;
    subtotal?: string;
    tax?: string;
    taxRate?: string;
    store?: string;
    table?: string;
  }>
}) {
  const { table_id } = await params;
  const searchParamsData = await searchParams;

  // 会計完了画面の表示判定
  const isCheckoutComplete = searchParamsData.complete === 'true';



  if (isCheckoutComplete && searchParamsData.total) {
    const totalAmount = parseInt(searchParamsData.total, 10) || 0;
    const subtotalAmount = parseInt(searchParamsData.subtotal || '0', 10) || 0;
    const taxAmount = parseInt(searchParamsData.tax || '0', 10) || 0;
    const taxRate = parseFloat(searchParamsData.taxRate || '10.0') || 10.0;

    // 値が空文字列の場合のフォールバック
    const storeName = searchParamsData.store ? decodeURIComponent(searchParamsData.store) : '不明な店舗';
    const tableName = searchParamsData.table ? decodeURIComponent(searchParamsData.table) : '不明なテーブル';

    return (
      <CheckoutComplete
        storeName={storeName}
        tableName={tableName}
        totalAmount={totalAmount}
        subtotalAmount={subtotalAmount}
        taxAmount={taxAmount}
        taxRate={taxRate}
      />
    );
  }

  // テーブル情報を取得
  const origin = process.env.NEXT_PUBLIC_URL || 'http://localhost:3000';
  const tableResponse = await fetch(`${origin}/api/tables/${table_id}`, {
    cache: 'no-store'
  });

  if (!tableResponse.ok) {
    if (tableResponse.status === 404) {
      notFound();
    }
    throw new Error(`テーブル情報の取得に失敗しました: ${tableResponse.statusText}`);
  }

  const table: TableData = await tableResponse.json();

  // メニュー情報を取得
  const menuResponse = await fetch(`${origin}/api/tables/${table_id}/menus`, {
    cache: 'no-store'
  });

  if (!menuResponse.ok) {
    throw new Error(`メニュー情報の取得に失敗しました: ${menuResponse.statusText}`);
  }

  const { menus: menuItems, menusByCategory, categories }: MenuResponse = await menuResponse.json();

  // セッション情報を取得または作成
  const sessionResponse = await fetch(`${origin}/api/tables/${table_id}/sessions`, {
    cache: 'no-store'
  });

  if (!sessionResponse.ok) {
    throw new Error(`セッション情報の取得に失敗しました: ${sessionResponse.statusText}`);
  }

  const session: SessionData = await sessionResponse.json();

  return (
    <CartProvider table_id={table_id}>
      <div className="min-h-screen bg-gray-100">

        {!session.charge_started_at ? (
          // ステップ1: 座席選択
          <main className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <SeatSelection
              tableId={table_id}
              tableName={table.name}
              sessionId={session.session_id}
            />
          </main>
        ) : session.charge_started_at && session.is_new_customer === null && session.selected_cast_id === null ? (
          // ステップ2: 新規/指名選択
          <main className="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <CustomerTypeSelectionWrapper
              tableId={table_id}
              sessionId={session.session_id}
              storeId={table.store_id}
            />
          </main>
        ) : (
          // ステップ3: メニュー表示 - サイドメニュー用に幅を最大に
          <MenuPageWrapper
            sessionId={session.session_id}
            tableId={table_id}
            tableName={table.name}
            storeName={table.store?.name || ''}
            seatTypeName={table.seat_type?.display_name || ''}
            pricePerHalfHour={table.seat_type?.price_per_unit || 0}
            chargeStartedAt={session.charge_started_at}
            chargePausedAt={session.charge_paused_at}
            timeUnitMinutes={table.seat_type?.time_unit_minutes || 30}
            menus={menuItems}
            menusByCategory={menusByCategory}
            storeId={table.store_id}
            categories={categories}
          />
        )}
      </div>
    </CartProvider>
  );
}

// クライアントコンポーネントをラップするためのサーバーコンポーネント
function CustomerTypeSelectionWrapper({ tableId, sessionId, storeId }: { tableId: string, sessionId: string, storeId: string }) {
  return (
    <ClientSideCustomerTypeSelection tableId={tableId} sessionId={sessionId} storeId={storeId} />
  );
}
</file>

<file path="app/menu/[table_id]/seat-selection.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface SeatSelectionProps {
  tableId: string;
  tableName: string;
  sessionId: string;
}

export default function SeatSelection({ tableId, tableName, sessionId }: SeatSelectionProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleSeatSelection = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 座席選択時間を記録
      const response = await fetch(`/api/tables/${tableId}/sessions/${sessionId}/`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          charge_started_at: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || '座席選択の処理に失敗しました');
      }

      // 画面を更新して次のステップ（新規/指名選択）に進む
      router.refresh();
    } catch (err) {
      console.error('座席選択エラー:', err);
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="bg-white shadow rounded-lg p-6 mb-6">
      <h2 className="text-xl font-bold mb-4">ようこそ</h2>
      <p className="mb-6">
        テーブル「{tableName}」にお座りになりますか？
      </p>

      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <button
        onClick={handleSeatSelection}
        disabled={isLoading}
        className="w-full bg-blue-600 text-white py-3 px-4 rounded-md hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed"
      >
        {isLoading ? '処理中...' : 'この席に座る'}
      </button>
    </div>
  );
}
</file>

<file path="app/page.tsx">
import Link from 'next/link';

// 店舗の型定義
interface Store {
  store_id: string;
  store_code: string;
  name: string;
}

export default async function HomePage() {
  // 店舗一覧をAPIから取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores`, {
    cache: 'no-store'
  });

  let stores: Store[] = [];
  if (response.ok) {
    stores = await response.json();
  } else {
    console.error('店舗一覧の取得に失敗しました:', await response.text());
  }

  return (
    <div className="min-h-screen bg-gray-100 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h1 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
          QRオーダー & 会計連携システム
        </h1>
        <p className="mt-2 text-center text-sm text-gray-600">
          ガールズバー向けQRオーダーシステム
        </p>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
          <h2 className="text-lg font-medium text-gray-900 mb-4">
            店舗を選択してください
          </h2>

          <div className="space-y-2">
            {stores && stores.length > 0 ? (
              stores.map((store) => (
                <Link
                  key={store.store_id}
                  href={`/login/${store.store_code}`}
                  className="w-full flex justify-between items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
                >
                  <span>{store.name}</span>
                  <span className="text-gray-400">&rarr;</span>
                </Link>
              ))
            ) : (
              <p className="text-center text-gray-500">
                登録されている店舗がありません。
              </p>
            )}
          </div>

          <div className="mt-6">
            <p className="text-center text-xs text-gray-500">
              ※ 店舗スタッフ専用ログインです。来店客は店内のQRコードからアクセスしてください。
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/casts/[id]/edit/page.tsx">
import { cookies } from 'next/headers';
import { redirect, notFound } from 'next/navigation';
import CastForm from '../../cast-form';

export default async function EditCastPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  console.log('EditCast: 転送するCookie:',
    allCookies.map(c => ({ name: c.name, value: c.name.includes('token') ? '***' : c.value }))
  );

  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // 店舗情報をAPIから取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報が見つかりません</div>;
  }

  const store = await storeResponse.json();

  // キャスト管理が無効の場合はダッシュボードにリダイレクト
  if (!store.enable_cast_management) {
    redirect('/portal/dashboard');
  }

  // APIからキャスト情報を取得
  const castResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/casts/${id}`, {
    cache: 'no-store'
  });

  if (!castResponse.ok) {
    console.error('キャスト情報の取得に失敗しました:', await castResponse.text());
    notFound();
  }

  const storeUser = await castResponse.json();
  console.log('キャスト情報取得結果:', { storeUser });

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">キャストを編集</h1>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <CastForm
              storeId={storeId}
              castId={storeUser.id}
              email={storeUser.email || ''}
              displayName={storeUser.display_name || ''}
              isEdit={true}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/casts/cast-form.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface CastFormProps {
  storeId: string;
  castId?: string;
  email?: string;
  displayName?: string;
  isEdit?: boolean;
}

export default function CastForm({
  storeId,
  castId,
  email = '',
  displayName = '',
  isEdit = false,
}: CastFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const [formData, setFormData] = useState({
    email: email,
    displayName: displayName,
    password: '',
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      if (isEdit) {
        // キャスト情報の更新
        const response = await fetch(`/api/casts/${castId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email: formData.email,
            display_name: formData.displayName,
            password: formData.password || undefined, // パスワードが空の場合は送信しない
          }),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'キャスト情報の更新に失敗しました');
        }

        setSuccess('キャスト情報を更新しました');
      } else {
        // 新規キャストの追加
        const response = await fetch('/api/casts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email: formData.email,
            display_name: formData.displayName,
            password: formData.password,
            store_id: storeId,
          }),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'キャストの追加に失敗しました');
        }

        setSuccess('キャストを追加しました');
        // フォームをリセット
        setFormData({
          email: '',
          displayName: '',
          password: '',
        });
      }

      // 成功メッセージを表示した後、一覧画面に戻る
      setTimeout(() => {
        router.push('/portal/casts');
        router.refresh();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async () => {
    if (!castId || !confirm('このキャストを削除しますか？')) {
      return;
    }

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch(`/api/casts/${castId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'キャストの削除に失敗しました');
      }

      setSuccess('キャストを削除しました');

      // 成功メッセージを表示した後、一覧画面に戻る
      setTimeout(() => {
        router.push('/portal/casts');
        router.refresh();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="space-y-6">
        {error && (
          <div className="bg-red-50 border-l-4 border-red-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
          </div>
        )}

        {success && (
          <div className="bg-green-50 border-l-4 border-green-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-green-700">{success}</p>
              </div>
            </div>
          </div>
        )}

        <div>
          <label htmlFor="displayName" className="block text-sm font-medium text-gray-700">
            名前
          </label>
          <div className="mt-1">
            <input
              type="text"
              name="displayName"
              id="displayName"
              value={formData.displayName}
              onChange={handleChange}
              className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
              required
              placeholder="キャストの名前"
            />
          </div>
        </div>

        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            メールアドレス
          </label>
          <div className="mt-1">
            <input
              type="email"
              name="email"
              id="email"
              value={formData.email}
              onChange={handleChange}
              className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
              required
            />
          </div>
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            パスワード {isEdit && '(変更する場合のみ入力)'}
          </label>
          <div className="mt-1">
            <input
              type="password"
              name="password"
              id="password"
              value={formData.password}
              onChange={handleChange}
              className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
              required={!isEdit}
              minLength={8}
            />
          </div>
          <p className="mt-1 text-sm text-gray-500">
            パスワードは8文字以上で設定してください
          </p>
        </div>

        <div className="flex justify-between">
          <div>
            <button
              type="button"
              onClick={() => router.back()}
              className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              キャンセル
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="ml-3 inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-blue-300"
            >
              {isLoading ? '処理中...' : isEdit ? '更新' : '追加'}
            </button>
          </div>

          {isEdit && (
            <button
              type="button"
              onClick={handleDelete}
              disabled={isLoading}
              className="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:bg-red-300"
            >
              削除
            </button>
          )}
        </div>
      </div>
    </form>
  );
}
</file>

<file path="app/portal/casts/delete-button.tsx">
'use client';

import { useState } from 'react';

interface DeleteButtonProps {
  castId: string;
}

export default function DeleteButton({ castId }: DeleteButtonProps) {
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    // 削除確認ダイアログ
    if (!confirm('このキャストを削除しますか？')) {
      return;
    }

    try {
      setIsDeleting(true);
      // 削除処理
      const response = await fetch(`/api/casts/${castId}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) {
        const data = await response.json();
        alert(data.error || 'キャストの削除に失敗しました');
        return;
      }
      
      alert('キャストを削除しました');
      window.location.reload();
    } catch (error) {
      console.error('キャスト削除エラー:', error);
      alert('キャストの削除に失敗しました');
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <button
      type="button"
      className="inline-flex items-center px-3 py-1 border border-transparent text-sm font-medium rounded-md text-red-700 bg-red-100 hover:bg-red-200"
      onClick={handleDelete}
      disabled={isDeleting}
    >
      {isDeleting ? '削除中...' : '削除'}
    </button>
  );
}
</file>

<file path="app/portal/casts/new/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import CastForm from '../cast-form';

export default async function NewCastPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  console.log('NewCast: 転送するCookie:',
    allCookies.map(c => ({ name: c.name, value: c.name.includes('token') ? '***' : c.value }))
  );

  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // 店舗情報をAPIから取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報が見つかりません</div>;
  }

  const store = await storeResponse.json();

  if (!store) {
    return <div>店舗情報が見つかりません</div>;
  }

  // キャスト管理が無効の場合はダッシュボードにリダイレクト
  if (!store.enable_cast_management) {
    redirect('/portal/dashboard');
  }

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">キャストを追加</h1>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <CastForm storeId={storeId} />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/casts/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import Link from 'next/link';
import DeleteButton from './delete-button';
import { createServerSupabaseClient } from '@/lib/supabase';

// キャストユーザーの型定義
interface StoreUser {
  id: string;
  user_id: string;
  display_name?: string;
  email?: string;
}

export default async function CastsPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');



  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // 店舗情報をAPIから取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報が見つかりません</div>;
  }

  const store = await storeResponse.json();

  // キャスト管理が無効の場合はダッシュボードにリダイレクト
  if (!store.enable_cast_management) {
    return (
      <div className="py-6">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-yellow-700">
                  キャスト管理機能は現在無効になっています。
                  <Link href="/portal/settings" className="font-medium underline text-yellow-700 hover:text-yellow-600">
                    設定画面
                  </Link>
                  から有効にしてください。
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // キャスト一覧をAPIから取得
  const castsResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/casts?storeId=${storeId}`, {
    cache: 'no-store'
  });

  let storeUsers: StoreUser[] = [];
  let storeUsersError = null;
  if (castsResponse.ok) {
    storeUsers = await castsResponse.json();
  } else {
    storeUsersError = await castsResponse.text();
    console.error('キャスト一覧の取得に失敗しました:', storeUsersError);
  }

  // キャスト情報が取得できた場合、各キャストのメールアドレスを取得
  if (storeUsers && storeUsers.length > 0) {
    // ユーザーIDの配列を作成
    const userIds = storeUsers.map((user: StoreUser) => user.user_id);

    // Supabaseクライアントを作成
    const supabase = await createServerSupabaseClient();

    // auth.usersテーブルから対応するメールアドレスを取得
    // Supabaseでは、authスキーマのテーブルにアクセスする場合は特別な方法が必要
    const { data: authUsers, error: authUsersError } = await supabase.auth.admin.listUsers();

    // 全ユーザーから必要なユーザーだけをフィルタリング
    // Supabaseの型定義に合わせる
    const filteredAuthUsers = authUsers?.users.filter((user) => {
      return userIds.includes(user.id);
    });



    // メールアドレス情報をキャスト情報に追加
    if (filteredAuthUsers && filteredAuthUsers.length > 0) {
      // ユーザーIDをキーとしたメールアドレスのマップを作成
      interface EmailMap {
        [key: string]: string;
      }

      const emailMap: EmailMap = {};

      // 手動でマップを作成
      filteredAuthUsers.forEach((user) => {
        if (user.id && user.email) {
          emailMap[user.id] = user.email;
        }
      });

      // キャスト情報にメールアドレスを追加
      storeUsers.forEach((user: StoreUser) => {
        if (user.user_id && emailMap[user.user_id]) {
          user.email = emailMap[user.user_id];
        } else {
          user.email = '';
        }
      });
    }
  }

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-semibold text-gray-900">キャスト管理</h1>
          <Link
            href="/portal/casts/new"
            className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700"
          >
            キャストを追加
          </Link>
        </div>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-md">
          <ul className="divide-y divide-gray-200">
            {storeUsers && storeUsers.length > 0 ? (
              storeUsers.map((storeUser: StoreUser) => (
                <li key={storeUser.id}>
                  <div className="px-4 py-4 flex items-center justify-between sm:px-6">
                    <div>
                      <p className="text-sm font-medium text-blue-600 truncate">{storeUser.display_name || '名前なし'}</p>
                      <p className="mt-1 text-sm text-gray-500">{storeUser.email || ''}</p>
                    </div>
                    <div className="flex space-x-2">
                      <Link
                        href={`/portal/casts/${storeUser.id}/edit`}
                        className="inline-flex items-center px-3 py-1 border border-transparent text-sm font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200"
                      >
                        編集
                      </Link>
                      <DeleteButton castId={storeUser.id} />
                    </div>
                  </div>
                </li>
              ))
            ) : (
              <li className="px-4 py-6 text-center text-gray-500">
                キャストが登録されていません
              </li>
            )}
          </ul>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/components/header.tsx">
'use client';

interface HeaderProps {
  storeName: string;
  userEmail: string;
  onToggleSideMenu: () => void;
  isSideMenuOpen: boolean;
}

export default function Header({ 
  storeName, 
  userEmail, 
  onToggleSideMenu,
  isSideMenuOpen
}: HeaderProps) {
  return (
    <header className="bg-white shadow-sm sticky top-0 z-10">
      <div className="px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16 items-center">
          <div className="flex items-center">
            {/* ハンバーガーメニューアイコン - モバイル用 */}
            <button
              onClick={onToggleSideMenu}
              className="md:hidden p-2 rounded-md text-gray-500 hover:bg-gray-100 focus:outline-none"
              aria-label="メニューを開閉"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
            
            <div className="flex-shrink-0 flex items-center ml-2 md:ml-0">
              <span className="text-lg font-bold">{storeName || '店舗'}</span>
            </div>
          </div>
          
          <div className="flex items-center">
            <div className="ml-3 relative">
              <div className="flex items-center">
                <span className="text-sm text-gray-500 mr-2">
                  {userEmail}
                </span>
                <form action="/api/logout" method="POST">
                  <button
                    type="submit"
                    className="bg-white p-1 rounded-full text-gray-400 hover:text-gray-500"
                  >
                    ログアウト
                  </button>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="app/portal/components/layout-wrapper.tsx">
'use client';

import { useState, useEffect } from 'react';
import Header from './header';
import SideMenu from './side-menu';

interface NavLink {
  href: string;
  label: string;
  roles: ('admin' | 'cast')[];
}

interface LayoutWrapperProps {
  children: React.ReactNode;
  navLinks: NavLink[];
  userRole: 'admin' | 'cast';
  storeName: string;
  userEmail: string;
}

export default function LayoutWrapper({
  children,
  navLinks,
  userRole,
  storeName,
  userEmail
}: LayoutWrapperProps) {
  // サイドメニューの開閉状態を管理（デフォルトは開いた状態）
  const [isSideMenuOpen, setIsSideMenuOpen] = useState(true);

  // サイドメニューの開閉を切り替える関数
  const toggleSideMenu = () => {
    setIsSideMenuOpen(!isSideMenuOpen);
  };

  // 画面サイズに応じてサイドメニューの状態を調整
  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth < 768) {
        setIsSideMenuOpen(false);
      } else {
        setIsSideMenuOpen(true);
      }
    };

    // 初期化時に一度実行
    handleResize();

    // リサイズイベントのリスナーを追加
    window.addEventListener('resize', handleResize);

    // クリーンアップ
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return (
    <div className="min-h-screen bg-gray-100 flex flex-col">
      <Header 
        storeName={storeName} 
        userEmail={userEmail} 
        onToggleSideMenu={toggleSideMenu}
        isSideMenuOpen={isSideMenuOpen}
      />

      <div className="flex flex-1 relative">
        <SideMenu 
          navLinks={navLinks} 
          userRole={userRole} 
          isSideMenuOpen={isSideMenuOpen} 
          onToggleSideMenu={toggleSideMenu} 
        />

        <main className={`flex-1 transition-all duration-300 ease-in-out py-10 ${isSideMenuOpen ? 'md:ml-64' : 'md:ml-16'}`}>
          <div className="px-4 sm:px-6 lg:px-8">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/components/side-menu.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';

interface NavLink {
  href: string;
  label: string;
  roles: ('admin' | 'cast')[];
}

interface SideMenuProps {
  navLinks: NavLink[];
  userRole: 'admin' | 'cast';
  isSideMenuOpen: boolean;
  onToggleSideMenu: () => void;
}

export default function SideMenu({ 
  navLinks, 
  userRole, 
  isSideMenuOpen, 
  onToggleSideMenu 
}: SideMenuProps) {
  const pathname = usePathname();

  return (
    <>
      {/* モバイル用オーバーレイ */}
      {isSideMenuOpen && (
        <div 
          className="fixed inset-0 bg-gray-600 bg-opacity-75 z-20 md:hidden" 
          onClick={onToggleSideMenu}
        />
      )}

      {/* サイドメニュー */}
      <div 
        className={`
          fixed md:sticky top-0 left-0 h-screen bg-white shadow-md z-30
          transition-all duration-300 ease-in-out
          ${isSideMenuOpen ? 'w-64' : 'w-0 md:w-16'} 
          overflow-hidden
        `}
      >
        <div className="h-full flex flex-col">
          {/* メニューヘッダー */}
          <div className="p-4 border-b">
            <div className="flex items-center justify-between">
              <h2 className={`font-bold text-lg ${!isSideMenuOpen && 'md:hidden'}`}>管理メニュー</h2>
              <button
                onClick={onToggleSideMenu}
                className="p-2 rounded-md text-gray-500 hover:bg-gray-100 focus:outline-none"
                aria-label="メニューを開閉"
              >
                {isSideMenuOpen ? (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                ) : (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 6h16M4 12h16M4 18h16" />
                  </svg>
                )}
              </button>
            </div>
          </div>

          {/* メニューリンク */}
          <nav className="flex-1 overflow-y-auto py-4">
            <ul className="space-y-1">
              {navLinks
                .filter(link => link.roles.includes(userRole))
                .map(link => {
                  const isActive = pathname === link.href;
                  return (
                    <li key={link.href}>
                      <Link
                        href={link.href}
                        className={`
                          flex items-center px-4 py-3 text-sm font-medium transition-colors
                          ${isActive 
                            ? 'bg-blue-50 text-blue-600 border-l-4 border-blue-600' 
                            : 'text-gray-700 hover:bg-gray-50 border-l-4 border-transparent'}
                        `}
                      >
                        <span className={!isSideMenuOpen ? 'md:hidden' : ''}>{link.label}</span>
                      </Link>
                    </li>
                  );
                })}
            </ul>
          </nav>
        </div>
      </div>
    </>
  );
}
</file>

<file path="app/portal/dashboard/dashboard-client.tsx">
'use client';

import { useEffect, useState } from 'react';
import { subscribeToSessions } from '@/lib/supabase-realtime';

// セッションの型定義
interface SeatType {
  seat_type_id: number;
  display_name: string;
  price_per_unit: number;
  time_unit_minutes?: number;
}

interface Table {
  table_id: string;
  name: string;
  seat_types: SeatType | null;
}

interface Session {
  session_id: string;
  start_at: string;
  charge_started_at: string | null;
  charge_paused_at: string | null;
  tables: Table | null;
}

interface DashboardClientProps {
  initialSessions: Session[];
  storeId: string;
}

export default function DashboardClient({ initialSessions, storeId }: DashboardClientProps) {
  const [sessions, setSessions] = useState<Session[]>(initialSessions);
  const [now, setNow] = useState(new Date());

  // 現在時刻を1秒ごとに更新
  useEffect(() => {
    const timer = setInterval(() => {
      setNow(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // リアルタイム更新のセットアップ
  useEffect(() => {
    if (!storeId) return;

    // 最新のセッションデータを取得する関数
    const fetchLatestSessions = async () => {
      try {
        const response = await fetch(`/api/dashboard/sessions?storeId=${storeId}`);
        if (response.ok) {
          const data = await response.json();
          setSessions(data);
        } else {
          console.error('セッションデータ取得エラー:', await response.text());
        }
      } catch (error) {
        console.error('セッションデータ取得エラー:', error);
      }
    };

    // Supabaseリアルタイムサブスクリプションのセットアップ
    const unsubscribe = subscribeToSessions(storeId, (payload) => {
      console.log('セッション更新イベント:', payload);
      fetchLatestSessions();
    });

    // 初回データ取得
    fetchLatestSessions();

    // 定期的なポーリングの設定（30秒ごと）- バックアップとして
    const pollingInterval = setInterval(fetchLatestSessions, 30000);

    // 画面がフォーカスされたときにも更新
    const handleFocus = () => {
      fetchLatestSessions();
    };
    window.addEventListener('focus', handleFocus);

    return () => {
      unsubscribe();
      clearInterval(pollingInterval);
      window.removeEventListener('focus', handleFocus);
    };
  }, [storeId]);

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">ダッシュボード</h1>

      <div className="bg-white shadow overflow-hidden sm:rounded-md">
        <ul className="divide-y divide-gray-200">
          {sessions && sessions.length > 0 ? (
            sessions.map((session) => {
              const startTime = new Date(session.charge_started_at || session.start_at);
              
              // 一時停止中かどうかを確認
              const isPaused = !!session.charge_paused_at;

              // 一時停止中の場合は、一時停止時間までの経過時間を計算
              const endTime = isPaused && session.charge_paused_at ? new Date(session.charge_paused_at) : now;

              const elapsedMinutes = Math.floor((endTime.getTime() - startTime.getTime()) / (1000 * 60));
              const hours = Math.floor(elapsedMinutes / 60);
              const minutes = elapsedMinutes % 60;

              return (
                <li key={session.session_id} className="px-6 py-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-lg font-medium text-gray-900">
                        {session.tables?.name || '不明なテーブル'}
                        ({session.tables?.seat_types?.display_name || '不明な席種'})
                      </p>
                      <p className="text-sm text-gray-500">
                        開始: {new Date(session.charge_started_at || session.start_at).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}
                      </p>
                    </div>
                    <div className="flex flex-col items-end">
                      <div className={`text-xl font-bold ${isPaused ? 'text-gray-500' : 'text-blue-600'}`}>
                        {hours > 0 ? `${hours}時間${minutes}分` : `${minutes}分`}
                      </div>
                      {isPaused && (
                        <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">一時停止中</span>
                      )}
                    </div>
                  </div>
                </li>
              );
            })
          ) : (
            <li className="px-6 py-4 text-center text-gray-500">
              現在アクティブなセッションはありません
            </li>
          )}
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/dashboard/page.tsx">
import { cookies } from 'next/headers';
import DashboardClient from './dashboard-client';

// セッションの型定義
interface SeatType {
  seat_type_id: number;
  display_name: string;
  price_per_unit: number;
  time_unit_minutes?: number;
}

interface Table {
  table_id: string;
  name: string;
  seat_types: SeatType | null;
}

interface Session {
  session_id: string;
  start_at: string;
  charge_started_at: string | null;
  charge_paused_at: string | null;
  tables: Table | null;
}

export default async function DashboardPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIからセッション情報を取得
  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/dashboard/sessions?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  let sessions: Session[] = [];
  if (response.ok) {
    sessions = await response.json();
  } else {
    console.error('セッション情報の取得に失敗しました:', await response.text());
  }

  // クライアントコンポーネントにセッションデータとストアIDを渡す
  return <DashboardClient initialSessions={sessions} storeId={storeId} />;
}
</file>

<file path="app/portal/menus/[id]/edit/page.tsx">
import { cookies } from 'next/headers';
import { redirect, notFound } from 'next/navigation';
import MenuForm from '../../menu-form';

export default async function EditMenuPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // APIからメニュー情報を取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/menus/${id}?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!response.ok) {
    console.error('メニュー情報の取得に失敗しました:', await response.text());
    notFound();
  }

  const menu = await response.json();

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">メニューを編集</h1>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <MenuForm
              storeId={storeId}
              menuId={menu.menu_id}
              initialData={{
                product_id: menu.product_id,
                name: menu.name,
                description: menu.description,
                price: menu.price,
                image_url: menu.image_url,
                category: menu.category,
                category_id: menu.category_id,
                is_available: menu.is_available,
              }}
              isEdit={true}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/menus/menu-form.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import { v4 as uuidv4 } from 'uuid';

interface Category {
  category_id: string;
  name: string;
  display_order: number;
}

interface MenuFormProps {
  storeId: string;
  menuId?: string;
  initialData?: {
    product_id: string;
    name: string;
    description: string | null;
    price: number;
    image_url: string | null;
    category: string | null;
    category_id: string | null;
    is_available: boolean;
  };
  isEdit?: boolean;
}

export default function MenuForm({
  storeId,
  menuId,
  initialData,
  isEdit = false,
}: MenuFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [uploadError, setUploadError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // 画像ファイルを保持するための状態
  const [selectedImage, setSelectedImage] = useState<{
    file: File | null;
    previewUrl: string | null;
    resizedBlob: Blob | null;
    fileName: string | null;
  }>({
    file: null,
    previewUrl: null,
    resizedBlob: null,
    fileName: null
  });

  const [formData, setFormData] = useState({
    product_id: initialData?.product_id || '',
    name: initialData?.name || '',
    description: initialData?.description || '',
    price: initialData?.price || 0,
    image_url: initialData?.image_url || '',
    category_id: initialData?.category_id || '',
    is_available: initialData?.is_available !== false, // デフォルトはtrue
  });

  const [categories, setCategories] = useState<Category[]>([]);
  const [isLoadingCategories, setIsLoadingCategories] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
      const checked = (e.target as HTMLInputElement).checked;
      setFormData({
        ...formData,
        [name]: checked,
      });
    } else if (type === 'number') {
      setFormData({
        ...formData,
        [name]: parseInt(value, 10) || 0,
      });
    } else {
      setFormData({
        ...formData,
        [name]: value,
      });
    }
  };

  // 画像をリサイズする関数
  const resizeImage = (file: File, maxWidth: number, maxHeight: number): Promise<Blob> => {
    return new Promise((resolve, reject) => {
      // 画像をロード
      const img = document.createElement('img');
      img.src = URL.createObjectURL(file);

      img.onload = () => {
        // 元の画像サイズを取得
        const originalWidth = img.width;
        const originalHeight = img.height;

        // リサイズ後のサイズを計算
        let newWidth = originalWidth;
        let newHeight = originalHeight;

        // 画像が指定サイズより大きい場合はリサイズ
        if (originalWidth > maxWidth || originalHeight > maxHeight) {
          const aspectRatio = originalWidth / originalHeight;

          if (aspectRatio > 1) {
            // 横長の画像
            newWidth = maxWidth;
            newHeight = maxWidth / aspectRatio;

            // 高さが最大値を超える場合は高さを基準にする
            if (newHeight > maxHeight) {
              newHeight = maxHeight;
              newWidth = maxHeight * aspectRatio;
            }
          } else {
            // 縦長の画像
            newHeight = maxHeight;
            newWidth = maxHeight * aspectRatio;

            // 幅が最大値を超える場合は幅を基準にする
            if (newWidth > maxWidth) {
              newWidth = maxWidth;
              newHeight = maxWidth / aspectRatio;
            }
          }
        }

        // Canvasを使用して画像をリサイズ
        const canvas = document.createElement('canvas');
        canvas.width = newWidth;
        canvas.height = newHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Canvas 2D context not available'));
          return;
        }

        // 画像を描画
        ctx.drawImage(img, 0, 0, newWidth, newHeight);

        // Blobに変換
        canvas.toBlob(
          (blob) => {
            if (blob) {
              // 使用済みのオブジェクトURLを解放
              URL.revokeObjectURL(img.src);
              resolve(blob);
            } else {
              reject(new Error('Failed to convert canvas to blob'));
            }
          },
          file.type, // 元の画像と同じ形式を維持
          0.9 // 品質（JPEG/WebPの場合）
        );
      };

      img.onerror = () => {
        URL.revokeObjectURL(img.src);
        reject(new Error('Failed to load image'));
      };
    });
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // ファイルタイプの検証
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (!allowedTypes.includes(file.type)) {
      setUploadError('許可されていないファイル形式です。JPEG、PNG、WebP、GIF形式のみ許可されています。');
      return;
    }

    // ファイルサイズの検証（5MB以下）
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (file.size > maxSize) {
      setUploadError('ファイルサイズが大きすぎます。5MB以下のファイルを選択してください。');
      return;
    }

    setIsUploading(true);
    setUploadError(null);

    try {
      // 画像をリサイズ（最大幅800px、最大高さ800px）
      const resizedBlob = await resizeImage(file, 800, 800);

      // UUIDベースのファイル名を生成
      const fileExtension = file.name.split('.').pop() || '';
      const uuid = uuidv4();
      const resizedFileName = `${uuid}.${fileExtension}`;

      // プレビュー用のURL生成
      const previewUrl = URL.createObjectURL(resizedBlob);

      // 選択した画像情報を保存
      setSelectedImage({
        file,
        previewUrl,
        resizedBlob,
        fileName: resizedFileName
      });

      // 既存の画像URLをクリア（新しい画像を選択した場合）
      if (formData.image_url) {
        setFormData(prev => ({
          ...prev,
          image_url: '',
        }));
      }
    } catch (err) {
      setUploadError(err instanceof Error ? err.message : '画像の処理に失敗しました');
    } finally {
      setIsUploading(false);
    }
  };

  // カテゴリ一覧を取得
  useEffect(() => {
    const fetchCategories = async () => {
      setIsLoadingCategories(true);
      try {
        const response = await fetch(`/api/menu-categories?storeId=${storeId}`);
        if (!response.ok) {
          throw new Error('カテゴリの取得に失敗しました');
        }
        const data = await response.json();
        setCategories(data);
      } catch (err) {
        console.error('カテゴリ取得エラー:', err);
      } finally {
        setIsLoadingCategories(false);
      }
    };

    fetchCategories();
  }, [storeId]);

  // コンポーネントのアンマウント時にプレビューURLを解放
  useEffect(() => {
    return () => {
      if (selectedImage.previewUrl) {
        URL.revokeObjectURL(selectedImage.previewUrl);
      }
    };
  }, [selectedImage.previewUrl]);

  // 画像をアップロードする関数
  const uploadImage = async (): Promise<string | null> => {
    if (!selectedImage.resizedBlob || !selectedImage.fileName) {
      return null; // 画像が選択されていない場合はnullを返す
    }

    try {
      // リサイズした画像をFileオブジェクトに変換
      const resizedFile = new File(
        [selectedImage.resizedBlob],
        selectedImage.fileName,
        { type: selectedImage.file?.type || 'image/jpeg' }
      );

      // FormDataを作成してアップロード
      const formData = new FormData();
      formData.append('file', resizedFile);

      const response = await fetch('/api/upload/menu-image', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || '画像のアップロードに失敗しました');
      }

      const data = await response.json();
      return data.url;
    } catch (err) {
      throw new Error(err instanceof Error ? err.message : '画像のアップロードに失敗しました');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      // 新しい画像が選択されている場合はアップロード
      let imageUrl = formData.image_url;
      if (selectedImage.resizedBlob) {
        setIsUploading(true);
        imageUrl = await uploadImage();
        setIsUploading(false);
      }

      // 更新するデータを準備
      const updatedData = {
        ...formData,
        image_url: imageUrl || formData.image_url,
        store_id: storeId,
      };

      if (isEdit && menuId) {
        // メニュー情報の更新
        const response = await fetch(`/api/menus/${menuId}?storeId=${storeId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updatedData),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'メニュー情報の更新に失敗しました');
        }

        setSuccess('メニュー情報を更新しました');
      } else {
        // 新規メニューの追加
        const response = await fetch(`/api/menus?storeId=${storeId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updatedData),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'メニューの追加に失敗しました');
        }

        setSuccess('メニューを追加しました');
        // フォームをリセット（新規追加の場合のみ）
        if (!isEdit) {
          setFormData({
            product_id: '',
            name: '',
            description: '',
            price: 0,
            image_url: '',
            category_id: '',
            is_available: true,
          });

          // 画像選択状態もリセット
          setSelectedImage({
            file: null,
            previewUrl: null,
            resizedBlob: null,
            fileName: null
          });
        }
      }

      // 成功メッセージを表示した後、一覧画面に戻る
      setTimeout(() => {
        router.push('/portal/menus');
        router.refresh();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async () => {
    if (!menuId || !confirm('このメニューを削除しますか？')) {
      return;
    }

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch(`/api/menus/${menuId}?storeId=${storeId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'メニューの削除に失敗しました');
      }

      setSuccess('メニューを削除しました');

      // 成功メッセージを表示した後、一覧画面に戻る
      setTimeout(() => {
        router.push('/portal/menus');
        router.refresh();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="space-y-6">
        {error && (
          <div className="bg-red-50 border-l-4 border-red-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
          </div>
        )}

        {success && (
          <div className="bg-green-50 border-l-4 border-green-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-green-700">{success}</p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
          <div>
            <label htmlFor="product_id" className="block text-sm font-medium text-gray-700">
              商品ID
            </label>
            <div className="mt-1">
              <input
                type="text"
                name="product_id"
                id="product_id"
                value={formData.product_id}
                onChange={handleChange}
                className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                required
                disabled={isEdit} // 編集時はIDを変更できないように
              />
            </div>
            {isEdit && (
              <p className="mt-1 text-xs text-gray-500">
                商品IDは編集できません
              </p>
            )}
          </div>

          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700">
              商品名
            </label>
            <div className="mt-1">
              <input
                type="text"
                name="name"
                id="name"
                value={formData.name}
                onChange={handleChange}
                className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                required
              />
            </div>
          </div>

          <div className="sm:col-span-2">
            <label htmlFor="description" className="block text-sm font-medium text-gray-700">
              商品説明
            </label>
            <div className="mt-1">
              <textarea
                name="description"
                id="description"
                rows={3}
                value={formData.description || ''}
                onChange={handleChange}
                className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
              />
            </div>
          </div>

          <div>
            <label htmlFor="price" className="block text-sm font-medium text-gray-700">
              価格（円）
            </label>
            <div className="mt-1">
              <input
                type="number"
                name="price"
                id="price"
                min="0"
                value={formData.price}
                onChange={handleChange}
                className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                required
              />
            </div>
          </div>

          <div>
            <label htmlFor="category_id" className="block text-sm font-medium text-gray-700">
              カテゴリー
            </label>
            <div className="mt-1">
              <select
                name="category_id"
                id="category_id"
                value={formData.category_id || ''}
                onChange={handleChange}
                className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
              >
                <option value="">カテゴリーを選択</option>
                {categories.map((category) => (
                  <option key={category.category_id} value={category.category_id}>
                    {category.name}
                  </option>
                ))}
              </select>
            </div>
            <div className="mt-1 text-xs text-gray-500">
              <a href="/portal/menu-categories" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">
                カテゴリーを管理する
              </a>
            </div>
          </div>

          <div>
            <label htmlFor="image_upload" className="block text-sm font-medium text-gray-700">
              画像アップロード
            </label>
            <div className="mt-1 flex items-center space-x-2">
              <input
                type="file"
                id="image_upload"
                ref={fileInputRef}
                onChange={handleFileChange}
                accept="image/jpeg,image/png,image/webp,image/gif"
                className="hidden"
              />
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                disabled={isUploading}
              >
                {isUploading ? '画像アップロード中...' : '画像を選択'}
              </button>
              {uploadError && (
                <p className="text-sm text-red-600">{uploadError}</p>
              )}
            </div>
            {/* 画像URLは非表示のフィールドとして保持 */}
            <input
              type="hidden"
              name="image_url"
              id="image_url"
              value={formData.image_url || ''}
            />
          </div>

          <div>
            {selectedImage.previewUrl ? (
              <div className="mt-2">
                <p className="block text-sm font-medium text-gray-700 mb-2">画像プレビュー（未保存）</p>
                <div className="w-32 h-32 relative">
                  <Image
                    src={selectedImage.previewUrl}
                    alt="商品画像プレビュー"
                    fill
                    sizes="128px"
                    className="object-cover rounded"
                    unoptimized
                  />
                </div>
                <button
                  type="button"
                  onClick={() => {
                    // プレビューURLを解放
                    if (selectedImage.previewUrl) {
                      URL.revokeObjectURL(selectedImage.previewUrl);
                    }
                    // 画像選択状態をリセット
                    setSelectedImage({
                      file: null,
                      previewUrl: null,
                      resizedBlob: null,
                      fileName: null
                    });
                  }}
                  className="mt-2 text-xs text-red-600 hover:text-red-800"
                >
                  画像を削除
                </button>
              </div>
            ) : formData.image_url ? (
              <div className="mt-2">
                <p className="block text-sm font-medium text-gray-700 mb-2">画像プレビュー（保存済み）</p>
                <div className="w-32 h-32 relative">
                  <Image
                    src={formData.image_url}
                    alt="商品画像プレビュー"
                    fill
                    sizes="128px"
                    className="object-cover rounded"
                    unoptimized
                  />
                </div>
                <button
                  type="button"
                  onClick={() => setFormData(prev => ({ ...prev, image_url: '' }))}
                  className="mt-2 text-xs text-red-600 hover:text-red-800"
                >
                  画像を削除
                </button>
              </div>
            ) : (
              <div className="mt-2">
                <p className="block text-sm font-medium text-gray-700 mb-2">画像プレビュー</p>
                <div className="w-32 h-32 bg-gray-200 rounded flex items-center justify-center">
                  <span className="text-gray-400 text-sm">画像なし</span>
                </div>
              </div>
            )}
          </div>

          <div className="sm:col-span-2">
            <div className="flex items-start">
              <div className="flex items-center h-5">
                <input
                  id="is_available"
                  name="is_available"
                  type="checkbox"
                  checked={formData.is_available}
                  onChange={handleChange}
                  className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                />
                <label htmlFor="is_available" className="ml-2 block text-sm text-gray-700">
                  提供可能
                </label>
              </div>
            </div>
          </div>
        </div>

        <div className="flex justify-between">
          <div>
            <button
              type="button"
              onClick={() => router.back()}
              className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              キャンセル
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="ml-3 inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-blue-300"
            >
              {isLoading ? '処理中...' : isEdit ? '更新' : '追加'}
            </button>
          </div>

          {isEdit && (
            <button
              type="button"
              onClick={handleDelete}
              disabled={isLoading}
              className="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:bg-red-300"
            >
              削除
            </button>
          )}
        </div>
      </div>
    </form>
  );
}
</file>

<file path="app/portal/menus/menu-list.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';

interface Category {
  category_id: string;
  name: string;
  display_order: number;
}

interface Menu {
  menu_id: string;
  product_id: string;
  name: string;
  description: string | null;
  price: number;
  image_url: string | null;
  category: string | null;
  category_id: string | null;
  is_available: boolean;
}

interface MenuListProps {
  menus: Menu[];
}

export default function MenuList({ menus }: MenuListProps) {
  const [filter, setFilter] = useState('');
  const [categoryFilter, setCategoryFilter] = useState<string | null>(null);
  const [availableFilter, setAvailableFilter] = useState<boolean | null>(null);
  const [categories, setCategories] = useState<Category[]>([]);
  const [isLoadingCategories, setIsLoadingCategories] = useState(false);

  // カテゴリ一覧を取得
  useEffect(() => {
    const fetchCategories = async () => {
      setIsLoadingCategories(true);
      try {
        // URLからクエリパラメータを取得
        const urlParams = new URLSearchParams(window.location.search);
        const storeId = urlParams.get('storeId') || localStorage.getItem('store-id');

        const response = await fetch(`/api/menu-categories?storeId=${storeId}`);
        if (!response.ok) {
          throw new Error('カテゴリの取得に失敗しました');
        }
        const data = await response.json();
        setCategories(data);
      } catch (err) {
        console.error('カテゴリ取得エラー:', err);
      } finally {
        setIsLoadingCategories(false);
      }
    };

    fetchCategories();
  }, []);

  // フィルタリングされたメニューを取得
  const filteredMenus = menus.filter(menu => {
    // 名前またはIDで検索
    const nameMatch = menu.name.toLowerCase().includes(filter.toLowerCase()) ||
                     menu.product_id.toLowerCase().includes(filter.toLowerCase());

    // カテゴリーでフィルタリング
    const categoryMatch = categoryFilter === null || menu.category_id === categoryFilter;

    // 提供可否でフィルタリング
    const availableMatch = availableFilter === null || menu.is_available === availableFilter;

    return nameMatch && categoryMatch && availableMatch;
  });

  // メニューが存在しない場合
  if (menus.length === 0) {
    return (
      <div className="bg-white shadow overflow-hidden sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6 text-center">
          <p className="text-gray-500">メニューが登録されていません。</p>
          <p className="text-gray-500 mt-2">「メニューを追加」ボタンから新しいメニューを追加するか、スマレジ連携が有効な場合は「スマレジ同期」ボタンを使用してください。</p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white shadow overflow-hidden sm:rounded-lg">
      <div className="px-4 py-5 sm:p-6">
        <div className="mb-6 grid grid-cols-1 gap-4 sm:grid-cols-4">
          <div className="col-span-1 sm:col-span-2">
            <label htmlFor="filter" className="block text-sm font-medium text-gray-700">
              検索
            </label>
            <input
              type="text"
              name="filter"
              id="filter"
              value={filter}
              onChange={(e) => setFilter(e.target.value)}
              placeholder="メニュー名またはID"
              className="mt-1 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md"
            />
          </div>

          <div>
            <label htmlFor="category" className="block text-sm font-medium text-gray-700">
              カテゴリー
            </label>
            <select
              id="category"
              name="category"
              value={categoryFilter || ''}
              onChange={(e) => setCategoryFilter(e.target.value || null)}
              className="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
            >
              <option value="">すべて</option>
              {categories.map((category) => (
                <option key={category.category_id} value={category.category_id}>
                  {category.name}
                </option>
              ))}
            </select>
          </div>

          <div className="flex space-x-4">
            <div>
              <label htmlFor="available" className="block text-sm font-medium text-gray-700">
                提供状態
              </label>
              <select
                id="available"
                name="available"
                value={availableFilter === null ? '' : availableFilter ? 'true' : 'false'}
                onChange={(e) => {
                  if (e.target.value === '') {
                    setAvailableFilter(null);
                  } else {
                    setAvailableFilter(e.target.value === 'true');
                  }
                }}
                className="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
              >
                <option value="">すべて</option>
                <option value="true">提供可</option>
                <option value="false">提供不可</option>
              </select>
            </div>


          </div>
        </div>

        <div className="mt-4">
          <p className="text-sm text-gray-500 mb-2">
            {filteredMenus.length} 件のメニューが見つかりました
          </p>
          <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {filteredMenus.map((menu) => (
              <div
                key={menu.menu_id}
                className={`border rounded-lg overflow-hidden shadow-sm ${
                  !menu.is_available ? 'bg-gray-50' : 'bg-white'
                }`}
              >
                <div className="p-4">
                  <div className="flex justify-between items-start">
                    <div>
                      <h3 className="text-lg font-medium text-gray-900 truncate">
                        {menu.name}
                      </h3>
                      <p className="text-sm text-gray-500">ID: {menu.product_id}</p>
                    </div>
                    <div className="flex flex-col items-end">
                      <span className="text-lg font-medium text-gray-900">
                        {menu.price.toLocaleString()}円
                      </span>
                      <div className="flex space-x-1 mt-1">
                        {!menu.is_available && (
                          <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                            提供停止
                          </span>
                        )}
                      </div>
                    </div>
                  </div>

                  <div className="mt-2 flex items-center">
                    {menu.image_url ? (
                      <div className="w-16 h-16 relative mr-3 flex-shrink-0">
                        <Image
                          src={menu.image_url}
                          alt={menu.name}
                          fill
                          sizes="64px"
                          className="object-cover rounded"
                        />
                      </div>
                    ) : (
                      <div className="w-16 h-16 bg-gray-200 rounded mr-3 flex items-center justify-center flex-shrink-0">
                        <span className="text-gray-400 text-xs">画像なし</span>
                      </div>
                    )}
                    <div className="flex-1">
                      <p className="text-sm text-gray-500 line-clamp-2">
                        {menu.description || '説明なし'}
                      </p>
                      <p className="text-xs text-gray-400 mt-1">
                        カテゴリー: {categories.find(c => c.category_id === menu.category_id)?.name || '未分類'}
                      </p>
                    </div>
                  </div>

                  <div className="mt-4 flex justify-end">
                    <Link
                      href={`/portal/menus/${menu.menu_id}/edit`}
                      className="inline-flex items-center px-3 py-1 border border-transparent text-sm font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200"
                    >
                      編集
                    </Link>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/menus/new/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import MenuForm from '../menu-form';

export default async function NewMenuPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');



  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // 店舗情報をAPIから取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報が見つかりません</div>;
  }

  const store = await storeResponse.json();

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">メニューを追加</h1>
      </div>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <div className="bg-white shadow overflow-hidden sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <MenuForm storeId={storeId} />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/menus/smaregi-sync-button.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface SmaregiSyncButtonProps {
  storeId: string;
  enableSmaregiIntegration: boolean;
}

export default function SmaregiSyncButton({
  storeId,
  enableSmaregiIntegration,
}: SmaregiSyncButtonProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const handleSync = async () => {
    if (!enableSmaregiIntegration) {
      setError('スマレジ連携が無効になっています。設定画面から有効にしてください。');
      return;
    }

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch('/api/smaregi-sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          store_id: storeId,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'スマレジ同期に失敗しました');
      }

      const data = await response.json();
      setSuccess(`スマレジ同期が完了しました。${data.count || 0}件のメニューを更新しました。`);
      
      // 画面を更新
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'スマレジ同期に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <button
        type="button"
        onClick={handleSync}
        disabled={isLoading || !enableSmaregiIntegration}
        className={`inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white ${
          enableSmaregiIntegration
            ? 'bg-green-600 hover:bg-green-700'
            : 'bg-gray-400 cursor-not-allowed'
        }`}
      >
        {isLoading ? (
          <>
            <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            同期中...
          </>
        ) : (
          'スマレジ同期'
        )}
      </button>

      {error && (
        <div className="mt-2 text-sm text-red-600">
          {error}
        </div>
      )}

      {success && (
        <div className="mt-2 text-sm text-green-600">
          {success}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/portal/order-board/order-board-client.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';
import { subscribeToOrders, subscribeToOrderItems } from '@/lib/supabase-realtime';

// 注文アイテムの型定義
interface OrderItem {
  order_id: string;
  order_item_id: string;
  status: string;
  created_at: string;
  created_by_role: string;
  proxy: boolean;
  table_name: string;
  product_id: string;
  product_name: string;
  quantity: number;
  price: number;
  total: number;
  target_cast_id: string | null;
  target_cast_name: string | null;
}

// 注文ステータスの定義
const ORDER_STATUSES = [
  { value: 'new', label: '新規', color: 'bg-green-500 text-white', nextStatus: 'ack' },
  { value: 'ack', label: '確認済', color: 'bg-pink-500 text-white', nextStatus: 'prep' },
  { value: 'prep', label: '準備中', color: 'bg-pink-500 text-white', nextStatus: 'served' },
  { value: 'served', label: '提供済', color: 'bg-gray-400 text-white', nextStatus: 'closed' },
  { value: 'closed', label: '完了', color: 'bg-gray-500 text-white', nextStatus: 'closed' },
  { value: 'cancel', label: 'キャンセル', color: 'bg-red-500 text-white', nextStatus: 'cancel' },
];

interface OrderBoardClientProps {
  initialOrderItems: OrderItem[];
  storeId: string;
}

export default function OrderBoardClient({ initialOrderItems, storeId }: OrderBoardClientProps) {
  const [orderItems, setOrderItems] = useState<OrderItem[]>(initialOrderItems);

  // 完了とキャンセル以外の注文アイテムをフィルタリングして古い順に並べる
  const activeOrderItems = useMemo(() => {
    return orderItems
      .filter((item: OrderItem) => item.status !== 'closed' && item.status !== 'cancel')
      .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
  }, [orderItems]);

  // リアルタイム更新のセットアップ
  useEffect(() => {
    if (!storeId) return;

    // 最新の注文データを取得する関数
    const fetchLatestOrders = async () => {
      try {
        console.log('注文データを取得中...');
        const response = await fetch('/api/orders/active-items');
        if (response.ok) {
          const data = await response.json();
          console.log('注文データ取得成功:', data.length + '件');
          setOrderItems(data);
        } else {
          console.error('注文データ取得エラー:', await response.text());
        }
      } catch (error) {
        console.error('注文データ取得エラー:', error);
      }
    };

    // Broadcast Channelの設定
    const broadcastChannel = new BroadcastChannel('broadcast:orders');
    broadcastChannel.onmessage = function(event) {
      console.log('ブロードキャストメッセージ受信:', event.data);
      // 注文関連のイベントが発生したら最新データを取得
      if (
        event.data.type === 'order:update' ||
        event.data.type === 'order:new' ||
        event.data.type === 'order_item:update' ||
        event.data.type === 'order_item:delete'
      ) {
        fetchLatestOrders();
      }
    };

    // Supabaseリアルタイムサブスクリプションのセットアップ
    console.log('Supabaseリアルタイムサブスクリプションを設定中...');
    
    // 注文テーブルのサブスクリプション
    const unsubscribeOrders = subscribeToOrders(storeId, (payload) => {
      console.log('注文テーブル更新イベント:', payload);
      fetchLatestOrders();
    });
    
    // 注文アイテムテーブルのサブスクリプション
    const unsubscribeOrderItems = subscribeToOrderItems(storeId, (payload) => {
      console.log('注文アイテムテーブル更新イベント:', payload);
      fetchLatestOrders();
    });

    // 初回データ取得
    fetchLatestOrders();

    // 定期的なポーリングの設定（30秒ごと）- バックアップとして
    const pollingInterval = setInterval(fetchLatestOrders, 30000);

    // 画面がフォーカスされたときにも更新
    const handleFocus = () => {
      console.log('画面がフォーカスされました。データを更新します。');
      fetchLatestOrders();
    };
    window.addEventListener('focus', handleFocus);

    return () => {
      broadcastChannel.close();
      unsubscribeOrders();
      unsubscribeOrderItems();
      clearInterval(pollingInterval);
      window.removeEventListener('focus', handleFocus);
    };
  }, [storeId]);

  // 注文アイテムのステータスを更新する関数
  const updateOrderItemStatus = async (orderItemId: string, newStatus: string) => {
    try {
      // 先にローカルの状態を更新して即時反映
      setOrderItems(prevItems =>
        prevItems.map(orderItem =>
          orderItem.order_item_id === orderItemId
            ? { ...orderItem, status: newStatus }
            : orderItem
        )
      );

      console.log(`注文アイテム ${orderItemId} のステータスを ${newStatus} に更新中...`);
      const formData = new FormData();
      formData.append('status', newStatus);

      const response = await fetch(`/api/order-items/${orderItemId}/status`, {
        method: 'PATCH',
        body: formData
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('注文アイテムのステータス更新に失敗しました', errorData);
        // 更新に失敗した場合は最新データを取得
        const updatedResponse = await fetch('/api/orders/active-items');
        if (updatedResponse.ok) {
          const data = await updatedResponse.json();
          setOrderItems(data);
        }
      }
    } catch (error) {
      console.error('注文アイテムステータス更新エラー:', error);
      // エラーが発生した場合も最新データを取得
      const updatedResponse = await fetch('/api/orders/active-items');
      if (updatedResponse.ok) {
        const data = await updatedResponse.json();
        setOrderItems(data);
      }
    }
  };

  // 次のステータスに進める関数
  const advanceOrderStatus = (item: OrderItem) => {
    const currentStatus = ORDER_STATUSES.find(s => s.value === item.status);
    if (currentStatus && currentStatus.nextStatus) {
      // 注文アイテム単位でステータスを更新
      updateOrderItemStatus(item.order_item_id, currentStatus.nextStatus);
    }
  };

  // 注文アイテムを削除する関数
  const deleteOrderItem = async (item: OrderItem, e: React.MouseEvent) => {
    e.stopPropagation(); // イベントの伝播を停止

    // 確認ダイアログを表示
    if (!confirm(`${item.product_name}をキャンセルしますか？`)) {
      return;
    }

    // 先にローカルの状態を更新して即時反映
    setOrderItems(prevItems =>
      prevItems.filter(orderItem => orderItem.order_item_id !== item.order_item_id)
    );

    // APIを呼び出してバックエンドを更新
    try {
      console.log(`注文アイテム ${item.order_item_id} を削除中...`);
      // 注文アイテム削除APIを使用
      const response = await fetch(`/api/order-items/${item.order_item_id}`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('注文アイテムのキャンセルに失敗しました', errorData);
        // キャンセルに失敗した場合は最新データを取得
        const updatedResponse = await fetch('/api/orders/active-items');
        if (updatedResponse.ok) {
          const data = await updatedResponse.json();
          setOrderItems(data);
        }
      }
    } catch (error) {
      console.error('注文アイテムキャンセルエラー:', error);
      // エラーが発生した場合も最新データを取得
      const updatedResponse = await fetch('/api/orders/active-items');
      if (updatedResponse.ok) {
        const data = await updatedResponse.json();
        setOrderItems(data);
      }
    }
  };

  // 経過時間を計算する関数
  const getElapsedTime = (createdAt: string) => {
    const orderTime = new Date(createdAt).getTime();
    const now = new Date().getTime();
    const diffMinutes = Math.floor((now - orderTime) / (1000 * 60));
    return `${diffMinutes}分経過`;
  };

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">注文ボード</h1>

      <div className="bg-gray-50 p-4 rounded-md">
        <h2 className="font-bold mb-4 px-2 py-1 border-b border-gray-200">
          アクティブな注文 ({activeOrderItems.length})
        </h2>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {activeOrderItems.map((item) => {
            const statusInfo = ORDER_STATUSES.find(s => s.value === item.status);
            return (
              <div
                key={item.order_item_id}
                className="rounded-md shadow-sm overflow-hidden"
                onClick={() => advanceOrderStatus(item)}
              >
                {/* ヘッダー部分 */}
                <div className={`flex justify-between items-center p-2 ${statusInfo?.color}`}>
                  <div className="flex items-center">
                    <span className="font-bold">{item.table_name}</span>
                    <span className="ml-2 text-xs">({item.order_item_id.substring(0, 4)})</span>
                  </div>
                  <span className="text-xs">{statusInfo?.label}</span>
                </div>

                {/* 商品情報部分 */}
                <div className="p-3 bg-white">
                  <div className="font-medium">{item.product_name}</div>

                  {/* 数量と経過時間 */}
                  <div className="flex justify-between items-center mt-2">
                    <div className="flex items-center">
                      <span className="text-sm">×{item.quantity}</span>
                      <span className="ml-3 text-xs text-gray-500">{getElapsedTime(item.created_at)}</span>
                    </div>

                    {/* キャンセルボタン */}
                    <button
                      className="bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs"
                      onClick={(e) => deleteOrderItem(item, e)}
                    >
                      ×
                    </button>
                  </div>

                  {/* キャスト情報 */}
                  {item.target_cast_name && (
                    <div className="text-sm text-blue-600 mt-1">
                      {item.target_cast_name}へ
                    </div>
                  )}
                </div>
              </div>
            );
          })}

          {activeOrderItems.length === 0 && (
            <div className="col-span-full text-center text-gray-500 text-sm py-8">
              アクティブな注文はありません
            </div>
          )}
        </div>
      </div>

      <div className="mt-8">
        <h2 className="text-lg font-bold mb-2">リアルタイム更新</h2>
        <p className="text-sm text-gray-600">
          このページは自動的に更新されます。注文ステータスの変更は即時に反映されます。
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/order-board/order-board.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';

// 注文アイテムの型定義
interface OrderItem {
  order_id: string;
  order_item_id: string;
  status: string;
  created_at: string;
  created_by_role: string;
  proxy: boolean;
  table_name: string;
  product_id: string;
  product_name: string;
  quantity: number;
  price: number;
  total: number;
  target_cast_id: string | null;
  target_cast_name: string | null;
}

// 注文ステータスの定義
const ORDER_STATUSES = [
  { value: 'new', label: '新規', color: 'bg-green-500 text-white', nextStatus: 'ack' },
  { value: 'ack', label: '確認済', color: 'bg-pink-500 text-white', nextStatus: 'prep' },
  { value: 'prep', label: '準備中', color: 'bg-pink-500 text-white', nextStatus: 'served' },
  { value: 'served', label: '提供済', color: 'bg-gray-400 text-white', nextStatus: 'closed' },
  { value: 'closed', label: '完了', color: 'bg-gray-500 text-white', nextStatus: 'closed' },
  { value: 'cancel', label: 'キャンセル', color: 'bg-red-500 text-white', nextStatus: 'cancel' },
];

interface OrderBoardProps {
  initialOrderItems: OrderItem[];
}

export default function OrderBoard({ initialOrderItems }: OrderBoardProps) {
  const [orderItems, setOrderItems] = useState<OrderItem[]>(initialOrderItems);

  // 完了とキャンセル以外の注文アイテムをフィルタリングして古い順に並べる
  const activeOrderItems = useMemo(() => {
    return orderItems
      .filter((item: OrderItem) => item.status !== 'closed' && item.status !== 'cancel')
      .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
  }, [orderItems]);

  // 定期的なポーリングとBroadcast Channelの設定
  useEffect(() => {
    // 最新の注文データを取得する関数
    const fetchLatestOrders = async () => {
      try {
        const response = await fetch('/api/orders/active-items');
        if (response.ok) {
          const data = await response.json();
          setOrderItems(data);
        } else {
          console.error('注文データ取得エラー:', await response.text());
        }
      } catch (error) {
        console.error('注文データ取得エラー:', error);
      }
    };

    // Broadcast Channelの設定
    const broadcastChannel = new BroadcastChannel('broadcast:orders');
    broadcastChannel.onmessage = function(event) {
      // 注文関連のイベントが発生したら最新データを取得
      if (
        event.data.type === 'order:update' ||
        event.data.type === 'order:new' ||
        event.data.type === 'order_item:update' ||
        event.data.type === 'order_item:delete'
      ) {
        fetchLatestOrders();
      }
    };

    // 初回データ取得
    fetchLatestOrders();

    // 定期的なポーリングの設定（3秒ごと）
    const pollingInterval = setInterval(fetchLatestOrders, 3000);

    // 画面がフォーカスされたときにも更新
    const handleFocus = () => {
      fetchLatestOrders();
    };
    window.addEventListener('focus', handleFocus);

    return () => {
      broadcastChannel.close();
      clearInterval(pollingInterval);
      window.removeEventListener('focus', handleFocus);
    };
  }, []);



  // 注文アイテムのステータスを更新する関数
  const updateOrderItemStatus = async (orderItemId: string, newStatus: string) => {
    try {
      // 先にローカルの状態を更新して即時反映
      setOrderItems(prevItems =>
        prevItems.map(orderItem =>
          orderItem.order_item_id === orderItemId
            ? { ...orderItem, status: newStatus }
            : orderItem
        )
      );

      const formData = new FormData();
      formData.append('status', newStatus);

      const response = await fetch(`/api/order-items/${orderItemId}/status`, {
        method: 'PATCH',
        body: formData
      });

      if (response.ok) {
        // 最新データは自動的にポーリングで取得されるため、ここでは取得しない
      } else {
        const errorData = await response.json();
        console.error('注文アイテムのステータス更新に失敗しました', errorData);

        // 更新に失敗した場合は最新データを取得
        const updatedResponse = await fetch('/api/orders/active-items');
        if (updatedResponse.ok) {
          const data = await updatedResponse.json();
          setOrderItems(data);
        }
      }
    } catch (error) {
      console.error('注文アイテムステータス更新エラー:', error);

      // エラーが発生した場合も最新データを取得
      console.log('エラー発生後のデータを取得中...');
      const updatedResponse = await fetch('/api/orders/active-items');
      if (updatedResponse.ok) {
        const data = await updatedResponse.json();
        setOrderItems(data);
      }
    }
  };

  // 次のステータスに進める関数
  const advanceOrderStatus = (item: OrderItem) => {
    const currentStatus = ORDER_STATUSES.find(s => s.value === item.status);
    if (currentStatus && currentStatus.nextStatus) {
      // 注文アイテム単位でステータスを更新
      updateOrderItemStatus(item.order_item_id, currentStatus.nextStatus);
    }
  };

  // 注文アイテムを削除する関数
  const deleteOrderItem = async (item: OrderItem, e: React.MouseEvent) => {
    e.stopPropagation(); // イベントの伝播を停止

    // 確認ダイアログを表示
    if (!confirm(`${item.product_name}をキャンセルしますか？`)) {
      return;
    }

    // 先にローカルの状態を更新して即時反映
    setOrderItems(prevItems =>
      prevItems.filter(orderItem => orderItem.order_item_id !== item.order_item_id)
    );

    // APIを呼び出してバックエンドを更新
    try {
      // 注文アイテム削除APIを使用
      const response = await fetch(`/api/order-items/${item.order_item_id}`, {
        method: 'DELETE'
      });

      if (response.ok) {
        // 最新データは自動的にポーリングで取得されるため、ここでは取得しない
      } else {
        const errorData = await response.json();
        console.error('注文アイテムのキャンセルに失敗しました', errorData);

        // キャンセルに失敗した場合は最新データを取得
        const updatedResponse = await fetch('/api/orders/active-items');
        if (updatedResponse.ok) {
          const data = await updatedResponse.json();
          setOrderItems(data);
        }
      }
    } catch (error) {
      console.error('注文アイテムキャンセルエラー:', error);

      // エラーが発生した場合も最新データを取得
      const updatedResponse = await fetch('/api/orders/active-items');
      if (updatedResponse.ok) {
        const data = await updatedResponse.json();
        setOrderItems(data);
      }
    }
  };

  // 経過時間を計算する関数
  const getElapsedTime = (createdAt: string) => {
    const orderTime = new Date(createdAt).getTime();
    const now = new Date().getTime();
    const diffMinutes = Math.floor((now - orderTime) / (1000 * 60));
    return `${diffMinutes}分経過`;
  };

  return (
    <div>
      <h1 className="text-2xl font-bold mb-6">注文ボード</h1>

      <div className="bg-gray-50 p-4 rounded-md">
        <h2 className="font-bold mb-4 px-2 py-1 border-b border-gray-200">
          アクティブな注文 ({activeOrderItems.length})
        </h2>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {activeOrderItems.map((item) => {
            const statusInfo = ORDER_STATUSES.find(s => s.value === item.status);
            return (
              <div
                key={item.order_item_id}
                className="rounded-md shadow-sm overflow-hidden"
                onClick={() => advanceOrderStatus(item)}
              >
                {/* ヘッダー部分 */}
                <div className={`flex justify-between items-center p-2 ${statusInfo?.color}`}>
                  <div className="flex items-center">
                    <span className="font-bold">{item.table_name}</span>
                    <span className="ml-2 text-xs">({item.order_item_id.substring(0, 4)})</span>
                  </div>
                  <span className="text-xs">{statusInfo?.label}</span>
                </div>

                {/* 商品情報部分 */}
                <div className="p-3 bg-white">
                  <div className="font-medium">{item.product_name}</div>

                  {/* 数量と経過時間 */}
                  <div className="flex justify-between items-center mt-2">
                    <div className="flex items-center">
                      <span className="text-sm">×{item.quantity}</span>
                      <span className="ml-3 text-xs text-gray-500">{getElapsedTime(item.created_at)}</span>
                    </div>

                    {/* キャンセルボタン */}
                    <button
                      className="bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs"
                      onClick={(e) => deleteOrderItem(item, e)}
                    >
                      ×
                    </button>
                  </div>

                  {/* キャスト情報 */}
                  {item.target_cast_name && (
                    <div className="text-sm text-blue-600 mt-1">
                      {item.target_cast_name}へ
                    </div>
                  )}
                </div>
              </div>
            );
          })}

          {activeOrderItems.length === 0 && (
            <div className="col-span-full text-center text-gray-500 text-sm py-8">
              アクティブな注文はありません
            </div>
          )}
        </div>
      </div>

      <div className="mt-8">
        <h2 className="text-lg font-bold mb-2">リアルタイム更新</h2>
        <p className="text-sm text-gray-600">
          このページは自動的に更新されます。注文ステータスの変更は即時に反映されます。
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/order-board/page.tsx">
import { cookies } from 'next/headers';
import OrderBoardClient from './order-board-client';

// 注文アイテムの型定義
interface OrderItem {
  order_id: string;
  order_item_id: string;
  status: string;
  created_at: string;
  created_by_role: string;
  proxy: boolean;
  table_name: string;
  product_id: string;
  product_name: string;
  quantity: number;
  price: number;
  total: number;
  target_cast_id: string | null;
  target_cast_name: string | null;
}

export default async function OrderBoardPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  // APIからアクティブな注文アイテムを取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/orders/active-items`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  let orderItems: OrderItem[] = [];
  if (response.ok) {
    orderItems = await response.json();
  } else {
    console.error('注文情報の取得に失敗しました:', await response.text());
  }

  // クライアントコンポーネントに初期データとストアIDを渡す
  return <OrderBoardClient initialOrderItems={orderItems} storeId={storeId} />;
}
</file>

<file path="app/portal/proxy-order/cart.tsx">
'use client';

import { useState } from 'react';

interface CartItem {
  menu_id: string;
  product_id: string;
  name: string;
  price: number;
  quantity: number;
  target_cast_id: string | null;
  from_user_id: string | null;
}

interface Cast {
  user_id: string;
  display_name: string;
}

interface CartProps {
  items: CartItem[];
  updateQuantity: (index: number, quantity: number) => void;
  clearCart: () => void;
  sessionId: string;
  tableId: string;
  tableName: string;
  casts: Cast[];
}

export default function Cart({
  items,
  updateQuantity,
  clearCart,
  sessionId,
  tableId,
  tableName,
  casts
}: CartProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [orderSuccess, setOrderSuccess] = useState(false);
  const [orderError, setOrderError] = useState<string | null>(null);

  // 合計金額を計算
  const totalPrice = items.reduce(
    (total, item) => total + item.price * item.quantity,
    0
  );

  // 注文を送信
  const submitOrder = async () => {
    if (items.length === 0) return;

    try {
      setIsSubmitting(true);
      setOrderError(null);

      // 注文データを準備
      const orderData = {
        session_id: sessionId,
        table_id: tableId,
        items: items.map(item => ({
          menu_id: item.menu_id,
          product_id: item.product_id,
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          target_cast_id: item.target_cast_id
        })),
        proxy: true,
        created_by_role: 'staff'
      };

      // 注文APIを呼び出し
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(orderData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '注文の送信に失敗しました');
      }

      // 注文成功
      setOrderSuccess(true);
      clearCart();

      // 2秒後に成功メッセージをクリア
      setTimeout(() => {
        setOrderSuccess(false);
      }, 2000);
    } catch (error) {
      console.error('注文エラー:', error);
      setOrderError(error instanceof Error ? error.message : '注文処理に失敗しました');
    } finally {
      setIsSubmitting(false);
    }
  };

  // キャスト名を取得
  const getCastName = (castId: string | null) => {
    if (!castId) return null;
    const cast = casts.find(c => c.user_id === castId);
    return cast ? cast.display_name : '不明なキャスト';
  };

  return (
    <div className="bg-gray-50 p-4 rounded-lg border sticky top-4">
      <h2 className="text-lg font-medium text-gray-900 mb-4">
        カート - {tableName}
      </h2>

      {items.length === 0 ? (
        <p className="text-gray-500 text-center py-4">カートは空です</p>
      ) : (
        <>
          <div className="space-y-3 mb-4 max-h-[400px] overflow-y-auto">
            {items.map((item, index) => (
              <div key={`${item.menu_id}-${item.target_cast_id}-${index}`} className="flex justify-between border-b pb-2">
                <div>
                  <p className="font-medium">{item.name}</p>
                  <p className="text-sm text-gray-500">¥{item.price.toLocaleString()} × {item.quantity}</p>
                  {item.target_cast_id && (
                    <p className="text-xs text-purple-600">
                      {getCastName(item.target_cast_id)}に奢る
                    </p>
                  )}
                </div>
                <div className="flex items-center">
                  <button
                    onClick={() => updateQuantity(index, item.quantity - 1)}
                    className="text-gray-500 hover:text-gray-700 px-2"
                  >
                    -
                  </button>
                  <span className="mx-1">{item.quantity}</span>
                  <button
                    onClick={() => updateQuantity(index, item.quantity + 1)}
                    className="text-gray-500 hover:text-gray-700 px-2"
                  >
                    +
                  </button>
                </div>
              </div>
            ))}
          </div>

          <div className="border-t pt-3">
            <div className="flex justify-between font-bold text-lg mb-4">
              <span>合計</span>
              <span>¥{totalPrice.toLocaleString()}</span>
            </div>

            <div className="space-y-2">
              <button
                onClick={submitOrder}
                disabled={isSubmitting}
                className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-blue-300"
              >
                {isSubmitting ? '処理中...' : '代理注文を確定'}
              </button>
              <button
                onClick={clearCart}
                className="w-full bg-gray-200 text-gray-800 py-2 px-4 rounded hover:bg-gray-300"
              >
                カートをクリア
              </button>
            </div>
          </div>
        </>
      )}

      {orderSuccess && (
        <div className="mt-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded">
          注文が正常に送信されました
        </div>
      )}

      {orderError && (
        <div className="mt-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
          {orderError}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/portal/proxy-order/cast-select-modal.tsx">
'use client';

import { useState, useEffect } from 'react';

interface Cast {
  id: string;
  user_id: string;
  display_name: string;
}

interface CastSelectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (castId: string, castName: string) => void;
  storeId: string;
}

export default function CastSelectModal({ isOpen, onClose, onSelect, storeId }: CastSelectModalProps) {
  const [casts, setCasts] = useState<Cast[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // キャスト一覧を取得
  useEffect(() => {
    if (!isOpen) return;

    const fetchCasts = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/casts?store_id=${storeId}`);
        
        if (!response.ok) {
          throw new Error('キャスト情報の取得に失敗しました');
        }
        
        const data = await response.json();
        setCasts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
        console.error('キャスト取得エラー:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchCasts();
  }, [isOpen, storeId]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">キャストを選択</h2>
          <button
            type="button"
            className="text-gray-400 hover:text-gray-500"
            onClick={onClose}
          >
            <span className="sr-only">閉じる</span>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {loading ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">読み込み中...</p>
          </div>
        ) : error ? (
          <div className="py-8 text-center">
            <p className="text-red-500">{error}</p>
            <button
              type="button"
              className="mt-4 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              onClick={onClose}
            >
              閉じる
            </button>
          </div>
        ) : casts.length === 0 ? (
          <div className="py-8 text-center">
            <p className="text-gray-500">キャストが登録されていません</p>
            <button
              type="button"
              className="mt-4 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
              onClick={onClose}
            >
              閉じる
            </button>
          </div>
        ) : (
          <div className="mt-4 grid grid-cols-1 gap-4">
            {casts.map((cast) => (
              <button
                key={cast.id}
                className="flex items-center p-3 border rounded-lg hover:bg-gray-50"
                onClick={() => onSelect(cast.user_id, cast.display_name)}
              >
                <div className="w-10 h-10 bg-gray-200 rounded-full flex items-center justify-center mr-3">
                  <span className="text-gray-500 text-sm">{cast.display_name.charAt(0)}</span>
                </div>
                <div className="flex-1 text-left">
                  <p className="font-medium">{cast.display_name}</p>
                </div>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/portal/proxy-order/menu-display.tsx">
'use client';

import { useState, useEffect } from 'react';
import Cart from './cart';
import CastSelectModal from './cast-select-modal';

interface MenuDisplayProps {
  tableId: string;
  sessionId: string;
  tableName: string;
}

interface MenuItem {
  menu_id: string;
  product_id: string;
  name: string;
  description: string | null;
  price: number;
  image_url: string | null;
  category_id: string | null;
  category: string | null;
  is_available: boolean;
}

interface Category {
  category_id: string;
  name: string;
  display_order: number;
  allow_treat_cast: boolean;
}

interface Cast {
  user_id: string;
  display_name: string;
}

interface CartItem {
  menu_id: string;
  product_id: string;
  name: string;
  price: number;
  quantity: number;
  target_cast_id: string | null;
  from_user_id: string | null;
}

export default function MenuDisplay({ tableId, sessionId, tableName }: MenuDisplayProps) {
  const [categories, setCategories] = useState<Category[]>([]);
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [casts, setCasts] = useState<Cast[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [cartItems, setCartItems] = useState<CartItem[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [addedMessage, setAddedMessage] = useState<string | null>(null);
  const [showCastModal, setShowCastModal] = useState(false);
  const [selectedMenu, setSelectedMenu] = useState<MenuItem | null>(null);
  const [storeId, setStoreId] = useState<string>('');

  // メニューとカテゴリを取得
  useEffect(() => {
    const fetchMenuData = async () => {
      try {
        setLoading(true);
        // メニュー情報を取得
        const menuResponse = await fetch(`/api/tables/${tableId}/menus`);
        if (!menuResponse.ok) {
          throw new Error('メニュー情報の取得に失敗しました');
        }
        const menuData = await menuResponse.json();

        setCategories(menuData.categories || []);
        setMenuItems(menuData.menus || []);

        // 最初のカテゴリを選択
        if (menuData.categories && menuData.categories.length > 0) {
          setSelectedCategory(menuData.categories[0].category_id);
        }

        // テーブル情報を取得して店舗IDを特定
        const tableResponse = await fetch(`/api/tables/${tableId}`);
        if (!tableResponse.ok) {
          throw new Error('テーブル情報の取得に失敗しました');
        }
        const tableData = await tableResponse.json();
        const fetchedStoreId = tableData.store_id;
        setStoreId(fetchedStoreId);

        // キャスト情報を取得（store_idクエリパラメータを指定）
        const castsResponse = await fetch(`/api/casts?store_id=${fetchedStoreId}`);
        if (castsResponse.ok) {
          const castsData = await castsResponse.json();
          setCasts(castsData || []);
        } else {
          console.error('キャスト情報取得エラー:', await castsResponse.text());
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
      } finally {
        setLoading(false);
      }
    };

    fetchMenuData();
  }, [tableId]);

  // カートに商品を追加
  const addToCart = (item: MenuItem, treatCast: boolean = false) => {
    if (treatCast) {
      // キャストに奢る場合、キャスト選択モーダルを表示
      setSelectedMenu(item);
      setShowCastModal(true);
    } else {
      // 自分で注文する場合、そのままカートに追加
      const existingItemIndex = cartItems.findIndex(
        cartItem =>
          cartItem.menu_id === item.menu_id &&
          cartItem.target_cast_id === null
      );

      if (existingItemIndex !== -1) {
        // 既存のアイテムの数量を増やす
        const updatedItems = [...cartItems];
        updatedItems[existingItemIndex].quantity += 1;
        setCartItems(updatedItems);
      } else {
        // 新しいアイテムをカートに追加
        setCartItems([
          ...cartItems,
          {
            menu_id: item.menu_id,
            product_id: item.product_id,
            name: item.name,
            price: item.price,
            quantity: 1,
            target_cast_id: null,
            from_user_id: null
          }
        ]);
      }

      // 追加メッセージを表示して1秒後に消す
      setAddedMessage(`${item.name}をカートに追加しました`);
      setTimeout(() => {
        setAddedMessage(null);
      }, 1000);
    }
  };

  // キャスト選択後の処理
  const handleCastSelect = (castId: string, castName: string) => {
    if (selectedMenu) {
      const existingItemIndex = cartItems.findIndex(
        cartItem =>
          cartItem.menu_id === selectedMenu.menu_id &&
          cartItem.target_cast_id === castId
      );

      if (existingItemIndex !== -1) {
        // 既存のアイテムの数量を増やす
        const updatedItems = [...cartItems];
        updatedItems[existingItemIndex].quantity += 1;
        setCartItems(updatedItems);
      } else {
        // 新しいアイテムをカートに追加
        setCartItems([
          ...cartItems,
          {
            menu_id: selectedMenu.menu_id,
            product_id: selectedMenu.product_id,
            name: selectedMenu.name,
            price: selectedMenu.price,
            quantity: 1,
            target_cast_id: castId,
            from_user_id: null
          }
        ]);
      }

      // 追加メッセージを表示して1秒後に消す
      setAddedMessage(`${selectedMenu.name}を${castName}に奢りました`);
      setTimeout(() => {
        setAddedMessage(null);
      }, 1000);
    }
    setShowCastModal(false);
    setSelectedMenu(null);
  };

  // カートをクリア
  const clearCart = () => {
    setCartItems([]);
  };

  // カート内のアイテムの数量を変更
  const updateQuantity = (index: number, newQuantity: number) => {
    if (newQuantity <= 0) {
      // 数量が0以下の場合はアイテムを削除
      const updatedItems = cartItems.filter((_, i) => i !== index);
      setCartItems(updatedItems);
    } else {
      // 数量を更新
      const updatedItems = [...cartItems];
      updatedItems[index].quantity = newQuantity;
      setCartItems(updatedItems);
    }
  };

  if (loading) {
    return <div className="text-center py-10">メニューを読み込み中...</div>;
  }

  if (error) {
    return (
      <div className="bg-red-50 border-l-4 border-red-400 p-4">
        <div className="flex">
          <div className="ml-3">
            <p className="text-sm text-red-700">{error}</p>
          </div>
        </div>
      </div>
    );
  }

  const filteredItems = selectedCategory
    ? menuItems.filter(item => item.category_id === selectedCategory)
    : menuItems;

  const selectedCategoryData = categories.find(cat => cat.category_id === selectedCategory);
  const allowTreatCast = selectedCategoryData?.allow_treat_cast || false;

  return (
    <div className="flex flex-col md:flex-row gap-6">
      {/* キャスト選択モーダル */}
      {showCastModal && (
        <CastSelectModal
          isOpen={showCastModal}
          onClose={() => setShowCastModal(false)}
          onSelect={handleCastSelect}
          storeId={storeId}
        />
      )}

      {/* 追加メッセージ */}
      {addedMessage && (
        <div className="fixed top-4 right-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded z-50">
          {addedMessage}
        </div>
      )}

      <div className="md:w-2/3">
        {/* カテゴリ選択 */}
        <div className="mb-6">
          <div className="flex flex-wrap gap-2">
            {categories.map(category => (
              <button
                key={category.category_id}
                onClick={() => setSelectedCategory(category.category_id)}
                className={`px-4 py-2 rounded-full text-sm font-medium ${
                  selectedCategory === category.category_id
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                }`}
              >
                {category.name}
              </button>
            ))}
          </div>
        </div>



        {/* メニュー一覧 */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredItems.map(item => (
            <div key={item.menu_id} className="border rounded-lg overflow-hidden shadow-sm">
              {item.image_url && (
                <div className="h-40 overflow-hidden">
                  <img
                    src={item.image_url}
                    alt={item.name}
                    className="w-full h-full object-cover"
                  />
                </div>
              )}
              <div className="p-4">
                <h3 className="font-medium">{item.name}</h3>
                {item.description && (
                  <p className="text-sm text-gray-500 mt-1">{item.description}</p>
                )}
                <p className="text-lg font-bold mt-2">¥{item.price.toLocaleString()}</p>

                <div className="mt-4 space-y-2">
                  <button
                    onClick={() => addToCart(item, false)}
                    className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700"
                  >
                    カートに追加
                  </button>

                  {allowTreatCast && casts.length > 0 && (
                    <button
                      onClick={() => addToCart(item, true)}
                      className="w-full bg-pink-600 hover:bg-pink-700 text-white py-2 px-4 rounded-md"
                    >
                      キャストに奢る
                    </button>
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* カート */}
      <div className="md:w-1/3">
        <Cart
          items={cartItems}
          updateQuantity={updateQuantity}
          clearCart={clearCart}
          sessionId={sessionId}
          tableId={tableId}
          tableName={tableName}
          casts={casts}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/portal/proxy-order/page.tsx">
import { cookies } from 'next/headers';
import TableSelector from './table-selector';
import { Suspense } from 'react';

export default async function ProxyOrderPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');



  // APIからアクティブなテーブル情報を取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/proxy-order/active-tables?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  let activeTables = [];
  if (response.ok) {
    activeTables = await response.json();

  } else {
    console.error('アクティブテーブルの取得に失敗しました:', await response.text());
  }

  // アクティブなテーブルがない場合
  if (!activeTables || activeTables.length === 0) {

    return (
      <div className="py-6">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <h1 className="text-2xl font-semibold text-gray-900 mb-6">代理注文</h1>

          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
            <div className="flex">
              <div className="ml-3">
                <p className="text-sm text-yellow-700">
                  現在、アクティブなテーブルがありません。お客様が着席してチャージが開始されたテーブルが表示されます。
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900 mb-6">代理注文</h1>

        <Suspense fallback={<div>テーブル情報を読み込み中...</div>}>
          <TableSelector tables={activeTables} />
        </Suspense>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/proxy-order/table-selector.tsx">
'use client';

import { useState } from 'react';
import MenuDisplay from './menu-display';

interface Table {
  table_id: string;
  name: string;
  session_id: string;
  seat_type: string;
}

interface TableSelectorProps {
  tables: Table[];
}

export default function TableSelector({ tables }: TableSelectorProps) {
  const [selectedTable, setSelectedTable] = useState<Table | null>(null);

  const handleTableSelect = (table: Table) => {
    setSelectedTable(table);
  };

  return (
    <div>
      {!selectedTable ? (
        <div>
          <h2 className="text-lg font-medium text-gray-900 mb-4">テーブルを選択してください</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {tables.map((table) => (
              <div
                key={table.table_id}
                className="border rounded-lg p-4 cursor-pointer hover:bg-gray-50"
                onClick={() => handleTableSelect(table)}
              >
                <h3 className="font-medium">{table.name}</h3>
                <p className="text-sm text-gray-500">席種: {table.seat_type}</p>
              </div>
            ))}
          </div>
        </div>
      ) : (
        <div>
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-lg font-medium text-gray-900">
              {selectedTable.name} のメニュー
            </h2>
            <button
              onClick={() => setSelectedTable(null)}
              className="text-sm text-blue-600 hover:text-blue-800"
            >
              テーブル選択に戻る
            </button>
          </div>
          <MenuDisplay 
            tableId={selectedTable.table_id} 
            sessionId={selectedTable.session_id}
            tableName={selectedTable.name}
          />
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/portal/seat-types/_components/seat-type-form.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// マイグレーション後はcodeカラムが存在しないため、型定義を修正
type SeatTypeInput = {
  display_name: string;
  price_per_unit: number;  // 時間単位あたりの料金
  store_id: string;
  time_unit_minutes: number;
  smaregi_product_id?: string;
};

// フォームで使用する型（seat_type_idを含む）
interface SeatTypeFormValues extends SeatTypeInput {
  seat_type_id?: string;
}

// スマレジ商品の型定義
interface SmaregiProduct {
  productId: string;
  name: string;
  price: number;
}

export default function SeatTypeForm({
  defaultValues
}: {
  defaultValues: Partial<SeatTypeFormValues>;
}) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSmaregiEnabled, setIsSmaregiEnabled] = useState(false);
  const [showSmaregiModal, setShowSmaregiModal] = useState(false);
  const [smaregiProducts, setSmaregiProducts] = useState<SmaregiProduct[]>([]);
  const [isLoadingProducts, setIsLoadingProducts] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');

  const [formValues, setFormValues] = useState<SeatTypeInput>({
    display_name: defaultValues.display_name || '',
    price_per_unit: defaultValues.price_per_unit || 0, // 互換性のため両方チェック
    store_id: defaultValues.store_id || '',
    time_unit_minutes: defaultValues.time_unit_minutes || 30, // デフォルトは30分
    smaregi_product_id: defaultValues.smaregi_product_id || '',
  });

  // スマレジ連携が有効になった時に価格を0にリセット
  useEffect(() => {
    if (isSmaregiEnabled && !defaultValues.seat_type_id) {
      setFormValues(prev => ({
        ...prev,
        price_per_unit: 0
      }));
    }
  }, [isSmaregiEnabled, defaultValues.seat_type_id]);

  // スマレジ連携が有効かどうかを確認
  useEffect(() => {
    const checkSmaregiEnabled = async () => {
      try {
        const response = await fetch('/api/stores/settings/smaregi-status');
        if (response.ok) {
          const data = await response.json();
          setIsSmaregiEnabled(data.enabled);
        }
      } catch (error) {
        console.error('スマレジ連携状態の取得に失敗しました:', error);
      }
    };

    checkSmaregiEnabled();
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;

    // 更新された値を取得
    let updatedValue;
    if (name === 'price_per_unit' || name === 'time_unit_minutes') {
      updatedValue = parseInt(value, 10) || 0;
    } else {
      updatedValue = value;
    }

    // フォーム値を更新
    setFormValues(prev => ({
      ...prev,
      [name]: updatedValue
    }));
  };

  // スマレジ商品を取得する関数
  const fetchSmaregiProducts = async () => {
    setIsLoadingProducts(true);
    try {
      const response = await fetch('/api/smaregi-products');
      if (response.ok) {
        const data = await response.json();
        setSmaregiProducts(data.products);
      } else {
        console.error('スマレジ商品の取得に失敗しました');
      }
    } catch (error) {
      console.error('スマレジ商品の取得中にエラーが発生しました:', error);
    } finally {
      setIsLoadingProducts(false);
    }
  };

  // スマレジ商品選択モーダルを開く
  const openSmaregiModal = () => {
    if (smaregiProducts.length === 0) {
      fetchSmaregiProducts();
    }
    setShowSmaregiModal(true);
  };

  // スマレジ商品を選択
  const selectSmaregiProduct = (product: SmaregiProduct) => {
    // 商品IDをそのまま保存
    setFormValues({
      ...formValues,
      smaregi_product_id: product.productId,
      price_per_unit: isSmaregiEnabled ? product.price : formValues.price_per_unit
    });
    setShowSmaregiModal(false);
  };

  // スマレジ商品の選択を解除
  const clearSmaregiProduct = () => {
    setFormValues({
      ...formValues,
      smaregi_product_id: '',
      price_per_unit: 0
    });
    setShowSmaregiModal(false);
  };

  // 検索条件に一致する商品をフィルタリング
  const filteredProducts = smaregiProducts.filter(product =>
    product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    product.productId.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      // バリデーション
      if (!formValues.display_name || formValues.price_per_unit < 0 || formValues.time_unit_minutes <= 0) {
        throw new Error('すべての項目を正しく入力してください');
      }

      // スマレジ連携が有効で商品IDが未入力の場合は警告を表示するが、保存は可能
      if (isSmaregiEnabled && !formValues.smaregi_product_id) {
        console.warn('スマレジ商品IDが未入力です。会計時にスマレジ連携ができない可能性があります。');
      }

      // APIエンドポイントの決定（店舗IDをクエリパラメータとして含める）
      const endpoint = defaultValues.seat_type_id
        ? `/api/seat-types/${defaultValues.seat_type_id}?storeId=${formValues.store_id}`
        : `/api/seat-types?storeId=${formValues.store_id}`;

      // デバッグ用にフォーム値をコンソールに出力
      console.log('送信するフォーム値:', formValues);

      // APIリクエスト
      const method = defaultValues.seat_type_id ? 'PATCH' : 'POST';
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formValues),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || '席種の保存に失敗しました');
      }

      // 成功したら一覧ページにリダイレクト
      router.push('/portal/seat-types');
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="bg-red-50 border-l-4 border-red-500 p-4 mb-4">
          <p className="text-red-700">{error}</p>
        </div>
      )}

      {/* コードはサーバー側で自動生成されるため、フィールドなし */}

      <div>
        <label htmlFor="display_name" className="block text-sm font-medium text-gray-700 mb-1">
          表示名
        </label>
        <input
          type="text"
          id="display_name"
          name="display_name"
          value={formValues.display_name}
          onChange={handleChange}
          className="w-full px-3 py-2 border border-gray-300 rounded-md"
          required
        />
        <p className="mt-1 text-sm text-gray-500">
          画面に表示される席種の名前（例: カウンター席, テーブル席, VIP席）
        </p>
      </div>

      <div>
        <label htmlFor="time_unit_minutes" className="block text-sm font-medium text-gray-700 mb-1">
          時間単位
        </label>
        <div className="flex items-center">
          <select
            id="time_unit_minutes"
            name="time_unit_minutes"
            value={formValues.time_unit_minutes}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
            required
          >
            <option value="10">10分</option>
            <option value="15">15分</option>
            <option value="20">20分</option>
            <option value="30">30分</option>
            <option value="60">60分（1時間）</option>
            <option value="90">90分（1.5時間）</option>
            <option value="120">120分（2時間）</option>
          </select>
        </div>
        <p className="mt-1 text-sm text-gray-500">
          料金計算の基本単位となる時間
        </p>
      </div>

      <div>
        <label htmlFor="price_per_unit" className="block text-sm font-medium text-gray-700 mb-1">
          料金（{formValues.time_unit_minutes}分あたり）
        </label>
        <div className="flex items-center">
          <input
            type="number"
            id="price_per_unit"
            name="price_per_unit"
            value={formValues.price_per_unit}
            onChange={handleChange}
            min="0"
            step="100"
            className={`w-full px-3 py-2 border ${isSmaregiEnabled ? 'bg-gray-100' : ''} border-gray-300 rounded-md`}
            required
            readOnly={isSmaregiEnabled}
            disabled={isSmaregiEnabled}
          />
          <span className="ml-2">円</span>
        </div>
        {isSmaregiEnabled && (
          <p className="mt-1 text-sm text-gray-500">
            スマレジ連携が有効な場合、料金は選択した商品の価格から自動設定されます
          </p>
        )}
      </div>

      {/* スマレジ連携が有効な場合のみ表示 */}
      {isSmaregiEnabled && (
        <div>
          <label htmlFor="smaregi_product_id" className="block text-sm font-medium text-gray-700 mb-1">
            スマレジ商品連携
          </label>
          <div className="flex items-center space-x-2">
            <input
              type="text"
              id="smaregi_product_id"
              name="smaregi_product_id"
              value={formValues.smaregi_product_id || ''}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md"
              placeholder="スマレジ商品ID"
              readOnly
            />
            <button
              type="button"
              onClick={openSmaregiModal}
              className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
            >
              商品選択
            </button>
            {formValues.smaregi_product_id && (
              <button
                type="button"
                onClick={() => {
                  setFormValues({
                    ...formValues,
                    smaregi_product_id: '',
                    price_per_unit: 0
                  });
                }}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
              >
                解除
              </button>
            )}
          </div>
          {formValues.smaregi_product_id ? (
            <div className="mt-2 p-2 bg-blue-50 border border-blue-200 rounded-md">
              <p className="text-sm text-blue-800">
                選択中の商品: <span className="font-semibold">{formValues.smaregi_product_id}</span>
              </p>
              <p className="text-sm text-blue-800">
                料金: <span className="font-semibold">{formValues.price_per_unit}円</span>
              </p>
            </div>
          ) : (
            <p className="mt-1 text-sm text-gray-500">
              会計時にスマレジに連携する商品を選択してください
            </p>
          )}
        </div>
      )}

      <div className="flex justify-end space-x-4">
        <button
          type="button"
          onClick={() => router.back()}
          className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          disabled={isSubmitting}
        >
          キャンセル
        </button>
        <button
          type="submit"
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-blue-300"
          disabled={isSubmitting}
        >
          {isSubmitting ? '保存中...' : defaultValues.seat_type_id ? '更新' : '作成'}
        </button>
      </div>

      {/* スマレジ商品選択モーダル */}
      {showSmaregiModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[80vh] overflow-y-auto">
            <h3 className="text-lg font-medium mb-4">スマレジ商品選択</h3>

            {/* 検索フォーム */}
            <div className="mb-4">
              <input
                type="text"
                placeholder="商品名または商品IDで検索"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md"
              />
            </div>

            {/* 商品リスト */}
            {isLoadingProducts ? (
              <div className="text-center py-4">
                <p>商品を読み込み中...</p>
              </div>
            ) : filteredProducts.length > 0 ? (
              <div className="border border-gray-200 rounded-md overflow-hidden">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">商品ID</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">商品名</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">価格</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {filteredProducts.map((product) => (
                      <tr key={product.productId}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {product.productId}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{product.name}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{product.price}円</td>
                        <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                          <button
                            type="button"
                            onClick={() => selectSmaregiProduct(product)}
                            className="text-blue-600 hover:text-blue-900"
                          >
                            選択
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            ) : (
              <div className="text-center py-4">
                <p>商品が見つかりません</p>
              </div>
            )}

            {/* モーダルフッター */}
            <div className="mt-6 flex justify-end space-x-2">
              <button
                type="button"
                onClick={clearSmaregiProduct}
                className="px-4 py-2 border border-red-300 rounded-md text-red-700 hover:bg-red-50"
              >
                選択解除
              </button>
              <button
                type="button"
                onClick={() => setShowSmaregiModal(false)}
                className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
              >
                閉じる
              </button>
            </div>
          </div>
        </div>
      )}
    </form>
  );
}
</file>

<file path="app/portal/seat-types/[id]/edit/page.tsx">
import { cookies } from 'next/headers';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import SeatTypeForm from '../../_components/seat-type-form';

export default async function EditSeatTypePage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  // UUIDとして処理（数値変換は不要）
  const seatTypeId = id;

  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIから席種情報を取得（店舗IDをクエリパラメータとして含める）
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/seat-types/${seatTypeId}?storeId=${storeId}`, {
    cache: 'no-store'
  });

  if (!response.ok) {
    console.error('席種情報の取得に失敗しました:', await response.text());
    notFound();
  }

  const seatType = await response.json();

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">席種編集: {seatType.display_name}</h1>
        <Link
          href="/portal/seat-types"
          className="bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600"
        >
          戻る
        </Link>
      </div>

      <div className="bg-white shadow-md rounded-lg p-6">
        <SeatTypeForm defaultValues={seatType} />
      </div>
    </div>
  );
}
</file>

<file path="app/portal/seat-types/new/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import Link from 'next/link';
import SeatTypeForm from '../_components/seat-type-form';

export default async function NewSeatTypePage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 新規作成用のデフォルト値
  const defaultValues = {
    display_name: '',
    price_per_unit: 0, // 時間単位あたりの料金
    time_unit_minutes: 30, // デフォルトは30分
    store_id: storeId
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">新規席種作成</h1>
        <Link
          href="/portal/seat-types"
          className="bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600"
        >
          戻る
        </Link>
      </div>

      <div className="bg-white shadow-md rounded-lg p-6">
        <SeatTypeForm defaultValues={defaultValues} />
      </div>
    </div>
  );
}
</file>

<file path="app/portal/seat-types/page.tsx">
import Link from 'next/link';
import { cookies } from 'next/headers';

// 席種の型定義
interface SeatType {
  seat_type_id: string; // UUIDなので文字列型
  display_name: string;
  price_per_unit: number; // 時間単位あたりの料金
  time_unit_minutes: number;
  store_id: string;
  created_at: string;
}

export default async function SeatTypesPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIから席種一覧を取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/seat-types?storeId=${storeId}`, {
    cache: 'no-store'
  });

  let seatTypes: SeatType[] = [];
  if (response.ok) {
    seatTypes = await response.json();
  } else {
    console.error('席種一覧の取得に失敗しました:', await response.text());
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">席種設定</h1>
        <Link
          href="/portal/seat-types/new"
          className="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
        >
          新規席種作成
        </Link>
      </div>

      <div className="bg-white shadow overflow-hidden sm:rounded-md">
        <ul className="divide-y divide-gray-200">
          {seatTypes && seatTypes.length > 0 ? (
            seatTypes.map((seatType) => (
              <li key={seatType.seat_type_id} className="px-6 py-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-lg font-medium text-gray-900">
                      {seatType.display_name}
                    </p>
                  </div>
                  <div className="text-right">
                    <p className="text-xl font-bold text-gray-900">
                      {seatType.price_per_unit}円/{seatType.time_unit_minutes || 30}分
                    </p>
                    <Link
                      href={`/portal/seat-types/${seatType.seat_type_id}/edit`}
                      className="text-blue-600 hover:text-blue-800 text-sm"
                    >
                      編集
                    </Link>
                  </div>
                </div>
              </li>
            ))
          ) : (
            <li className="px-6 py-4 text-center text-gray-500">
              席種がまだ登録されていません。「新規席種作成」から追加してください。
            </li>
          )}
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/tables/_components/charge-control-button.tsx">
'use client';

import { useState } from 'react';

interface ChargeControlButtonProps {
  tableId: string;
  sessionId: string;
  isPaused: boolean;
}

export default function ChargeControlButton({ tableId, sessionId, isPaused }: ChargeControlButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentPauseState, setCurrentPauseState] = useState(isPaused);

  const handleToggleCharge = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // 課金停止または再開のAPIを呼び出す
      const endpoint = currentPauseState
        ? `/api/tables/${tableId}/sessions/${sessionId}/resume`
        : `/api/tables/${tableId}/sessions/${sessionId}/pause`;

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || '処理に失敗しました');
      }

      // 状態を更新
      setCurrentPauseState(!currentPauseState);

      // ページをリロードして最新の状態を反映
      window.location.reload();
    } catch (err) {
      console.error('課金制御エラー:', err);
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <button
        onClick={handleToggleCharge}
        disabled={isLoading}
        className={`w-full py-1 px-3 rounded-md text-sm ${
          currentPauseState
            ? 'bg-green-600 hover:bg-green-700 text-white'
            : 'bg-yellow-500 hover:bg-yellow-600 text-white'
        } ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
      >
        {isLoading ? '処理中...' : currentPauseState ? '課金再開' : '課金一時停止'}
      </button>
      {error && <p className="text-xs text-red-500 mt-1">{error}</p>}
    </div>
  );
}
</file>

<file path="app/portal/tables/_components/table-form.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Database } from '@/lib/database.types';

type Table = Database['public']['Tables']['tables']['Row'];
type SeatType = Database['public']['Tables']['seat_types']['Row'];

// テーブルフォームで使用する入力値の型
type TableInput = {
  name: string;
  seat_type_id: string;
  store_id: string;
};

// フォームで使用する型（table_idを含む）
interface TableFormValues extends Partial<TableInput> {
  table_id?: string;
  seat_type?: {
    seat_type_id: string;
    display_name: string;
    price_per_unit: number;
  };
}

interface TableFormProps {
  defaultValues: TableFormValues;
  seatTypes?: SeatType[];
}

export default function TableForm({ defaultValues, seatTypes = [] }: TableFormProps) {
  const router = useRouter();
  // seat_type_idの初期値を取得（seat_typeオブジェクトから取得するか、直接指定された値を使用）
  const initialSeatTypeId = defaultValues.seat_type?.seat_type_id || defaultValues.seat_type_id || '';

  const [formValues, setFormValues] = useState<TableInput>({
    name: defaultValues.name || '',
    seat_type_id: initialSeatTypeId,
    store_id: defaultValues.store_id || '',
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [availableSeatTypes, setAvailableSeatTypes] = useState<SeatType[]>(seatTypes);

  // 席種一覧を取得
  const fetchSeatTypes = async () => {
    try {
      const response = await fetch(`/api/seat-types?storeId=${formValues.store_id}`);
      if (!response.ok) {
        throw new Error('席種一覧の取得に失敗しました');
      }
      const data = await response.json();
      setAvailableSeatTypes(data);
    } catch (error) {
      console.error('席種一覧取得エラー:', error);
      setError('席種一覧の取得に失敗しました');
    }
  };

  // コンポーネントマウント時に席種一覧を取得
  useEffect(() => {
    if (seatTypes.length === 0) {
      fetchSeatTypes();
    }
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormValues(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      // バリデーション
      if (!formValues.name || !formValues.seat_type_id) {
        throw new Error('すべての項目を入力してください');
      }

      // APIエンドポイントの決定（店舗IDをクエリパラメータとして含める）
      const endpoint = defaultValues.table_id
        ? `/api/tables/${defaultValues.table_id}?storeId=${formValues.store_id}`
        : `/api/tables?storeId=${formValues.store_id}`;

      // APIリクエスト
      const response = await fetch(endpoint, {
        method: defaultValues.table_id ? 'PATCH' : 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formValues),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'テーブルの保存に失敗しました');
      }

      // 成功時の処理
      router.push('/portal/tables');
      router.refresh();
    } catch (error) {
      console.error('テーブル保存エラー:', error);
      setError(error instanceof Error ? error.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-md mb-4">
          {error}
        </div>
      )}

      <div className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">
            テーブル名
          </label>
          <input
            type="text"
            id="name"
            name="name"
            value={formValues.name}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
            required
          />
        </div>

        <div>
          <label htmlFor="seat_type_id" className="block text-sm font-medium text-gray-700 mb-1">
            席種
          </label>
          <select
            id="seat_type_id"
            name="seat_type_id"
            value={formValues.seat_type_id}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
            required
          >
            <option value="">席種を選択してください</option>
            {availableSeatTypes.map((seatType) => (
              <option key={seatType.seat_type_id} value={seatType.seat_type_id}>
                {seatType.display_name} ({seatType.price_per_unit}円/{seatType.time_unit_minutes || 30}分)
              </option>
            ))}
          </select>
        </div>

        <div className="pt-4">
          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:bg-blue-300"
          >
            {isLoading ? '保存中...' : defaultValues.table_id ? '更新する' : '作成する'}
          </button>
        </div>
      </div>
    </form>
  );
}
</file>

<file path="app/portal/tables/_components/table-move-button.tsx">
'use client';

import { useState } from 'react';
import { Database } from '@/lib/database.types';

// テーブルの型定義（実際のデータ構造に合わせて調整）
interface Table {
  table_id: string;
  name: string;
  seat_types?: {
    display_name: string;
    price_per_unit: number;
  } | null;
}

interface TableMoveButtonProps {
  tableId: string;
  tableName: string;
  sessionId: string;
  availableTables: Table[];
}

export default function TableMoveButton({
  tableId,
  tableName,
  sessionId,
  availableTables
}: TableMoveButtonProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  // 移動先テーブル候補（現在のテーブルを除外）
  const targetTables = availableTables.filter(table => table.table_id !== tableId);

  const handleMoveTable = async (targetTableId: string) => {
    try {
      setIsLoading(true);
      setError(null);
      setSuccess(null);

      const response = await fetch(`/api/sessions/${sessionId}/move`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          target_table_id: targetTableId,
        }),
      });

      const result = await response.json();
      console.log('席移動API応答:', result);

      if (!response.ok) {
        throw new Error(result.error || '席移動に失敗しました');
      }

      const previousCharge = result.previous_charge || 0;

      // 移動前の料金がある場合は、その情報も表示
      if (previousCharge > 0) {
        setSuccess(`席移動が完了しました。移動前の料金 ${previousCharge.toLocaleString()}円 は会計時に加算されます。`);
      } else {
        setSuccess('席移動が完了しました');
      }

      // 3秒後にページをリロード
      setTimeout(() => {
        window.location.reload();
      }, 3000);
    } catch (err) {
      console.error('席移動エラー:', err);
      setError(err instanceof Error ? err.message : '予期せぬエラーが発生しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      <button
        onClick={() => setIsModalOpen(true)}
        className="bg-indigo-600 text-white py-1 px-3 rounded-md text-sm hover:bg-indigo-700"
      >
        席移動
      </button>

      {/* 席移動モーダル */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full max-h-[80vh] overflow-y-auto">
            <h3 className="text-lg font-medium mb-4">席移動</h3>
            <p className="mb-4 text-sm text-gray-600">
              「{tableName}」から移動先のテーブルを選択してください。
            </p>

            {error && (
              <div className="mb-4 p-2 bg-red-100 text-red-700 rounded-md text-sm">
                {error}
              </div>
            )}

            {success && (
              <div className="mb-4 p-2 bg-green-100 text-green-700 rounded-md text-sm">
                {success}
              </div>
            )}

            {targetTables.length === 0 ? (
              <p className="text-gray-500 italic">移動先のテーブルがありません</p>
            ) : (
              <div className="grid grid-cols-1 gap-2 mb-4">
                {targetTables.map((table) => (
                  <button
                    key={table.table_id}
                    onClick={() => handleMoveTable(table.table_id)}
                    disabled={isLoading}
                    className="flex justify-between items-center p-3 border rounded-md hover:bg-gray-50 disabled:opacity-50"
                  >
                    <span className="font-medium">{table.name}</span>
                    <span className="text-sm text-gray-500">
                      {table.seat_types?.display_name || '不明な席種'}
                    </span>
                  </button>
                ))}
              </div>
            )}

            <div className="flex justify-end">
              <button
                onClick={() => setIsModalOpen(false)}
                disabled={isLoading}
                className="bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600 disabled:opacity-50"
              >
                キャンセル
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
</file>

<file path="app/portal/tables/[table_id]/edit/page.tsx">
import { cookies } from 'next/headers';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import TableForm from '../../_components/table-form';

export default async function EditTablePage({ params }: { params: Promise<{ table_id: string }> }) {
  const { table_id } = await params;

  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIからテーブル情報を取得（店舗IDをクエリパラメータとして含める）
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/tables/${table_id}?storeId=${storeId}`, {
    cache: 'no-store'
  });

  if (!response.ok) {
    console.error('テーブル情報の取得に失敗しました:', await response.text());
    notFound();
  }

  const table = await response.json();

  // APIから席種一覧を取得
  const seatTypesResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/seat-types?storeId=${storeId}`, {
    cache: 'no-store'
  });

  let seatTypes = [];
  if (seatTypesResponse.ok) {
    seatTypes = await seatTypesResponse.json();
  } else {
    console.error('席種一覧の取得に失敗しました:', await seatTypesResponse.text());
  }

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">テーブル編集: {table.name}</h1>
        <Link
          href="/portal/tables"
          className="bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600"
        >
          戻る
        </Link>
      </div>

      <div className="bg-white shadow-md rounded-lg p-6">
        <TableForm defaultValues={table} seatTypes={seatTypes} />
      </div>
    </div>
  );
}
</file>

<file path="app/portal/tables/new/page.tsx">
import { cookies } from 'next/headers';
import Link from 'next/link';
import TableForm from '../_components/table-form';

export default async function NewTablePage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIから席種一覧を取得
  const seatTypesResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/seat-types?storeId=${storeId}`, {
    cache: 'no-store'
  });
  
  let seatTypes = [];
  if (seatTypesResponse.ok) {
    seatTypes = await seatTypesResponse.json();
  } else {
    console.error('席種一覧の取得に失敗しました:', await seatTypesResponse.text());
  }

  // 新規作成用のデフォルト値
  const defaultValues = {
    name: '',
    store_id: storeId
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">新規テーブル作成</h1>
        <Link
          href="/portal/tables"
          className="bg-gray-500 text-white py-2 px-4 rounded-md hover:bg-gray-600"
        >
          戻る
        </Link>
      </div>

      <div className="bg-white shadow-md rounded-lg p-6">
        <TableForm defaultValues={defaultValues} seatTypes={seatTypes} />
      </div>
    </div>
  );
}
</file>

<file path="app/portal/tables/page.tsx">
import { cookies } from 'next/headers';
import QRCode from 'qrcode';
import TablesClient from './tables-client';

// テーブルの型定義
interface SeatType {
  seat_type_id: number;
  display_name: string;
  price_per_unit: number;
  time_unit_minutes?: number;
}

interface Table {
  table_id: string;
  name: string;
  seat_types: SeatType | null;
}

interface Session {
  session_id: string;
  table_id: string;
  start_at: string;
  charge_started_at: string;
  charge_paused_at: string | null;
}

interface ElapsedTime {
  hours: number;
  minutes: number;
  totalMinutes: number;
}

interface TableWithDetails extends Table {
  qrCode: string;
  session?: Session;
  elapsedTime?: ElapsedTime;
  formattedStartTime?: string;
  isPaused: boolean;
}

// QRコード生成関数
async function generateQRCode(tableId: string): Promise<string> {
  const url = `${process.env.PUBLIC_URL || 'http://localhost:3000'}/menu/${tableId}`;
  return await QRCode.toDataURL(url);
}

export default async function TablesPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // APIからテーブル一覧を取得
  const tablesResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/tables?storeId=${storeId}`, {
    cache: 'no-store'
  });

  let tables: Table[] = [];
  if (tablesResponse.ok) {
    tables = await tablesResponse.json();
  } else {
    console.error('テーブル一覧の取得に失敗しました:', await tablesResponse.text());
  }

  // APIからアクティブなセッション情報を取得
  const sessionsResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/sessions/active?storeId=${storeId}`, {
    cache: 'no-store'
  });

  let sessions: Session[] = [];
  if (sessionsResponse.ok) {
    sessions = await sessionsResponse.json();
  } else {
    const sessionsError = await sessionsResponse.text();
    console.error('セッション情報の取得に失敗しました:', sessionsError);
  }

  // テーブルIDとセッション情報のマッピングを作成
  const sessionMap = new Map();
  if (sessions && sessions.length > 0) {
    sessions.forEach(session => {
      // テーブルIDを文字列に変換して保存（型の不一致を防ぐため）
      const tableIdStr = String(session.table_id);

      // 同じテーブルIDのセッションが既に存在する場合は、最新のものだけを保持
      if (!sessionMap.has(tableIdStr)) {
        sessionMap.set(tableIdStr, session);
      }
    });
  }

  // 各テーブルのQRコードを生成し、セッション情報を追加
  const tablesWithQR: TableWithDetails[] = await Promise.all(
    (tables || []).map(async (table) => {
      const qrCode = await generateQRCode(table.table_id);
      // テーブルIDを文字列に変換して検索（型の不一致を防ぐため）
      const tableIdStr = String(table.table_id);
      const session = sessionMap.get(tableIdStr);

      // 経過時間の計算
      let elapsedTime: ElapsedTime | undefined = undefined;
      let formattedStartTime: string | undefined = undefined;
      let isPaused = false;

      if (session && session.charge_started_at) {
        const startTime = new Date(session.charge_started_at);
        const now = new Date();

        // 一時停止中かどうかを確認
        isPaused = !!session.charge_paused_at;

        // 一時停止中の場合は、一時停止時間までの経過時間を計算
        const endTime = isPaused ? new Date(session.charge_paused_at) : now;

        const elapsedMinutes = Math.floor((endTime.getTime() - startTime.getTime()) / (1000 * 60));
        const hours = Math.floor(elapsedMinutes / 60);
        const minutes = elapsedMinutes % 60;

        elapsedTime = {
          hours,
          minutes,
          totalMinutes: elapsedMinutes
        };

        // 着席時間のフォーマット
        formattedStartTime = startTime.toLocaleString('ja-JP', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      return {
        ...table,
        qrCode,
        session,
        elapsedTime,
        formattedStartTime,
        isPaused
      };
    })
  );

  // クライアントコンポーネントに初期データとストアIDを渡す
  return <TablesClient initialTables={tablesWithQR} storeId={storeId} />;
}
</file>

<file path="app/portal/tables/tables-client.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { subscribeToSessions, subscribeToTables } from '@/lib/supabase-realtime';
import ChargeControlButton from './_components/charge-control-button';
import TableMoveButton from './_components/table-move-button';

// テーブルの型定義
interface SeatType {
  seat_type_id: number;
  display_name: string;
  price_per_unit: number;
  time_unit_minutes?: number;
}

interface Table {
  table_id: string;
  name: string;
  seat_types: SeatType | null;
  qrCode: string;
}

interface Session {
  session_id: string;
  table_id: string;
  start_at: string;
  charge_started_at: string;
  charge_paused_at: string | null;
}

interface ElapsedTime {
  hours: number;
  minutes: number;
  totalMinutes: number;
}

interface TableWithDetails extends Table {
  session?: Session;
  elapsedTime?: ElapsedTime;
  formattedStartTime?: string;
  isPaused: boolean;
}

interface TablesClientProps {
  initialTables: TableWithDetails[];
  storeId: string;
}

export default function TablesClient({ initialTables, storeId }: TablesClientProps) {
  const [tables, setTables] = useState<TableWithDetails[]>(initialTables);
  const [now, setNow] = useState(new Date());

  // 現在時刻を1秒ごとに更新
  useEffect(() => {
    const timer = setInterval(() => {
      setNow(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // リアルタイム更新のセットアップ
  useEffect(() => {
    if (!storeId) return;

    // 最新のテーブルとセッションデータを取得する関数
    const fetchLatestData = async () => {
      try {
        // テーブル一覧を取得
        const tablesResponse = await fetch(`/api/tables?storeId=${storeId}`);
        let updatedTables: Table[] = [];
        if (tablesResponse.ok) {
          updatedTables = await tablesResponse.json();
        } else {
          console.error('テーブル一覧の取得に失敗しました:', await tablesResponse.text());
          return;
        }

        // アクティブなセッション情報を取得
        const sessionsResponse = await fetch(`/api/sessions/active?storeId=${storeId}`);
        let sessions: Session[] = [];
        if (sessionsResponse.ok) {
          sessions = await sessionsResponse.json();
        } else {
          console.error('セッション情報の取得に失敗しました:', await sessionsResponse.text());
          return;
        }

        // テーブルIDとセッション情報のマッピングを作成
        const sessionMap = new Map<string, Session>();
        if (sessions && sessions.length > 0) {
          sessions.forEach(session => {
            const tableIdStr = String(session.table_id);
            if (!sessionMap.has(tableIdStr)) {
              sessionMap.set(tableIdStr, session);
            }
          });
        }

        // 既存のQRコードを保持しつつ、新しいデータで更新
        const updatedTablesWithDetails = updatedTables.map(table => {
          // 既存のテーブル情報を検索
          const existingTable = tables.find(t => t.table_id === table.table_id);
          const qrCode = existingTable?.qrCode || '';

          // セッション情報を取得
          const tableIdStr = String(table.table_id);
          const session = sessionMap.get(tableIdStr);

          // 経過時間の計算
          let elapsedTime = null;
          let formattedStartTime = null;
          let isPaused = false;

          if (session && session.charge_started_at) {
            const startTime = new Date(session.charge_started_at);
            
            // 一時停止中かどうかを確認
            isPaused = !!session.charge_paused_at;

            // 一時停止中の場合は、一時停止時間までの経過時間を計算
            const endTime = isPaused && session.charge_paused_at ? new Date(session.charge_paused_at) : now;

            const elapsedMinutes = Math.floor((endTime.getTime() - startTime.getTime()) / (1000 * 60));
            const hours = Math.floor(elapsedMinutes / 60);
            const minutes = elapsedMinutes % 60;

            elapsedTime = {
              hours,
              minutes,
              totalMinutes: elapsedMinutes
            };

            // 着席時間のフォーマット
            formattedStartTime = startTime.toLocaleString('ja-JP', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            });
          }

          return {
            ...table,
            qrCode,
            session,
            elapsedTime,
            formattedStartTime,
            isPaused
          };
        });

        setTables(updatedTablesWithDetails);
      } catch (error) {
        console.error('データ取得エラー:', error);
      }
    };

    // Supabaseリアルタイムサブスクリプションのセットアップ
    console.log('Supabaseリアルタイムサブスクリプションを設定中...');
    
    // テーブルテーブルのサブスクリプション
    const unsubscribeTables = subscribeToTables(storeId, (payload) => {
      console.log('テーブルテーブル更新イベント:', payload);
      fetchLatestData();
    });
    
    // セッションテーブルのサブスクリプション
    const unsubscribeSessions = subscribeToSessions(storeId, (payload) => {
      console.log('セッションテーブル更新イベント:', payload);
      fetchLatestData();
    });

    // 初回データ取得
    fetchLatestData();

    // 定期的なポーリングの設定（30秒ごと）- バックアップとして
    const pollingInterval = setInterval(fetchLatestData, 30000);

    // 画面がフォーカスされたときにも更新
    const handleFocus = () => {
      console.log('画面がフォーカスされました。データを更新します。');
      fetchLatestData();
    };
    window.addEventListener('focus', handleFocus);

    return () => {
      unsubscribeTables();
      unsubscribeSessions();
      clearInterval(pollingInterval);
      window.removeEventListener('focus', handleFocus);
    };
  }, [storeId, tables]);

  // 経過時間を更新
  useEffect(() => {
    // 現在時刻が変わるたびに経過時間を再計算
    const updatedTables = tables.map(table => {
      if (table.session && table.session.charge_started_at) {
        const startTime = new Date(table.session.charge_started_at);
        
        // 一時停止中かどうかを確認
        const isPaused = !!table.session.charge_paused_at;

        // 一時停止中の場合は、一時停止時間までの経過時間を計算
        const endTime = isPaused && table.session.charge_paused_at ? new Date(table.session.charge_paused_at) : now;

        const elapsedMinutes = Math.floor((endTime.getTime() - startTime.getTime()) / (1000 * 60));
        const hours = Math.floor(elapsedMinutes / 60);
        const minutes = elapsedMinutes % 60;

        return {
          ...table,
          elapsedTime: {
            hours,
            minutes,
            totalMinutes: elapsedMinutes
          }
        };
      }
      return table;
    });

    setTables(updatedTables);
  }, [now]);

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">テーブル管理</h1>
        <Link
          href="/portal/tables/new"
          className="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
        >
          新規テーブル作成
        </Link>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {tables.map((table) => (
          <div key={table.table_id} className="bg-white shadow rounded-lg overflow-hidden">
            <div className="p-6">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold">{table.name}</h2>
                <span className="px-3 py-1 bg-gray-100 text-gray-800 rounded-full text-sm">
                  {table.seat_types?.display_name || ''}
                </span>
              </div>

              <div className="mb-4 flex justify-center">
                <img
                  src={table.qrCode}
                  alt={`QR Code for ${table.name}`}
                  className="w-48 h-48"
                />
              </div>

              <div className="text-center mb-4">
                <p className="text-sm text-gray-500">
                  {table.seat_types?.price_per_unit || 0}円/
                  {table.seat_types?.time_unit_minutes || 30}分
                </p>
              </div>

              {/* 着席情報と経過時間 */}
              <div className="border-t border-gray-200 pt-4 mb-4">
                <h3 className="text-sm font-medium text-gray-700 mb-2">着席状況</h3>
                {table.elapsedTime ? (
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-xs text-gray-500">着席時間:</span>
                      <span className="text-xs font-medium">{table.formattedStartTime}</span>
                    </div>
                    <div className="flex justify-between mb-1">
                      <span className="text-xs text-gray-500">経過時間:</span>
                      <span className={`text-xs font-medium ${table.isPaused ? 'text-orange-600' : 'text-red-600'}`}>
                        {table.elapsedTime.hours}時間{table.elapsedTime.minutes}分
                        {table.isPaused && <span className="ml-1">(停止中)</span>}
                      </span>
                    </div>

                    {/* 課金停止/再開ボタン */}
                    {table.session && (
                      <div className="mt-2">
                        <ChargeControlButton
                          tableId={table.table_id}
                          sessionId={table.session.session_id}
                          isPaused={table.isPaused}
                        />
                      </div>
                    )}

                    {/* 席移動ボタン */}
                    {table.session && (
                      <div className="mt-2">
                        <TableMoveButton
                          tableId={table.table_id}
                          tableName={table.name}
                          sessionId={table.session.session_id}
                          availableTables={tables.map(t => ({
                            table_id: t.table_id,
                            name: t.name,
                            seat_types: t.seat_types
                          }))}
                        />
                      </div>
                    )}
                  </div>
                ) : (
                  <p className="text-xs text-gray-500 text-center italic">未着席</p>
                )}
              </div>

              <div className="flex justify-between">
                <a
                  href={table.qrCode}
                  download={`table-${table.name}-qr.png`}
                  className="bg-green-600 text-white py-1 px-3 rounded-md text-sm hover:bg-green-700"
                >
                  QRダウンロード
                </a>
                <Link
                  href={`/portal/tables/${table.table_id}/edit`}
                  className="bg-gray-600 text-white py-1 px-3 rounded-md text-sm hover:bg-gray-700"
                >
                  編集
                </Link>
              </div>
            </div>
          </div>
        ))}
      </div>

      {tables.length === 0 && (
        <div className="bg-white shadow rounded-lg p-6 text-center text-gray-500">
          テーブルがまだ登録されていません。「新規テーブル作成」から追加してください。
        </div>
      )}
    </div>
  );
}
</file>

<file path="docs/migration-guide.md">
# マイグレーションガイド

このガイドでは、Supabaseのマイグレーションを実行する方法について説明します。

## 前提条件

- Node.js がインストールされていること
- Supabase CLI がインストールされていること
- プロジェクトのルートディレクトリに `.env.local` ファイルが存在し、以下の環境変数が設定されていること:
  - `SUPABASE_URL`
  - `SUPABASE_ANON_KEY`

## マイグレーションの実行方法

### 1. package.jsonにスクリプトを追加

以下のコマンドを実行して、package.jsonにマイグレーション用のスクリプトを追加します。

```bash
npm pkg set scripts.migrate="node scripts/run-migration.js"
```

または、package.jsonファイルを手動で編集して、以下のスクリプトを追加します:

```json
{
  "scripts": {
    "migrate": "node scripts/run-migration.js"
  }
}
```

### 2. 依存パッケージのインストール

マイグレーションスクリプトで使用する依存パッケージをインストールします。

```bash
npm install dotenv --save-dev
```

### 3. マイグレーションの実行

以下のコマンドを実行して、マイグレーションを実行します。

```bash
# 新しいマイグレーションのみを適用
npm run migrate

# デバッグ情報を表示
npm run migrate -- --debug

# データベースをリセットして全てのマイグレーションを適用
npm run migrate -- --reset

# 特定のマイグレーションファイルのみを適用
npm run migrate -- --file=20250703000004_fix_sessions_foreign_key.sql
```

## マイグレーションファイルについて

マイグレーションファイルは `supabase/migrations` ディレクトリに配置されています。ファイル名は `YYYYMMDD000000_description.sql` の形式で、実行順序はファイル名の昇順で決まります。

### 今回のマイグレーション内容

依存関係の問題を回避するため、より直接的なアプローチを採用しました：

#### `20250703000003_recreate_seat_types_table.sql`

このマイグレーションでは、以下の手順で席種テーブルとその関連テーブルを再作成します：

1. 既存のデータを一時テーブルに保存
2. 依存するすべてのビューとマテリアライズドビューを削除
3. 関連テーブル（`tables`、`session_seat_events`）のデータをバックアップ
4. 関連テーブルを削除（依存関係を解消）
5. 関連テーブルを再作成（`seat_type_id`をUUID型に変更）
6. 席種テーブルを再作成（`code`を`seat_type_id`に名前変更し、主キーに設定）
7. すべてのテーブルにデータを復元
8. 外部キー制約とRLSポリシーを再作成

#### `20250703000004_fix_sessions_foreign_key.sql`

このマイグレーションでは、以下の修正を行います：

1. `sessions`テーブルの`table_id`の外部キー制約を再作成
2. 関連するトリガー関数を更新
3. テーブル更新時のトリガーを再作成

これにより、`sessions`テーブルと`tables`テーブルの間の関係が正しく設定され、アプリケーションが正常に動作するようになります。

この変更により、席種テーブルの主キーがUUID型になり、より柔軟なデータ管理が可能になります。また、席種IDはUUIDで自動生成されるようになります。

## 注意事項

- マイグレーションを実行すると、既存のデータベースがリセットされる可能性があります。本番環境で実行する前に、必ずバックアップを取ってください。
- マイグレーションファイルは一度実行すると変更できません。新しい変更を加える場合は、新しいマイグレーションファイルを作成してください。
</file>

<file path="fix_next_event_after_move_null.sql">
-- テーブル移動後のイベントが存在しない場合のエラーを修正（より堅牢な実装）
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record := NULL; -- 明示的にNULLで初期化
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
  v_has_next_event boolean := false; -- 次のイベントが存在するかのフラグ
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、一時停止時間を現在時刻として扱う
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 席移動後の最初のイベントを取得する前に、そのようなイベントが存在するか確認
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後のイベントが存在するか確認
    SELECT EXISTS (
      SELECT 1
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
    ) INTO v_has_next_event;
    
    -- 席移動後のイベントが存在する場合のみ取得
    IF v_has_next_event THEN
      SELECT 
        event_id,
        seat_type_id,
        price_snapshot,
        changed_at,
        is_table_move_charge
      INTO v_next_event_after_move
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
      ORDER BY changed_at ASC
      LIMIT 1;
    END IF;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  -- v_next_event_after_moveがNULLでないことを確認
  IF v_has_move_charge AND v_has_next_event AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;
</file>

<file path="fix_next_event_after_move_property_access.sql">
-- テーブル移動後のイベントのプロパティアクセスエラーを修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record := NULL; -- 明示的にNULLで初期化
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
  v_has_next_event boolean := false; -- 次のイベントが存在するかのフラグ
  v_next_event_changed_at timestamptz := NULL; -- 次のイベントの時間を別変数で保持
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、一時停止時間を現在時刻として扱う
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 席移動後の最初のイベントを取得する前に、そのようなイベントが存在するか確認
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後のイベントが存在するか確認
    SELECT EXISTS (
      SELECT 1
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
    ) INTO v_has_next_event;
    
    -- 席移動後のイベントが存在する場合のみ取得
    IF v_has_next_event THEN
      SELECT 
        event_id,
        seat_type_id,
        price_snapshot,
        changed_at,
        is_table_move_charge
      INTO v_next_event_after_move
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
      ORDER BY changed_at ASC
      LIMIT 1;
      
      -- 次のイベントの時間を別変数に保存（NULLチェックを避けるため）
      IF v_next_event_after_move IS NOT NULL THEN
        v_next_event_changed_at := v_next_event_after_move.changed_at;
      END IF;
    END IF;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  -- v_next_event_after_moveのプロパティにアクセスする前にNULLチェックを行う
  -- v_next_event_changed_atを使用して比較
  IF v_has_move_charge AND v_has_next_event AND v_next_event_after_move IS NOT NULL AND 
     v_next_event_changed_at IS NOT NULL AND v_last_event_time = v_next_event_changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;
</file>

<file path="lib/auth.ts">
import { createServerSupabaseClient, createServerComponentClient } from './supabase';

export type UserRole = 'admin' | 'cast';

export interface StoreUser {
  id: string;
  store_id: string;
  user_id: string;
  role: UserRole;
}

export interface Store {
  store_id: string;
  store_code: string;
  name: string;
}

// ユーザーが特定の店舗に所属しているか確認
export async function isUserMemberOfStore(userId: string, storeId: string): Promise<boolean> {
  const supabase = await createServerSupabaseClient();

  console.log('isUserMemberOfStore called with:', { userId, storeId });

  const { data, error } = await supabase
    .from('store_users')
    .select('id')
    .eq('user_id', userId)
    .eq('store_id', storeId)
    .single();

  if (error) {
    console.error('Error checking store membership:', error);
    console.error('Error details:', error);

    // 全てのstore_usersを取得して確認
    const { data: allStoreUsers, error: allError } = await supabase
      .from('store_users')
      .select('*');

    if (!allError) {
      console.log('All store_users:', allStoreUsers);
    } else {
      console.error('Error fetching all store_users:', allError);
    }

    return false;
  }

  console.log('Store membership data:', data);
  return !!data;
}

// ユーザーの店舗での役割を取得
export async function getUserRoleInStore(userId: string, storeId: string): Promise<UserRole | null> {
  const supabase = await createServerSupabaseClient();

  const { data, error } = await supabase
    .from('store_users')
    .select('role')
    .eq('user_id', userId)
    .eq('store_id', storeId)
    .single();

  if (error || !data) {
    console.error('Error getting user role:', error);
    return null;
  }

  return data.role as UserRole;
}

// 店舗コードから店舗情報を取得
export async function getStoreByCode(storeCode: string): Promise<Store | null> {
  const supabase = await createServerSupabaseClient();

  const { data, error } = await supabase
    .from('stores')
    .select('*')
    .eq('store_code', storeCode)
    .single();

  if (error || !data) {
    console.error('Error getting store by code:', error);
    return null;
  }

  return data as Store;
}
</file>

<file path="lib/charge.ts">
/**
 * 経過時間を指定された時間単位で切り上げる関数
 * @param minutes 経過時間（分）
 * @param timeUnitMinutes 時間単位（分）（デフォルトは30分）
 * @returns 指定された時間単位で切り上げた時間（分）
 */
export function roundUpToTimeUnit(minutes: number, timeUnitMinutes: number = 30): number {
  // 時間単位が無効な場合はデフォルトの30分を使用
  const validTimeUnit = timeUnitMinutes > 0 ? timeUnitMinutes : 30;

  // 1分未満の場合は時間単位として扱う（最低料金）
  // 0分だけでなく、数十秒など1分未満の場合も最低料金を適用
  if (minutes < 1) return validTimeUnit;

  return Math.ceil(minutes / validTimeUnit) * validTimeUnit;
}

/**
 * 2つの日時の間の経過時間を分単位で計算する
 * @param startTime 開始時間
 * @param endTime 終了時間
 * @param pauseTime 一時停止時間（オプション）
 * @returns 経過時間（分）
 */
export function calculateElapsedMinutes(
  startTime: Date,
  endTime: Date,
  pauseTime?: Date | null
): number {
  // 日時が無効な場合は0を返す
  if (!startTime || !endTime || isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
    return 0;
  }

  // 一時停止中の場合
  if (pauseTime && !isNaN(pauseTime.getTime())) {
    // 一時停止時間が開始時間より前の場合は0を返す
    if (pauseTime.getTime() <= startTime.getTime()) {
      return 0;
    }

    // 一時停止時間が終了時間より後の場合は通常計算
    if (pauseTime.getTime() >= endTime.getTime()) {
      const diffMs = endTime.getTime() - startTime.getTime();
      return diffMs < 0 ? 0 : Math.floor(diffMs / (1000 * 60));
    }

    // 一時停止時間が開始時間と終了時間の間にある場合
    const diffMs = pauseTime.getTime() - startTime.getTime();
    return diffMs < 0 ? 0 : Math.floor(diffMs / (1000 * 60));
  }

  // 通常の計算
  const diffMs = endTime.getTime() - startTime.getTime();

  // 負の値になる場合は0を返す（異常値）
  if (diffMs < 0) {
    return 0;
  }

  return Math.floor(diffMs / (1000 * 60));
}

/**
 * 経過時間と単価から料金を計算する
 * @param elapsedMinutes 経過時間（分）
 * @param pricePerUnit 時間単位あたりの単価（デフォルトは30分単位）
 * @param timeUnitMinutes 時間単位（分）（デフォルトは30分）
 * @returns 計算された料金
 */
export function calculateCharge(
  elapsedMinutes: number,
  pricePerUnit: number,
  timeUnitMinutes: number = 30
): number {
  // 単価が無効な場合は0を返す
  if (!pricePerUnit || pricePerUnit < 0) {
    return 0;
  }

  // 時間単位が無効な場合はデフォルトの30分を使用
  const validTimeUnit = timeUnitMinutes > 0 ? timeUnitMinutes : 30;

  // 時間単位で切り上げ（roundUpToTimeUnit関数を使用）
  const roundedMinutes = roundUpToTimeUnit(elapsedMinutes, validTimeUnit);

  // 時間単位の数を計算
  const units = roundedMinutes / validTimeUnit;

  // 料金を計算
  return units * pricePerUnit;
}

/**
 * 開始時間、終了時間、一時停止時間から料金を計算する
 * @param startTime 開始時間
 * @param endTime 終了時間
 * @param pricePerUnit 時間単位あたりの単価
 * @param timeUnitMinutes 時間単位（分）
 * @param pauseTime 一時停止時間（オプション）
 * @returns 計算された料金
 */
export function calculateChargeWithPause(
  startTime: Date,
  endTime: Date,
  pricePerUnit: number,
  timeUnitMinutes: number = 30,
  pauseTime?: Date | null
): number {
  // 経過時間を計算（一時停止を考慮）
  const elapsedMinutes = calculateElapsedMinutes(startTime, endTime, pauseTime);

  // 料金を計算
  return calculateCharge(elapsedMinutes, pricePerUnit, timeUnitMinutes);
}
</file>

<file path="lib/database.types.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      stores: {
        Row: {
          store_id: string
          store_code: string
          name: string
        }
        Insert: {
          store_id?: string
          store_code: string
          name: string
        }
        Update: {
          store_id?: string
          store_code?: string
          name?: string
        }
      }
      store_users: {
        Row: {
          id: string
          store_id: string
          user_id: string
          role: string
        }
        Insert: {
          id?: string
          store_id: string
          user_id: string
          role: string
        }
        Update: {
          id?: string
          store_id?: string
          user_id?: string
          role?: string
        }
      }
      seat_types: {
        Row: {
          seat_type_id: string  // UUIDだがTypeScriptでは文字列として扱う
          store_id: string
          display_name: string
          price_per_unit: number  // 時間単位あたりの料金
          time_unit_minutes: number
        }
        Insert: {
          seat_type_id?: string  // 自動生成されるため省略可能
          store_id: string
          display_name: string
          price_per_unit: number  // 時間単位あたりの料金
          time_unit_minutes?: number
        }
        Update: {
          seat_type_id?: string
          store_id?: string
          display_name?: string
          price_per_unit?: number  // 時間単位あたりの料金
          time_unit_minutes?: number
        }
      }
      tables: {
        Row: {
          table_id: string
          store_id: string
          name: string
          seat_type_id: string
        }
        Insert: {
          table_id?: string
          store_id: string
          name: string
          seat_type_id: string
        }
        Update: {
          table_id?: string
          store_id?: string
          name?: string
          seat_type_id?: string
        }
      }
      sessions: {
        Row: {
          session_id: string
          store_id: string
          table_id: string
          start_at: string
          charge_started_at: string | null
        }
        Insert: {
          session_id?: string
          store_id: string
          table_id: string
          start_at?: string
          charge_started_at?: string | null
        }
        Update: {
          session_id?: string
          store_id?: string
          table_id?: string
          start_at?: string
          charge_started_at?: string | null
        }
      }
      session_seat_events: {
        Row: {
          event_id: string
          session_id: string
          seat_type_id: string
          price_snapshot: number
          changed_at: string
        }
        Insert: {
          event_id?: string
          session_id: string
          seat_type_id: string
          price_snapshot: number
          changed_at?: string
        }
        Update: {
          event_id?: string
          session_id?: string
          seat_type_id?: string
          price_snapshot?: number
          changed_at?: string
        }
      }
      orders: {
        Row: {
          order_id: string
          store_id: string
          session_id: string
          status: string
          created_by_role: string | null
          proxy: boolean
          created_at: string
        }
        Insert: {
          order_id?: string
          store_id: string
          session_id: string
          status: string
          created_by_role?: string | null
          proxy?: boolean
          created_at?: string
        }
        Update: {
          order_id?: string
          store_id?: string
          session_id?: string
          status?: string
          created_by_role?: string | null
          proxy?: boolean
          created_at?: string
        }
      }
    }
  }
}
</file>

<file path="lib/smaregi.ts">
import axios from 'axios';

/**
 * スマレジAPIのアクセストークンを取得する
 * @param clientId クライアントID
 * @param clientSecret クライアントシークレット
 * @param contractId 契約ID
 * @param scope APIスコープ（デフォルト: 'pos.products:read pos.transactions:write'）
 * @param isSandbox サンドボックス環境かどうか
 * @returns アクセストークン
 */
export async function getSmaregiAccessToken(
  clientId: string,
  clientSecret: string,
  contractId: string,
  scope: string = 'pos.products:read pos.transactions:write',
  isSandbox: boolean = true
): Promise<string> {
  const baseUrl = isSandbox ? 'https://id.smaregi.dev' : 'https://id.smaregi.jp';
  const url = `${baseUrl}/app/${contractId}/token`;

  const auth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');

  try {
    const response = await axios.post(
      url,
      new URLSearchParams({
        grant_type: 'client_credentials',
        scope: scope,
      }).toString(),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': `Basic ${auth}`,
        },
      }
    );

    return response.data.access_token;
  } catch (error) {
    console.error('スマレジアクセストークン取得エラー:', error);
    throw new Error('スマレジアクセストークンの取得に失敗しました');
  }
}

/**
 * スマレジAPIから商品情報を取得する（ページネーション対応）
 * @param accessToken アクセストークン
 * @param contractId 契約ID
 * @param isSandbox サンドボックス環境かどうか
 * @returns 商品情報の配列
 */
export async function fetchSmaregiProducts(
  accessToken: string,
  contractId: string,
  isSandbox: boolean = true
): Promise<any[]> {
  const baseUrl = isSandbox ? 'https://api.smaregi.dev' : 'https://api.smaregi.jp';
  const url = `${baseUrl}/${contractId}/pos/products`;
  const limit = 1000; // 1回のリクエストで取得する最大件数（APIの上限は1000）
  let page = 1;
  let allProducts: any[] = [];
  let hasMore = true;

  try {
    // 全ての商品を取得するまでループ
    while (hasMore) {


      const response = await axios.get(url, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        },
        params: {
          limit,
          page
        }
      });

      const products = response.data;
      allProducts = [...allProducts, ...products];

      // 取得件数が指定した上限より少ない場合、全ての商品を取得したと判断
      if (products.length < limit) {
        hasMore = false;
      } else {
        // 次のページへ
        page++;
      }
    }


    return allProducts;
  } catch (error) {
    console.error('スマレジ商品情報取得エラー:', error);
    throw new Error('スマレジからの商品情報取得に失敗しました');
  }
}

/**
 * スマレジAPIから商品画像情報を取得する（個別商品）
 * @param accessToken アクセストークン
 * @param contractId 契約ID
 * @param productId 商品ID
 * @param isSandbox サンドボックス環境かどうか
 * @returns 商品画像情報の配列
 * @deprecated 代わりに fetchSmaregiAllProductImages を使用してください
 */
export async function fetchSmaregiProductImages(
  accessToken: string,
  contractId: string,
  productId: string,
  isSandbox: boolean = true
): Promise<any[]> {
  const baseUrl = isSandbox ? 'https://api.smaregi.dev' : 'https://api.smaregi.jp';
  const url = `${baseUrl}/${contractId}/pos/products/${productId}/images`;

  try {
    const response = await axios.get(url, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    return response.data;
  } catch (error) {
    console.error(`スマレジ商品画像取得エラー (productId: ${productId}):`, error);

    // エラーレスポンスの詳細情報を出力
    if (error && typeof error === 'object' && 'response' in error) {
      const axiosError = error as { response: { status: number; statusText: string; data: any } };
      console.error(`エラーレスポンス (productId: ${productId}):`, {
        status: axiosError.response.status,
        statusText: axiosError.response.statusText,
        data: axiosError.response.data
      });
    }

    // エラーが発生しても処理を続行するため、空の配列を返す
    return [];
  }
}

/**
 * スマレジAPIから全商品画像情報を一括取得する
 * @param accessToken アクセストークン
 * @param contractId 契約ID
 * @param isSandbox サンドボックス環境かどうか
 * @returns 商品画像情報の配列
 */
export async function fetchSmaregiAllProductImages(
  accessToken: string,
  contractId: string,
  isSandbox: boolean = true
): Promise<any[]> {
  const baseUrl = isSandbox ? 'https://api.smaregi.dev' : 'https://api.smaregi.jp';
  const url = `${baseUrl}/${contractId}/pos/products/images`;
  const limit = 1000; // 1回のリクエストで取得する最大件数（APIの上限は1000）
  let page = 1;
  let allProductImages: any[] = [];
  let hasMore = true;

  try {
    // 全ての商品画像を取得するまでループ
    while (hasMore) {
      const response = await axios.get(url, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        },
        params: {
          limit,
          page
        }
      });

      const productImages = response.data;
      allProductImages = [...allProductImages, ...productImages];

      // 取得件数が指定した上限より少ない場合、全ての商品画像を取得したと判断
      if (productImages.length < limit) {
        hasMore = false;
      } else {
        // 次のページへ
        page++;
      }
    }

    // 画像取得結果のサマリーをログ出力
    const imageCount = allProductImages.length;
    const imagesWithUrl = allProductImages.filter(img => img.url || img.imageUrl).length;
    console.log(`スマレジ商品画像取得結果: 合計${imageCount}件、URL有り${imagesWithUrl}件`);

    // 最初の5件の画像情報をサンプルとしてログ出力
    if (allProductImages.length > 0) {
      const sampleImages = allProductImages.slice(0, 5);
      console.log('画像サンプル:', JSON.stringify(sampleImages));
    }

    return allProductImages;
  } catch (error) {
    console.error('スマレジ全商品画像取得エラー:', error);

    // エラーレスポンスの詳細情報を出力
    if (error && typeof error === 'object' && 'response' in error) {
      const axiosError = error as { response: { status: number; statusText: string; data: any } };
      console.error('エラーレスポンス:', {
        status: axiosError.response.status,
        statusText: axiosError.response.statusText,
        data: axiosError.response.data
      });
    }

    // エラーが発生しても処理を続行するため、空の配列を返す
    return [];
  }
}

/**
 * スマレジAPIから部門情報を取得する（ページネーション対応）
 * @param accessToken アクセストークン
 * @param contractId 契約ID
 * @param isSandbox サンドボックス環境かどうか
 * @returns 部門情報の配列
 */
export async function fetchSmaregiCategories(
  accessToken: string,
  contractId: string,
  isSandbox: boolean = true
): Promise<any[]> {
  const baseUrl = isSandbox ? 'https://api.smaregi.dev' : 'https://api.smaregi.jp';
  const url = `${baseUrl}/${contractId}/pos/categories`;
  const limit = 1000; // 1回のリクエストで取得する最大件数（APIの上限は1000）
  let page = 1;
  let allCategories: any[] = [];
  let hasMore = true;

  try {
    // 全ての部門を取得するまでループ
    while (hasMore) {


      const response = await axios.get(url, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        },
        params: {
          limit,
          page
        }
      });

      const categories = response.data;
      allCategories = [...allCategories, ...categories];

      // 取得件数が指定した上限より少ない場合、全ての部門を取得したと判断
      if (categories.length < limit) {
        hasMore = false;
      } else {
        // 次のページへ
        page++;
      }
    }


    return allCategories;
  } catch (error) {
    console.error('スマレジ部門情報取得エラー:', error);
    throw new Error('スマレジからの部門情報取得に失敗しました');
  }
}

/**
 * スマレジAPIに取引データを登録する
 * @param accessToken アクセストークン
 * @param contractId 契約ID
 * @param transactionData 取引データ
 * @param isSandbox サンドボックス環境かどうか
 * @returns 登録された取引情報
 */
export async function registerSmaregiTransaction(
  accessToken: string,
  contractId: string,
  transactionData: any,
  isSandbox: boolean = true
): Promise<any> {
  const baseUrl = isSandbox ? 'https://api.smaregi.dev' : 'https://api.smaregi.jp';
  const url = `${baseUrl}/${contractId}/pos/transactions`;

  try {
    const response = await axios.post(
      url,
      transactionData,
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    return response.data;
  } catch (error) {
    console.error('スマレジ取引登録エラー:', error);

    // エラーレスポンスの詳細情報を出力
    if (error && typeof error === 'object' && 'response' in error) {
      const axiosError = error as { response: { status: number; statusText: string; data: any } };
      console.error('エラーレスポンス:', {
        status: axiosError.response.status,
        statusText: axiosError.response.statusText,
        data: axiosError.response.data
      });

      // リクエストデータも出力（デバッグ用）
      console.error('リクエストデータ:', JSON.stringify(transactionData, null, 2));
    }

    throw new Error('スマレジへの取引登録に失敗しました');
  }
}
</file>

<file path="lib/supabase-realtime.ts">
import { createClient } from '@supabase/supabase-js';

// 共通の設定
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// クライアント側で使用するSupabaseクライアント（リアルタイム機能用）
export const createRealtimeClient = () => {
  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    throw new Error('Supabase URL or Anon Key is missing');
  }

  return createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
    },
  });
};

// リアルタイムチャンネルの種類
export enum RealtimeChannel {
  ORDERS = 'orders',
  SESSIONS = 'sessions',
  TABLES = 'tables',
}

// リアルタイムイベントの種類
export enum RealtimeEvent {
  INSERT = 'INSERT',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
}

// リアルタイムサブスクリプションのオプション
export interface SubscriptionOptions {
  event?: RealtimeEvent | '*';
  filter?: string;
  callback: (payload: any) => void;
}

// リアルタイムサブスクリプションを作成する関数
export const subscribeToTable = (
  table: string,
  options: SubscriptionOptions,
  storeId?: string
) => {
  const supabase = createRealtimeClient();
  
  // チャンネル名を生成（ストアIDがある場合は含める）
  const channelName = storeId 
    ? `realtime:${storeId}:${table}` 
    : `realtime:${table}`;
  
  // チャンネルを作成
  const channel = supabase
    .channel(channelName)
    .on(
      'postgres_changes',
      {
        event: options.event || '*',
        schema: 'public',
        table: table,
        filter: options.filter || undefined,
      },
      (payload) => {
        options.callback(payload);
      }
    )
    .subscribe();
  
  // チャンネルの解除関数を返す
  return () => {
    supabase.removeChannel(channel);
  };
};

// 注文テーブルのサブスクリプション
export const subscribeToOrders = (
  storeId: string,
  callback: (payload: any) => void
) => {
  return subscribeToTable(
    'orders',
    {
      event: '*',
      filter: `store_id=eq.${storeId}`,
      callback,
    },
    storeId
  );
};

// 注文アイテムテーブルのサブスクリプション
export const subscribeToOrderItems = (
  storeId: string,
  callback: (payload: any) => void
) => {
  return subscribeToTable(
    'order_items',
    {
      event: '*',
      callback,
    },
    storeId
  );
};

// セッションテーブルのサブスクリプション
export const subscribeToSessions = (
  storeId: string,
  callback: (payload: any) => void
) => {
  return subscribeToTable(
    'sessions',
    {
      event: '*',
      filter: `store_id=eq.${storeId}`,
      callback,
    },
    storeId
  );
};

// テーブルテーブルのサブスクリプション
export const subscribeToTables = (
  storeId: string,
  callback: (payload: any) => void
) => {
  return subscribeToTable(
    'tables',
    {
      event: '*',
      filter: `store_id=eq.${storeId}`,
      callback,
    },
    storeId
  );
};
</file>

<file path="lib/supabase.ts">
import { createClient } from '@supabase/supabase-js';
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

// 共通の設定
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

// サービスロール権限のクライアント（データベース操作用）
export const createServerSupabaseClient = async () => {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
    throw new Error('Supabase URL or Service Role Key is missing');
  }

  return createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
};

// サーバーコンポーネント用のクライアント（Cookieベース）
export const createServerComponentClient = async () => {
  const cookieStore = await cookies();

  return createServerClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options);
            });
          } catch (error) {
            // サーバーコンポーネントからの呼び出しの場合、エラーが発生する可能性がある
            console.error('createServerComponentClient: Cookie設定エラー:', error);
            // ミドルウェアでセッションが更新されていれば問題ない
          }
        },
      },
    }
  );
};

// ミドルウェア用のクライアント
export const createMiddlewareClient = (request: NextRequest, response: NextResponse) => {
  return createServerClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          // リクエストCookieを設定（Next.jsのミドルウェア用）
          cookiesToSet.forEach(({ name, value }) => {
            request.cookies.set({
              name,
              value,
            });
          });

          // レスポンスCookieを設定（ブラウザ用）
          cookiesToSet.forEach(({ name, value, options }) => {
            response.cookies.set({
              name,
              value,
              ...options,
            });
          });
        },
      },
    }
  );
};

// ミドルウェアでセッションを更新する関数
export async function updateSession(request: NextRequest) {
  // レスポンスを作成
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  // ミドルウェアクライアントを作成
  const supabase = createMiddlewareClient(request, response);

  try {
    // getUser()を直接使用して認証を確認（セキュリティ上の理由からgetSession()は使用しない）
    const { data: { user }, error } = await supabase.auth.getUser();

    if (error) {
      console.error('Middleware: 認証エラー:', error);
      // エラーがあっても処理を続行（リダイレクト判定のため）
    }

    // ポータルへのアクセスは認証が必要
    if (request.nextUrl.pathname.startsWith('/portal')) {
      if (!user) {
        // ログインページにリダイレクト
        return NextResponse.redirect(new URL('/', request.url));
      }

      // 店舗IDの取得
      const storeId = request.cookies.get('store-id')?.value;

      if (!storeId) {
        // 店舗IDがない場合はログアウト
        await supabase.auth.signOut();
        return NextResponse.redirect(new URL('/', request.url));
      }
    }
  } catch (error) {
    console.error('Middleware: 予期せぬエラー:', error);
    // エラーが発生した場合でも処理を続行
  }

  return response;
}
</file>

<file path="middleware.ts">
import { NextRequest } from 'next/server';
import { updateSession } from '@/lib/supabase';

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

// ミドルウェアを適用するパスを指定
export const config = {
  matcher: [
    // 認証が必要なパスのみを指定
    '/portal/:path*',
  ],
};
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: [
      'pos-cache.smaregi.dev', // スマレジの画像ドメイン
      'pos-cache.smaregi.jp',  // 本番環境用のスマレジ画像ドメイン
      'ooiajrjymsrmnxukmavb.supabase.co' // Supabaseストレージドメイン
    ],
  },
}

module.exports = nextConfig
</file>

<file path="package.json">
{
  "name": "girls-bar-qr-menu-sys",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:e2e": "playwright test",
    "seed": "ts-node --project tsconfig.scripts.json scripts/seed.ts"
  },
  "dependencies": {
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.49.4",
    "axios": "^1.9.0",
    "next": "^15.3.1",
    "qrcode": "^1.5.3",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "uuid": "^11.1.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.1",
    "@types/node": "^20.10.6",
    "@types/qrcode": "^1.5.5",
    "@types/react": "^18.2.46",
    "@types/react-dom": "^18.2.18",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "dotenv": "^16.5.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^15.3.1",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "vitest": "^3.1.3"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="scripts/run-migration.js">
/**
 * Supabaseマイグレーションを実行するスクリプト
 *
 * 使用方法:
 * 1. .env.localファイルにSUPABASE_URLとSUPABASE_ANON_KEYを設定
 * 2. npm run migrate を実行
 */

const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const dotenv = require('dotenv');

// .env.localファイルを読み込む
dotenv.config({ path: '.env.local' });

// 必要な環境変数が設定されているか確認
const { SUPABASE_URL, SUPABASE_ANON_KEY } = process.env;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.error('エラー: SUPABASE_URLとSUPABASE_ANON_KEYを.env.localファイルに設定してください。');
  process.exit(1);
}

// マイグレーションディレクトリのパス
const migrationsDir = path.join(__dirname, '..', 'supabase', 'migrations');

// マイグレーションファイルが存在するか確認
if (!fs.existsSync(migrationsDir)) {
  console.error(`エラー: マイグレーションディレクトリが見つかりません: ${migrationsDir}`);
  process.exit(1);
}

try {
  console.log('Supabaseマイグレーションを実行中...');

  // supabase CLIがインストールされているか確認
  try {
    execSync('supabase --version', { stdio: 'ignore' });
  } catch (error) {
    console.error('エラー: supabase CLIがインストールされていません。');
    console.error('インストール方法: https://supabase.com/docs/guides/cli');
    process.exit(1);
  }

  // コマンドライン引数を取得
  const args = process.argv.slice(2);
  const isReset = args.includes('--reset');
  const isDebug = args.includes('--debug');
  const specificMigration = args.find(arg => arg.startsWith('--file='));

  let command = '';

  if (isReset) {
    // データベースをリセットして全てのマイグレーションを適用
    command = 'supabase db reset';
    if (isDebug) {
      command += ' --debug';
    }
  } else if (specificMigration) {
    // 特定のマイグレーションファイルのみを適用
    const migrationFile = specificMigration.replace('--file=', '');
    const migrationPath = path.join(migrationsDir, migrationFile);

    if (!fs.existsSync(migrationPath)) {
      console.error(`エラー: マイグレーションファイルが見つかりません: ${migrationPath}`);
      process.exit(1);
    }

    command = `supabase db push --db-only ${isDebug ? '--debug' : ''}`;
  } else {
    // 新しいマイグレーションのみを適用
    command = `supabase db push --db-only ${isDebug ? '--debug' : ''}`;
  }

  console.log(`実行コマンド: ${command}`);

  // マイグレーションを実行
  execSync(command, {
    stdio: 'inherit',
    env: {
      ...process.env,
      SUPABASE_URL,
      SUPABASE_ANON_KEY
    }
  });

  console.log('マイグレーションが正常に完了しました！');
} catch (error) {
  console.error('マイグレーション中にエラーが発生しました:', error.message);
  process.exit(1);
}
</file>

<file path="scripts/seed.ts">
import { createServerSupabaseClient } from '../lib/supabase';
import * as dotenv from 'dotenv';

// .env.localファイルから環境変数を読み込む
dotenv.config({ path: '.env.local' });

async function main() {
  // 監査ログトリガーを一時的に無効化
  const disableAuditTriggers = async (supabase: any) => {
    console.log('Temporarily disabling audit triggers...');
    await supabase.rpc('disable_audit_triggers');
  };

  // 監査ログトリガーを再度有効化
  const enableAuditTriggers = async (supabase: any) => {
    console.log('Re-enabling audit triggers...');
    await supabase.rpc('enable_audit_triggers');
  };
  console.log('Starting seed process...');

  const supabase = await createServerSupabaseClient();

  try {
    // 監査ログトリガーを一時的に無効化
    try {
      await disableAuditTriggers(supabase);
    } catch (error) {
      console.warn('Failed to disable audit triggers. This might be expected if they are not set up yet:', error);
    }
    // 店舗の作成
    console.log('Creating store...');
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .insert({ store_code: 'GB001', name: 'GirlsBar One' })
      .select()
      .single();

    if (storeError) {
      throw storeError;
    }

    console.log('Store created:', store);

    // 管理者ユーザーの作成
    console.log('Creating admin user...');
    const { data: user, error: userError } = await supabase.auth.admin.createUser({
      email: 'test@test.com',
      password: 'testtest',
      email_confirm: true,
    });

    if (userError) {
      throw userError;
    }

    console.log('Admin user created:', user);

    // 店舗ユーザー関連付けの作成
    console.log('Creating store user association...');
    const { data: storeUser, error: storeUserError } = await supabase
      .from('store_users')
      .insert({
        store_id: store.store_id,
        user_id: user.user.id,
        role: 'admin'
      })
      .select()
      .single();

    if (storeUserError) {
      throw storeUserError;
    }

    console.log('Store user association created:', storeUser);

    // 席種の作成
    console.log('Creating seat types...');
    const seatTypes = [
      { code: 'COUNTER', display_name: 'カウンター席', price_per_unit: 1500 },
      { code: 'TABLE', display_name: 'テーブル席', price_per_unit: 2000 },
      { code: 'VIP', display_name: 'VIP席', price_per_unit: 3000 }
    ];

    const { data: createdSeatTypes, error: seatTypeError } = await supabase
      .from('seat_types')
      .insert(seatTypes)
      .select();

    if (seatTypeError) {
      throw seatTypeError;
    }

    console.log('Seat types created:', createdSeatTypes);

    // テーブルの作成
    console.log('Creating tables...');
    const tables = [
      { store_id: store.store_id, name: 'C1', seat_type_id: createdSeatTypes[0].seat_type_id },
      { store_id: store.store_id, name: 'C2', seat_type_id: createdSeatTypes[0].seat_type_id },
      { store_id: store.store_id, name: 'T1', seat_type_id: createdSeatTypes[1].seat_type_id },
      { store_id: store.store_id, name: 'V1', seat_type_id: createdSeatTypes[2].seat_type_id }
    ];

    const { data: createdTables, error: tableError } = await supabase
      .from('tables')
      .insert(tables)
      .select();

    if (tableError) {
      throw tableError;
    }

    console.log('Tables created:', createdTables);

    console.log('Seed completed successfully!');

  } catch (error) {
    console.error('Error during seed process:', error);
    process.exit(1);
  } finally {
    // 監査ログトリガーを再度有効化
    try {
      await enableAuditTriggers(supabase);
    } catch (error) {
      console.warn('Failed to re-enable audit triggers:', error);
    }
  }
}

main();
</file>

<file path="supabase/.temp/cli-latest">
v2.22.12
</file>

<file path="supabase/.temp/gotrue-version">
v2.171.0
</file>

<file path="supabase/.temp/pooler-url">
postgresql://postgres.ooiajrjymsrmnxukmavb:[YOUR-PASSWORD]@aws-0-ap-northeast-1.pooler.supabase.com:6543/postgres
</file>

<file path="supabase/.temp/postgres-version">
15.8.1.073
</file>

<file path="supabase/.temp/project-ref">
ooiajrjymsrmnxukmavb
</file>

<file path="supabase/.temp/rest-version">
v12.2.3
</file>

<file path="supabase/.temp/storage-version">
custom-metadata
</file>

<file path="supabase/config.toml">
# A string used to distinguish different Supabase projects on the same host. Defaults to the working
# directory name when running `supabase init`.
project_id = "girls-bar-qr-menu-sys"

[api]
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. public and storage are always included.
schemas = ["public", "storage", "auth"]
# Extra schemas to add to the search_path of every request. public is always included.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[db]
# Port to use for the local database URL.
port = 54322
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[studio]
# Port to use for Supabase Studio.
port = 54323

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
# Port to use for the email testing server web interface.
port = 54324
smtp_port = 54325
pop3_port = 54326

[storage]
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

[auth]
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://localhost:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://localhost:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 seconds (one
# week).
jwt_expiry = 3600
# Allow/disallow new user signups to your project.
enable_signup = true

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false

# Use an external OAuth provider. The full list of providers are: "apple", "azure", "bitbucket",
# "discord", "facebook", "github", "gitlab", "google", "keycloak", "linkedin", "notion", "twitch",
# "twitter", "slack", "spotify", "workos", "zoom".
[auth.external.apple]
enabled = false
client_id = ""
secret = ""
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""

[analytics]
enabled = false
port = 54327
vector_port = 54328
# Setup BigQuery project to enable log viewer on local development stack.
# See: https://supabase.com/docs/guides/getting-started/local-development#enabling-local-logging
gcp_project_id = ""
gcp_project_number = ""
gcp_jwt_path = "supabase/gcloud.json"
</file>

<file path="supabase/migrations/20250428000000_initial_schema.sql">
-- 初期スキーマ作成
-- 店舗テーブル
create table if not exists public.stores (
  store_id uuid primary key default gen_random_uuid(),
  store_code text unique not null,
  name text not null,
  created_at timestamptz default now()
);

-- 席種テーブル
create table if not exists public.seat_types (
  seat_type_id serial primary key,
  code text unique not null,
  display_name text not null,
  price_per_30min int not null,
  created_at timestamptz default now()
);

-- テーブルテーブル
create table if not exists public.tables (
  table_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  name text not null,
  seat_type_id int references public.seat_types not null,
  created_at timestamptz default now()
);

-- セッションテーブル
create table if not exists public.sessions (
  session_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  table_id uuid references public.tables on delete cascade not null,
  start_at timestamptz default now(),
  charge_started_at timestamptz,
  created_at timestamptz default now()
);

-- セッション席種イベントテーブル
create table if not exists public.session_seat_events (
  event_id uuid primary key default gen_random_uuid(),
  session_id uuid references public.sessions on delete cascade not null,
  seat_type_id int references public.seat_types not null,
  price_snapshot int not null,
  changed_at timestamptz default now(),
  created_at timestamptz default now()
);

-- 注文テーブル
create table if not exists public.orders (
  order_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  session_id uuid references public.sessions on delete cascade not null,
  status text check (status in ('new','ack','prep','served','closed','cancel')) not null,
  created_by_role text,
  proxy boolean default false,
  created_at timestamptz default now()
);

-- 注文明細テーブル
create table if not exists public.order_items (
  order_item_id uuid primary key default gen_random_uuid(),
  order_id uuid references public.orders on delete cascade not null,
  product_id text not null,
  product_name text not null,
  quantity int not null,
  price int not null,
  target_cast_id uuid references auth.users,
  created_at timestamptz default now()
);

-- メニューテーブル
create table if not exists public.menus (
  menu_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  product_id text not null,
  name text not null,
  description text,
  price int not null,
  image_url text,
  category text,
  is_staff_drink boolean default false,
  is_available boolean default true,
  created_at timestamptz default now(),
  unique(store_id, product_id)
);

-- 店舗ユーザー関連テーブル
create table if not exists public.store_users (
  id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  user_id uuid references auth.users on delete cascade not null,
  role text check (role in ('admin','cast')) not null,
  created_at timestamptz default now(),
  unique(store_id, user_id)
);

-- 会計履歴テーブル
create table if not exists public.checkouts (
  checkout_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  session_id uuid references public.sessions on delete cascade not null,
  total_amount int not null,
  charge_amount int not null,
  order_amount int not null,
  smaregi_receipt_id text,
  status text check (status in ('pending','completed','failed')) not null default 'pending',
  created_at timestamptz default now()
);

-- ブロードキャストテーブル（リアルタイム通知用）
create table if not exists public.broadcast (
  id uuid primary key default gen_random_uuid(),
  channel text not null,
  payload jsonb not null,
  created_at timestamptz default now()
);

-- 監査ログテーブル
create table if not exists public.audit_logs (
  log_id uuid primary key default gen_random_uuid(),
  store_id uuid references public.stores on delete cascade not null,
  user_id uuid references auth.users,
  action text not null,
  table_name text not null,
  record_id uuid not null,
  old_data jsonb,
  new_data jsonb,
  created_at timestamptz default now()
);

-- インデックス作成
create index if not exists idx_tables_store_id on public.tables(store_id);
create index if not exists idx_sessions_store_id on public.sessions(store_id);
create index if not exists idx_sessions_table_id on public.sessions(table_id);
create index if not exists idx_orders_store_id on public.orders(store_id);
create index if not exists idx_orders_session_id on public.orders(session_id);
create index if not exists idx_orders_status on public.orders(status);
create index if not exists idx_order_items_order_id on public.order_items(order_id);
create index if not exists idx_menus_store_id on public.menus(store_id);
create index if not exists idx_store_users_store_id on public.store_users(store_id);
create index if not exists idx_store_users_user_id on public.store_users(user_id);
create index if not exists idx_session_seat_events_session_id on public.session_seat_events(session_id);
create index if not exists idx_checkouts_store_id on public.checkouts(store_id);
create index if not exists idx_checkouts_session_id on public.checkouts(session_id);
create index if not exists idx_audit_logs_store_id on public.audit_logs(store_id);
create index if not exists idx_audit_logs_created_at on public.audit_logs(created_at);
</file>

<file path="supabase/migrations/20250428000001_rls_policies.sql">
-- RLSを有効化
alter table public.stores enable row level security;
alter table public.seat_types enable row level security;
alter table public.tables enable row level security;
alter table public.sessions enable row level security;
alter table public.session_seat_events enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.menus enable row level security;
alter table public.store_users enable row level security;
alter table public.checkouts enable row level security;
alter table public.broadcast enable row level security;
alter table public.audit_logs enable row level security;

-- 匿名ユーザー用のポリシー
-- 店舗情報は匿名ユーザーも閲覧可能
create policy "店舗情報は誰でも閲覧可能" on public.stores
  for select using (true);

-- テーブル情報は匿名ユーザーも閲覧可能
create policy "テーブル情報は誰でも閲覧可能" on public.tables
  for select using (true);

-- 席種情報は匿名ユーザーも閲覧可能
create policy "席種情報は誰でも閲覧可能" on public.seat_types
  for select using (true);

-- メニュー情報は匿名ユーザーも閲覧可能
create policy "メニュー情報は誰でも閲覧可能" on public.menus
  for select using (true);

-- セッション情報は匿名ユーザーも閲覧可能（テーブルIDで絞り込み）
create policy "セッション情報は誰でも閲覧可能" on public.sessions
  for select using (true);

-- 匿名ユーザーは注文を作成可能
create policy "匿名ユーザーは注文を作成可能" on public.orders
  for insert with check (created_by_role = 'customer');

-- 匿名ユーザーは注文明細を作成可能
create policy "匿名ユーザーは注文明細を作成可能" on public.order_items
  for insert with check (
    order_id in (
      select order_id from public.orders where created_by_role = 'customer'
    )
  );

-- 認証済みユーザー用のポリシー
-- 自分が所属する店舗の情報のみ閲覧・編集可能
create policy "自分が所属する店舗の情報のみ閲覧可能" on public.stores
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗のテーブル情報のみ閲覧・編集可能
create policy "自分が所属する店舗のテーブル情報のみ閲覧・編集可能" on public.tables
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗のセッション情報のみ閲覧・編集可能
create policy "自分が所属する店舗のセッション情報のみ閲覧・編集可能" on public.sessions
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗のセッション席種イベント情報のみ閲覧・編集可能
create policy "自分が所属する店舗のセッション席種イベント情報のみ閲覧・編集可能" on public.session_seat_events
  for all using (
    session_id in (
      select session_id from public.sessions where store_id in (
        select store_id from public.store_users where user_id = auth.uid()
      )
    )
  );

-- 自分が所属する店舗の注文情報のみ閲覧・編集可能
create policy "自分が所属する店舗の注文情報のみ閲覧・編集可能" on public.orders
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗の注文明細情報のみ閲覧・編集可能
create policy "自分が所属する店舗の注文明細情報のみ閲覧・編集可能" on public.order_items
  for all using (
    order_id in (
      select order_id from public.orders where store_id in (
        select store_id from public.store_users where user_id = auth.uid()
      )
    )
  );

-- 自分が所属する店舗のメニュー情報のみ閲覧・編集可能
create policy "自分が所属する店舗のメニュー情報のみ閲覧・編集可能" on public.menus
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗の会計情報のみ閲覧・編集可能
create policy "自分が所属する店舗の会計情報のみ閲覧・編集可能" on public.checkouts
  for all using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 自分が所属する店舗の監査ログのみ閲覧可能
create policy "自分が所属する店舗の監査ログのみ閲覧可能" on public.audit_logs
  for select using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 店舗ユーザー関連は自分が所属する店舗のみ閲覧可能
create policy "自分が所属する店舗のユーザー関連のみ閲覧可能" on public.store_users
  for select using (
    store_id in (
      select store_id from public.store_users where user_id = auth.uid()
    )
  );

-- 管理者のみ店舗ユーザー関連を編集可能
create policy "管理者のみ店舗ユーザー関連を編集可能" on public.store_users
  for insert with check (
    exists (
      select 1 from public.store_users 
      where user_id = auth.uid() and store_id = store_users.store_id and role = 'admin'
    )
  );

create policy "管理者のみ店舗ユーザー関連を更新可能" on public.store_users
  for update using (
    exists (
      select 1 from public.store_users 
      where user_id = auth.uid() and store_id = store_users.store_id and role = 'admin'
    )
  );

create policy "管理者のみ店舗ユーザー関連を削除可能" on public.store_users
  for delete using (
    exists (
      select 1 from public.store_users 
      where user_id = auth.uid() and store_id = store_users.store_id and role = 'admin'
    )
  );

-- 席種は管理者のみ編集可能
create policy "席種は管理者のみ編集可能" on public.seat_types
  for insert with check (
    exists (
      select 1 from public.store_users where user_id = auth.uid() and role = 'admin'
    )
  );

create policy "席種は管理者のみ更新可能" on public.seat_types
  for update using (
    exists (
      select 1 from public.store_users where user_id = auth.uid() and role = 'admin'
    )
  );

create policy "席種は管理者のみ削除可能" on public.seat_types
  for delete using (
    exists (
      select 1 from public.store_users where user_id = auth.uid() and role = 'admin'
    )
  );

-- ブロードキャストは誰でも閲覧可能
create policy "ブロードキャストは誰でも閲覧可能" on public.broadcast
  for select using (true);

-- ブロードキャストは認証済みユーザーのみ作成可能
create policy "ブロードキャストは認証済みユーザーのみ作成可能" on public.broadcast
  for insert with check (auth.role() = 'authenticated');
</file>

<file path="supabase/migrations/20250428000002_charge_functions.sql">
-- チャージ計算用の関数
create or replace function public.fn_calc_total_charge(p_session_id uuid)
returns int
language plpgsql
security definer
as $$
declare
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_half_hour_units int;
  v_event_charge int;
begin
  -- セッションの開始時間を取得
  select charge_started_at into v_charge_start_time
  from public.sessions
  where session_id = p_session_id;

  -- チャージ開始時間が設定されていない場合は0を返す
  if v_charge_start_time is null then
    return 0;
  end if;

  -- セッション席種イベントを時系列順に取得
  for v_event in (
    select
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at
    from public.session_seat_events
    where session_id = p_session_id
    order by changed_at asc
  ) loop
    -- 最初のイベントの場合
    if v_last_event_time is null then
      v_last_event_time := v_charge_start_time;
    end if;

    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch from (v_event.changed_at - v_last_event_time)) / 60;

    -- 30分単位で切り上げ
    v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / 30) * 30;

    -- 30分単位の数を計算
    v_half_hour_units := v_rounded_minutes / 30;

    -- 区間のチャージ金額を計算
    v_event_charge := v_half_hour_units * (
      select price_per_unit
      from public.seat_types
      where seat_type_id = v_event.seat_type_id
    );

    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;

    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  end loop;

  -- 最後のイベントから現在までの経過時間を計算
  if v_last_event_time is null then
    -- イベントがない場合は開始時間から現在までを計算
    v_last_event_time := v_charge_start_time;
  end if;

  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch from (v_current_time - v_last_event_time)) / 60;

  -- 30分単位で切り上げ
  v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / 30) * 30;

  -- 30分単位の数を計算
  v_half_hour_units := v_rounded_minutes / 30;

  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_half_hour_units * (
    select price_per_unit
    from public.seat_types
    where seat_type_id = (
      select seat_type_id
      from public.session_seat_events
      where session_id = p_session_id
      order by changed_at desc
      limit 1
    )
  );

  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;

  return v_total_charge;
end;
$$;

-- セッション開始時に席種スナップショットを作成する関数
create or replace function public.fn_create_session_seat_snapshot()
returns trigger
language plpgsql
security definer
as $$
begin
  -- チャージ開始時に席種スナップショットを作成
  if new.charge_started_at is not null and (old.charge_started_at is null or old.charge_started_at <> new.charge_started_at) then
    insert into public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    select
      new.session_id,
      t.seat_type_id,
      st.price_per_unit,
      new.charge_started_at
    from
      public.tables t
      join public.seat_types st on t.seat_type_id = st.seat_type_id
    where
      t.table_id = new.table_id;
  end if;

  return new;
end;
$$;

-- セッション更新時のトリガー
create trigger trg_session_update
after update on public.sessions
for each row
execute function public.fn_create_session_seat_snapshot();

-- テーブルの席種変更時にセッション席種スナップショットを作成する関数
create or replace function public.fn_create_table_seat_change_snapshot()
returns trigger
language plpgsql
security definer
as $$
begin
  -- 席種が変更された場合
  if new.seat_type_id <> old.seat_type_id then
    -- アクティブなセッションがあれば席種スナップショットを作成
    insert into public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    select
      s.session_id,
      new.seat_type_id,
      st.price_per_unit,
      now()
    from
      public.sessions s
      join public.seat_types st on st.seat_type_id = new.seat_type_id
    where
      s.table_id = new.table_id
      and s.charge_started_at is not null;
  end if;

  return new;
end;
$$;

-- テーブル更新時のトリガー
create trigger trg_table_update
after update on public.tables
for each row
execute function public.fn_create_table_seat_change_snapshot();
</file>

<file path="supabase/migrations/20250428000003_audit_triggers.sql">
-- 監査ログ用のトリガー関数
create or replace function public.fn_audit_log()
returns trigger
language plpgsql
security definer
as $$
declare
  v_store_id uuid;
  v_user_id uuid := auth.uid();
  v_action text;
  v_record_id uuid;
begin
  -- アクションの種類を設定
  if TG_OP = 'INSERT' then
    v_action := 'insert';
    v_record_id := new.id;
    
    -- テーブルごとに店舗IDを取得
    if TG_TABLE_NAME = 'stores' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      select store_id into v_store_id from public.orders where order_id = new.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      select store_id into v_store_id from public.sessions where session_id = new.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      new_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(new)
    );
    
  elsif TG_OP = 'UPDATE' then
    v_action := 'update';
    v_record_id := new.id;
    
    -- テーブルごとに店舗IDを取得
    if TG_TABLE_NAME = 'stores' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      select store_id into v_store_id from public.orders where order_id = new.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      select store_id into v_store_id from public.sessions where session_id = new.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      old_data,
      new_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(old),
      to_jsonb(new)
    );
    
  elsif TG_OP = 'DELETE' then
    v_action := 'delete';
    v_record_id := old.id;
    
    -- テーブルごとに店舗IDを取得
    if TG_TABLE_NAME = 'stores' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      select store_id into v_store_id from public.orders where order_id = old.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      select store_id into v_store_id from public.sessions where session_id = old.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      old_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(old)
    );
  end if;
  
  return null;
end;
$$;

-- 監査ログトリガーを各テーブルに適用
create trigger trg_audit_stores
after insert or update or delete on public.stores
for each row execute function public.fn_audit_log();

create trigger trg_audit_tables
after insert or update or delete on public.tables
for each row execute function public.fn_audit_log();

create trigger trg_audit_sessions
after insert or update or delete on public.sessions
for each row execute function public.fn_audit_log();

create trigger trg_audit_orders
after insert or update or delete on public.orders
for each row execute function public.fn_audit_log();

create trigger trg_audit_order_items
after insert or update or delete on public.order_items
for each row execute function public.fn_audit_log();

create trigger trg_audit_menus
after insert or update or delete on public.menus
for each row execute function public.fn_audit_log();

create trigger trg_audit_store_users
after insert or update or delete on public.store_users
for each row execute function public.fn_audit_log();

create trigger trg_audit_checkouts
after insert or update or delete on public.checkouts
for each row execute function public.fn_audit_log();

-- 90日以上経過した監査ログを削除する関数
create or replace function public.fn_cleanup_audit_logs()
returns void
language plpgsql
security definer
as $$
begin
  delete from public.audit_logs
  where created_at < now() - interval '90 days';
end;
$$;
</file>

<file path="supabase/migrations/20250428000004_report_views.sql">
-- 日次売上レポート用ビュー
create or replace view public.v_daily_sales as
select
  c.store_id,
  s.name as store_name,
  date_trunc('day', c.created_at) as sales_date,
  count(distinct c.checkout_id) as checkout_count,
  sum(c.total_amount) as total_sales,
  sum(c.charge_amount) as charge_sales,
  sum(c.order_amount) as order_sales
from
  public.checkouts c
  join public.stores s on c.store_id = s.store_id
where
  c.status = 'completed'
group by
  c.store_id,
  s.name,
  date_trunc('day', c.created_at);

-- スタッフドリンク集計用ビュー
create or replace view public.v_staff_drinks as
select
  o.store_id,
  s.name as store_name,
  date_trunc('day', o.created_at) as sales_date,
  oi.target_cast_id,
  u.email as cast_email,
  count(oi.order_item_id) as drink_count,
  sum(oi.price * oi.quantity) as drink_sales
from
  public.order_items oi
  join public.orders o on oi.order_id = o.order_id
  join public.stores s on o.store_id = s.store_id
  left join auth.users u on oi.target_cast_id = u.id
where
  oi.target_cast_id is not null
  and o.status not in ('cancel')
group by
  o.store_id,
  s.name,
  date_trunc('day', o.created_at),
  oi.target_cast_id,
  u.email;

-- テーブル利用状況ビュー
create or replace view public.v_table_usage as
select
  s.store_id,
  st.name as store_name,
  t.table_id,
  t.name as table_name,
  st2.display_name as seat_type,
  st2.price_per_30min,
  s.session_id,
  s.start_at,
  s.charge_started_at,
  case
    when s.charge_started_at is not null then
      extract(epoch from (now() - s.charge_started_at)) / 60
    else
      0
  end as elapsed_minutes,
  case
    when s.charge_started_at is not null then
      ceiling(extract(epoch from (now() - s.charge_started_at)) / 60 / 30) * 30
    else
      0
  end as rounded_minutes,
  case
    when s.charge_started_at is not null then
      ceiling(extract(epoch from (now() - s.charge_started_at)) / 60 / 30) * st2.price_per_30min
    else
      0
  end as current_charge
from
  public.sessions s
  join public.tables t on s.table_id = t.table_id
  join public.stores st on s.store_id = st.store_id
  join public.seat_types st2 on t.seat_type_id = st2.seat_type_id
where
  s.charge_started_at is not null
  and not exists (
    select 1 from public.checkouts c
    where c.session_id = s.session_id and c.status = 'completed'
  );

-- 注文ステータス集計ビュー
create or replace view public.v_order_status as
select
  o.store_id,
  s.name as store_name,
  o.status,
  count(*) as order_count
from
  public.orders o
  join public.stores s on o.store_id = s.store_id
where
  o.created_at > now() - interval '24 hours'
group by
  o.store_id,
  s.name,
  o.status;
</file>

<file path="supabase/migrations/20250428000007_audit_triggers_fix.sql">
-- 監査ログ用のトリガー関数を修正
create or replace function public.fn_audit_log()
returns trigger
language plpgsql
security definer
as $$
declare
  v_store_id uuid;
  v_user_id uuid := auth.uid();
  v_action text;
  v_record_id uuid;
begin
  -- アクションの種類を設定
  if TG_OP = 'INSERT' then
    v_action := 'insert';
    
    -- テーブルごとに主キーを取得
    if TG_TABLE_NAME = 'stores' then
      v_record_id := new.store_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_record_id := new.table_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_record_id := new.session_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_record_id := new.order_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_record_id := new.menu_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_record_id := new.id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_record_id := new.checkout_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      v_record_id := new.item_id;
      select store_id into v_store_id from public.orders where order_id = new.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      v_record_id := new.event_id;
      select store_id into v_store_id from public.sessions where session_id = new.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      new_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(new)
    );
    
  elsif TG_OP = 'UPDATE' then
    v_action := 'update';
    
    -- テーブルごとに主キーを取得
    if TG_TABLE_NAME = 'stores' then
      v_record_id := new.store_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_record_id := new.table_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_record_id := new.session_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_record_id := new.order_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_record_id := new.menu_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_record_id := new.id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_record_id := new.checkout_id;
      v_store_id := new.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      v_record_id := new.item_id;
      select store_id into v_store_id from public.orders where order_id = new.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      v_record_id := new.event_id;
      select store_id into v_store_id from public.sessions where session_id = new.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      old_data,
      new_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(old),
      to_jsonb(new)
    );
    
  elsif TG_OP = 'DELETE' then
    v_action := 'delete';
    
    -- テーブルごとに主キーを取得
    if TG_TABLE_NAME = 'stores' then
      v_record_id := old.store_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'tables' then
      v_record_id := old.table_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'sessions' then
      v_record_id := old.session_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'orders' then
      v_record_id := old.order_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'menus' then
      v_record_id := old.menu_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'store_users' then
      v_record_id := old.id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'checkouts' then
      v_record_id := old.checkout_id;
      v_store_id := old.store_id;
    elsif TG_TABLE_NAME = 'order_items' then
      v_record_id := old.item_id;
      select store_id into v_store_id from public.orders where order_id = old.order_id;
    elsif TG_TABLE_NAME = 'session_seat_events' then
      v_record_id := old.event_id;
      select store_id into v_store_id from public.sessions where session_id = old.session_id;
    end if;
    
    -- 監査ログを挿入
    insert into public.audit_logs (
      store_id,
      user_id,
      action,
      table_name,
      record_id,
      old_data
    ) values (
      v_store_id,
      v_user_id,
      v_action,
      TG_TABLE_NAME,
      v_record_id,
      to_jsonb(old)
    );
  end if;
  
  return null;
end;
$$;
</file>

<file path="supabase/migrations/20250428000008_audit_triggers_toggle.sql">
-- 監査ログトリガーを無効化するRPC関数
create or replace function public.disable_audit_triggers()
returns void
language plpgsql
security definer
as $$
begin
  alter table public.stores disable trigger trg_audit_stores;
  alter table public.tables disable trigger trg_audit_tables;
  alter table public.sessions disable trigger trg_audit_sessions;
  alter table public.orders disable trigger trg_audit_orders;
  alter table public.order_items disable trigger trg_audit_order_items;
  alter table public.menus disable trigger trg_audit_menus;
  alter table public.store_users disable trigger trg_audit_store_users;
  alter table public.checkouts disable trigger trg_audit_checkouts;
end;
$$;

-- 監査ログトリガーを有効化するRPC関数
create or replace function public.enable_audit_triggers()
returns void
language plpgsql
security definer
as $$
begin
  alter table public.stores enable trigger trg_audit_stores;
  alter table public.tables enable trigger trg_audit_tables;
  alter table public.sessions enable trigger trg_audit_sessions;
  alter table public.orders enable trigger trg_audit_orders;
  alter table public.order_items enable trigger trg_audit_order_items;
  alter table public.menus enable trigger trg_audit_menus;
  alter table public.store_users enable trigger trg_audit_store_users;
  alter table public.checkouts enable trigger trg_audit_checkouts;
end;
$$;
</file>

<file path="supabase/migrations/20250430000000_add_store_id_to_seat_types.sql">
-- seat_typesテーブルにstore_idカラムを追加
ALTER TABLE public.seat_types
ADD COLUMN store_id uuid REFERENCES public.stores(store_id) ON DELETE CASCADE;

-- 既存の席種データを移行するための一時的な処理
-- 既存のすべての席種を最初の店舗に紐づける
UPDATE public.seat_types
SET store_id = (SELECT store_id FROM public.stores LIMIT 1)
WHERE store_id IS NULL;

-- store_idカラムをNOT NULLに設定
ALTER TABLE public.seat_types
ALTER COLUMN store_id SET NOT NULL;

-- 店舗IDとコードの組み合わせでユニーク制約を設定
ALTER TABLE public.seat_types
DROP CONSTRAINT seat_types_code_key;

ALTER TABLE public.seat_types
ADD CONSTRAINT seat_types_store_id_code_key UNIQUE (store_id, code);

-- RLSポリシーの追加
ALTER TABLE public.seat_types ENABLE ROW LEVEL SECURITY;

-- 店舗管理者のみが席種を作成・編集・削除できるポリシー
CREATE POLICY seat_type_store_admin_all ON public.seat_types
  USING (store_id IN (
    SELECT store_id FROM public.store_users 
    WHERE user_id = auth.uid() AND role = 'admin'
  ));

-- 店舗スタッフは席種を閲覧のみ可能
CREATE POLICY seat_type_store_cast_select ON public.seat_types
  FOR SELECT
  USING (store_id IN (
    SELECT store_id FROM public.store_users 
    WHERE user_id = auth.uid()
  ));
</file>

<file path="supabase/migrations/20250501000000_add_store_settings.sql">
-- storesテーブルに設定カラムを追加
ALTER TABLE public.stores
ADD COLUMN enable_cast_management boolean NOT NULL DEFAULT true,
ADD COLUMN enable_smaregi_integration boolean NOT NULL DEFAULT true;

-- 既存の店舗データを更新
UPDATE public.stores
SET enable_cast_management = true,
    enable_smaregi_integration = true;

-- 新しいカラムに対するRLSポリシーを追加
CREATE POLICY "管理者のみ店舗設定を更新可能" ON public.stores
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND store_id = stores.store_id
      AND role = 'admin'
    )
  );
</file>

<file path="supabase/migrations/20250502000000_add_display_name_to_store_users.sql">
-- store_usersテーブルにdisplay_nameカラムを追加
ALTER TABLE public.store_users
ADD COLUMN display_name text;

-- 既存のキャストデータにはメールアドレスの@前の部分を名前として設定
UPDATE public.store_users su
SET display_name = (
  SELECT split_part(email, '@', 1)
  FROM auth.users
  WHERE id = su.user_id
)
WHERE role = 'cast';

-- RLSポリシーは既に正しく設定されているため、更新は不要
</file>

<file path="supabase/migrations/20250503000000_add_smaregi_keys.sql">
-- storesテーブルにスマレジ連携キーのカラムを追加
ALTER TABLE public.stores
ADD COLUMN smaregi_client_id text,
ADD COLUMN smaregi_client_secret text;

-- 既存のRLSポリシーは既に管理者のみが店舗設定を更新できるようになっているため、
-- 追加のポリシーは不要
</file>

<file path="supabase/migrations/20250504000000_add_smaregi_contract_id.sql">
-- storesテーブルにスマレジ契約IDのカラムを追加
ALTER TABLE public.stores
ADD COLUMN smaregi_contract_id text;

-- 既存のRLSポリシーは既に管理者のみが店舗設定を更新できるようになっているため、
-- 追加のポリシーは不要
</file>

<file path="supabase/migrations/20250601000000_add_menu_categories.sql">
-- メニューカテゴリテーブルの作成
CREATE TABLE IF NOT EXISTS public.menu_categories (
  category_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id UUID REFERENCES public.stores ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  display_order INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(store_id, name)
);

-- インデックスの作成
CREATE INDEX IF NOT EXISTS idx_menu_categories_store_id ON public.menu_categories(store_id);

-- RLSの有効化
ALTER TABLE public.menu_categories ENABLE ROW LEVEL SECURITY;

-- RLSポリシーの作成
-- 匿名ユーザーも閲覧可能
CREATE POLICY "メニューカテゴリ情報は誰でも閲覧可能" ON public.menu_categories
  FOR SELECT USING (true);

-- 自分が所属する店舗のメニューカテゴリ情報のみ編集可能
CREATE POLICY "自分が所属する店舗のメニューカテゴリ情報のみ編集可能" ON public.menu_categories
  FOR ALL USING (
    store_id IN (
      SELECT store_id FROM public.store_users WHERE user_id = auth.uid()
    )
  );

-- menusテーブルにcategory_idカラムを追加
ALTER TABLE public.menus ADD COLUMN category_id UUID REFERENCES public.menu_categories(category_id);

-- インデックスの作成
CREATE INDEX IF NOT EXISTS idx_menus_category_id ON public.menus(category_id);
</file>

<file path="supabase/migrations/20250601000001_migrate_menu_categories.sql">
-- 既存のカテゴリデータを新テーブルに移行するスクリプト

-- 一時的に各店舗ごとの一意なカテゴリ名を抽出して新テーブルに挿入
INSERT INTO public.menu_categories (store_id, name, display_order)
SELECT DISTINCT m.store_id, 
                COALESCE(m.category, '未分類') AS name, 
                ROW_NUMBER() OVER (PARTITION BY m.store_id ORDER BY MIN(m.created_at)) AS display_order
FROM public.menus m
GROUP BY m.store_id, COALESCE(m.category, '未分類');

-- 既存のメニューのcategory_idを更新
UPDATE public.menus m
SET category_id = mc.category_id
FROM public.menu_categories mc
WHERE m.store_id = mc.store_id 
AND COALESCE(m.category, '未分類') = mc.name;
</file>

<file path="supabase/migrations/20250602000000_remove_staff_drink.sql">
-- スタッフドリンク機能の削除

-- 依存関係のあるビューを先に削除
DROP VIEW IF EXISTS public.v_staff_drinks;

-- menusテーブルからis_staff_drinkカラムを削除
ALTER TABLE public.menus DROP COLUMN IF EXISTS is_staff_drink;

-- order_itemsテーブルからtarget_cast_idカラムを削除
ALTER TABLE public.order_items DROP COLUMN IF EXISTS target_cast_id;
</file>

<file path="supabase/migrations/20250603000000_add_smaregi_category_id.sql">
-- menu_categoriesテーブルにsmaregi_category_idカラムを追加
ALTER TABLE public.menu_categories ADD COLUMN IF NOT EXISTS smaregi_category_id TEXT;

-- smaregi_category_idにインデックスを作成
CREATE INDEX IF NOT EXISTS idx_menu_categories_smaregi_category_id ON public.menu_categories(smaregi_category_id);

-- store_idとsmaregi_category_idの組み合わせに一意制約を追加
ALTER TABLE public.menu_categories ADD CONSTRAINT unique_store_smaregi_category_id UNIQUE (store_id, smaregi_category_id) DEFERRABLE INITIALLY DEFERRED;
</file>

<file path="supabase/migrations/20250604000000_add_category_treat_cast_flag.sql">
-- menu_categoriesテーブルにallow_treat_castカラムを追加
ALTER TABLE public.menu_categories ADD COLUMN IF NOT EXISTS allow_treat_cast BOOLEAN NOT NULL DEFAULT false;

-- order_itemsテーブルにtarget_cast_idカラムを再追加（スタッフドリンク機能削除で削除されていた場合）
ALTER TABLE public.order_items ADD COLUMN IF NOT EXISTS target_cast_id UUID REFERENCES auth.users(id);
</file>

<file path="supabase/migrations/20250610000000_add_menu_images_bucket.sql">
-- メニュー画像用のストレージバケットを作成
INSERT INTO storage.buckets (id, name, public, avif_autodetection, file_size_limit, allowed_mime_types)
VALUES ('menu-images', 'menu-images', true, false, 5242880, '{image/jpeg,image/png,image/webp,image/gif}')
ON CONFLICT (id) DO NOTHING;

-- メニュー画像バケットのRLSポリシーを設定
-- 誰でも閲覧可能
CREATE POLICY "メニュー画像は誰でも閲覧可能" ON storage.objects
  FOR SELECT
  USING (bucket_id = 'menu-images');

-- 管理者のみアップロード可能
CREATE POLICY "管理者のみメニュー画像をアップロード可能" ON storage.objects
  FOR INSERT
  WITH CHECK (
    bucket_id = 'menu-images' AND
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- 管理者のみ更新可能
CREATE POLICY "管理者のみメニュー画像を更新可能" ON storage.objects
  FOR UPDATE
  USING (
    bucket_id = 'menu-images' AND
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- 管理者のみ削除可能
CREATE POLICY "管理者のみメニュー画像を削除可能" ON storage.objects
  FOR DELETE
  USING (
    bucket_id = 'menu-images' AND
    EXISTS (
      SELECT 1 FROM public.store_users
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );
</file>

<file path="supabase/migrations/20250701000000_add_status_to_order_items.sql">
-- order_itemsテーブルにstatusカラムを追加
ALTER TABLE public.order_items
ADD COLUMN status TEXT CHECK (status IN ('new', 'ack', 'prep', 'served', 'closed', 'cancel'));

-- 既存の注文アイテムのステータスを親注文のステータスに合わせる
UPDATE public.order_items oi
SET status = o.status
FROM public.orders o
WHERE oi.order_id = o.order_id;

-- statusカラムをNOT NULLに設定
ALTER TABLE public.order_items
ALTER COLUMN status SET NOT NULL;

-- インデックスを作成
CREATE INDEX IF NOT EXISTS idx_order_items_status ON public.order_items(status);
</file>

<file path="supabase/migrations/20250702000000_update_seat_types_code_to_uuid.sql">
-- UUID拡張機能が有効化されていることを確認
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 既存のデータを一時的に保存するための一時テーブルを作成
CREATE TEMP TABLE temp_seat_types AS
SELECT * FROM public.seat_types;

-- 既存のユニーク制約を削除
ALTER TABLE public.seat_types
DROP CONSTRAINT IF EXISTS seat_types_store_id_code_key;

-- codeカラムの型をUUIDに変更し、デフォルト値を設定
-- まず既存のcodeカラムを削除
ALTER TABLE public.seat_types
DROP COLUMN code;

-- 次にUUID型のcodeカラムを追加（sessionsテーブルと同様にgen_random_uuid()を使用）
ALTER TABLE public.seat_types
ADD COLUMN code UUID DEFAULT gen_random_uuid() NOT NULL;

-- 既存のデータを更新（既存のコードはそのまま保持できないため、新しいUUIDを生成）
UPDATE public.seat_types st
SET code = gen_random_uuid()
FROM temp_seat_types tt
WHERE st.seat_type_id = tt.seat_type_id;

-- 店舗IDとコードの組み合わせでユニーク制約を再設定
ALTER TABLE public.seat_types
ADD CONSTRAINT seat_types_store_id_code_key UNIQUE (store_id, code);

-- 一時テーブルを削除
DROP TABLE temp_seat_types;

-- データベース型定義の更新に関するコメント
COMMENT ON COLUMN public.seat_types.code IS 'システム内部で使用する一意のコード（UUID自動生成）';
</file>

<file path="supabase/migrations/20250703000003_recreate_seat_types_table.sql">
-- 席種テーブルを再作成するマイグレーション
-- 依存関係の問題を回避するため、テーブルを再作成する方法

-- 既存のデータを一時テーブルに保存
CREATE TEMP TABLE temp_seat_types AS
SELECT
  seat_type_id AS old_seat_type_id,
  code AS new_seat_type_id,
  store_id,
  display_name,
  price_per_30min,
  created_at
FROM public.seat_types;

-- 依存するビューを特定して削除
DO $$
DECLARE
  view_record RECORD;
BEGIN
  -- 依存するビューを検索して削除
  FOR view_record IN
    SELECT viewname, schemaname
    FROM pg_views
    WHERE schemaname = 'public'
  LOOP
    EXECUTE 'DROP VIEW IF EXISTS ' || view_record.schemaname || '.' || view_record.viewname || ' CASCADE';
    RAISE NOTICE 'Dropped view: %.%', view_record.schemaname, view_record.viewname;
  END LOOP;
END $$;

-- 依存するマテリアライズドビューを特定して削除
DO $$
DECLARE
  mview_record RECORD;
BEGIN
  -- 依存するマテリアライズドビューを検索して削除
  FOR mview_record IN
    SELECT matviewname, schemaname
    FROM pg_matviews
    WHERE schemaname = 'public'
  LOOP
    EXECUTE 'DROP MATERIALIZED VIEW IF EXISTS ' || mview_record.schemaname || '.' || mview_record.matviewname || ' CASCADE';
    RAISE NOTICE 'Dropped materialized view: %.%', mview_record.schemaname, mview_record.matviewname;
  END LOOP;
END $$;

-- 関連テーブルの外部キー制約を一時的に削除
ALTER TABLE public.tables DROP CONSTRAINT IF EXISTS tables_seat_type_id_fkey;
ALTER TABLE public.session_seat_events DROP CONSTRAINT IF EXISTS session_seat_events_seat_type_id_fkey;

-- 既存のRLSポリシーを削除
DROP POLICY IF EXISTS seat_type_store_admin_all ON public.seat_types;
DROP POLICY IF EXISTS seat_type_store_cast_select ON public.seat_types;

-- 新しい席種テーブルを作成（一時的な名前）
CREATE TABLE public.seat_types_new (
  seat_type_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id UUID REFERENCES public.stores(store_id) ON DELETE CASCADE NOT NULL,
  display_name TEXT NOT NULL,
  price_per_30min INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 店舗IDと席種IDの組み合わせでユニーク制約を設定
ALTER TABLE public.seat_types_new
ADD CONSTRAINT seat_types_new_store_id_seat_type_id_key UNIQUE (store_id, seat_type_id);

-- 既存のデータを新しいテーブルに移行
INSERT INTO public.seat_types_new (seat_type_id, store_id, display_name, price_per_30min, created_at)
SELECT
  new_seat_type_id AS seat_type_id,
  store_id,
  display_name,
  price_per_30min,
  created_at
FROM temp_seat_types;

-- 既存のテーブルデータをバックアップ
CREATE TEMP TABLE temp_tables AS
SELECT * FROM public.tables;

CREATE TEMP TABLE temp_session_seat_events AS
SELECT * FROM public.session_seat_events;

-- 関連テーブルを一時的に削除（依存関係を解消）
DROP TABLE IF EXISTS public.tables CASCADE;
DROP TABLE IF EXISTS public.session_seat_events CASCADE;

-- テーブルテーブルを再作成（seat_type_idをUUID型に変更）
CREATE TABLE public.tables (
  table_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  store_id UUID REFERENCES public.stores(store_id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  seat_type_id UUID NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- セッション席種イベントテーブルを再作成（seat_type_idをUUID型に変更）
CREATE TABLE public.session_seat_events (
  event_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES public.sessions(session_id) ON DELETE CASCADE NOT NULL,
  seat_type_id UUID NULL,
  price_snapshot INTEGER NOT NULL,
  changed_at TIMESTAMPTZ DEFAULT now(),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 古いテーブルを削除し、新しいテーブルをリネーム
DROP TABLE public.seat_types CASCADE;
ALTER TABLE public.seat_types_new RENAME TO seat_types;

-- テーブルデータを復元
INSERT INTO public.tables (table_id, store_id, name, seat_type_id, created_at)
SELECT
  tt.table_id,
  tt.store_id,
  tt.name,
  ts.new_seat_type_id,
  tt.created_at
FROM temp_tables tt
LEFT JOIN temp_seat_types ts ON tt.seat_type_id::text = ts.old_seat_type_id::text;

-- セッション席種イベントデータを復元
INSERT INTO public.session_seat_events (event_id, session_id, seat_type_id, price_snapshot, changed_at, created_at)
SELECT
  tsse.event_id,
  tsse.session_id,
  ts.new_seat_type_id,
  tsse.price_snapshot,
  tsse.changed_at,
  tsse.created_at
FROM temp_session_seat_events tsse
LEFT JOIN temp_seat_types ts ON tsse.seat_type_id::text = ts.old_seat_type_id::text;

-- 外部キー制約を再作成
ALTER TABLE public.tables
ADD CONSTRAINT tables_seat_type_id_fkey
FOREIGN KEY (seat_type_id) REFERENCES public.seat_types(seat_type_id);

ALTER TABLE public.session_seat_events
ADD CONSTRAINT session_seat_events_seat_type_id_fkey
FOREIGN KEY (seat_type_id) REFERENCES public.seat_types(seat_type_id);

-- RLSポリシーの再作成
ALTER TABLE public.seat_types ENABLE ROW LEVEL SECURITY;

-- 店舗管理者のみが席種を作成・編集・削除できるポリシー
CREATE POLICY seat_type_store_admin_all ON public.seat_types
  USING (store_id IN (
    SELECT store_id FROM public.store_users
    WHERE user_id = auth.uid() AND role = 'admin'
  ));

-- 店舗スタッフは席種を閲覧のみ可能
CREATE POLICY seat_type_store_cast_select ON public.seat_types
  FOR SELECT
  USING (store_id IN (
    SELECT store_id FROM public.store_users
    WHERE user_id = auth.uid()
  ));

-- 一時テーブルを削除
DROP TABLE temp_seat_types;

-- データベース型定義の更新に関するコメント
COMMENT ON COLUMN public.seat_types.seat_type_id IS 'システム内部で使用する一意のID（UUID自動生成）';
</file>

<file path="supabase/migrations/20250703000004_fix_sessions_foreign_key.sql">
-- sessionsテーブルの外部キー制約を再作成するマイグレーション

-- sessionsテーブルのtable_idの外部キー制約を再作成
ALTER TABLE public.sessions
DROP CONSTRAINT IF EXISTS sessions_table_id_fkey;

ALTER TABLE public.sessions
ADD CONSTRAINT sessions_table_id_fkey
FOREIGN KEY (table_id) REFERENCES public.tables(table_id) ON DELETE CASCADE;

-- 関連するトリガー関数を更新
CREATE OR REPLACE FUNCTION public.fn_create_session_seat_snapshot()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- チャージ開始時に席種スナップショットを作成
  IF NEW.charge_started_at IS NOT NULL AND (OLD.charge_started_at IS NULL OR OLD.charge_started_at <> NEW.charge_started_at) THEN
    INSERT INTO public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    SELECT
      NEW.session_id,
      t.seat_type_id,
      st.price_per_30min,
      NEW.charge_started_at
    FROM
      public.tables t
      JOIN public.seat_types st ON t.seat_type_id = st.seat_type_id
    WHERE
      t.table_id = NEW.table_id;
  END IF;
  
  RETURN NEW;
END;
$$;

-- テーブルの席種変更時にセッション席種スナップショットを作成する関数
CREATE OR REPLACE FUNCTION public.fn_create_table_seat_change_snapshot()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 席種が変更された場合
  IF NEW.seat_type_id <> OLD.seat_type_id THEN
    -- アクティブなセッションがあれば席種スナップショットを作成
    INSERT INTO public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    SELECT
      s.session_id,
      NEW.seat_type_id,
      st.price_per_30min,
      NOW()
    FROM
      public.sessions s
      JOIN public.seat_types st ON st.seat_type_id = NEW.seat_type_id
    WHERE
      s.table_id = NEW.table_id
      AND s.charge_started_at IS NOT NULL;
  END IF;
  
  RETURN NEW;
END;
$$;

-- テーブル更新時のトリガーを再作成
DROP TRIGGER IF EXISTS trg_table_update ON public.tables;

CREATE TRIGGER trg_table_update
AFTER UPDATE ON public.tables
FOR EACH ROW
EXECUTE FUNCTION public.fn_create_table_seat_change_snapshot();
</file>

<file path="supabase/migrations/20250704000000_add_time_unit_minutes_to_seat_types.sql">
-- Add time_unit_minutes column to seat_types table
ALTER TABLE seat_types ADD COLUMN IF NOT EXISTS time_unit_minutes INTEGER DEFAULT 30 NOT NULL;

-- Update existing records to have the default value
UPDATE seat_types SET time_unit_minutes = 30 WHERE time_unit_minutes IS NULL;
</file>

<file path="supabase/migrations/20250705000000_rename_price_per_30min_to_price_per_unit.sql">
-- Rename price_per_30min column to price_per_unit
ALTER TABLE seat_types RENAME COLUMN price_per_30min TO price_per_unit;
</file>

<file path="supabase/migrations/20250706000000_update_charge_functions.sql">
-- チャージ計算用の関数を更新（price_per_30minをprice_per_unitに変更）
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_half_hour_units int;
  v_event_charge int;
BEGIN
  -- セッションの開始時間を取得
  SELECT charge_started_at INTO v_charge_start_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 30分単位で切り上げ
    v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / 30) * 30;
    
    -- 30分単位の数を計算
    v_half_hour_units := v_rounded_minutes / 30;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_half_hour_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 30分単位で切り上げ
  v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / 30) * 30;
  
  -- 30分単位の数を計算
  v_half_hour_units := v_rounded_minutes / 30;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_half_hour_units * (
    SELECT price_snapshot 
    FROM public.session_seat_events 
    WHERE session_id = p_session_id 
    ORDER BY changed_at DESC 
    LIMIT 1
  );
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- セッション開始時に席種スナップショットを作成する関数を更新
CREATE OR REPLACE FUNCTION public.fn_create_session_seat_snapshot()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- チャージ開始時に席種スナップショットを作成
  IF NEW.charge_started_at IS NOT NULL AND (OLD.charge_started_at IS NULL OR OLD.charge_started_at <> NEW.charge_started_at) THEN
    INSERT INTO public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    SELECT
      NEW.session_id,
      t.seat_type_id,
      st.price_per_unit,
      NEW.charge_started_at
    FROM
      public.tables t
      JOIN public.seat_types st ON t.seat_type_id = st.seat_type_id
    WHERE
      t.table_id = NEW.table_id;
  END IF;
  
  RETURN NEW;
END;
$$;

-- テーブルの席種変更時にセッション席種スナップショットを作成する関数を更新
CREATE OR REPLACE FUNCTION public.fn_create_table_seat_change_snapshot()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 席種が変更された場合
  IF NEW.seat_type_id <> OLD.seat_type_id THEN
    -- アクティブなセッションがあれば席種スナップショットを作成
    INSERT INTO public.session_seat_events (
      session_id,
      seat_type_id,
      price_snapshot,
      changed_at
    )
    SELECT
      s.session_id,
      NEW.seat_type_id,
      st.price_per_unit,
      NOW()
    FROM
      public.sessions s
      JOIN public.seat_types st ON st.seat_type_id = NEW.seat_type_id
    WHERE
      s.table_id = NEW.table_id
      AND s.charge_started_at IS NOT NULL;
  END IF;
  
  RETURN NEW;
END;
$$;
</file>

<file path="supabase/migrations/20250707000000_update_charge_functions_time_unit.sql">
-- チャージ計算用の関数を更新（time_unit_minutesを参照するように変更）
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
BEGIN
  -- セッションの開始時間を取得
  SELECT charge_started_at INTO v_charge_start_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを保存
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 時間単位で切り上げ
    v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントがない場合は開始時間から現在までを計算
  IF v_last_event_time IS NULL THEN
    v_last_event_time := v_charge_start_time;
    
    -- 最新のセッション席種イベントから席種IDを取得
    SELECT seat_type_id INTO v_seat_type_id
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
    
    -- セッション席種イベントがない場合はテーブルから席種IDを取得
    IF v_seat_type_id IS NULL THEN
      SELECT t.seat_type_id INTO v_seat_type_id
      FROM public.sessions s
      JOIN public.tables t ON s.table_id = t.table_id
      WHERE s.session_id = p_session_id;
    END IF;
  ELSE
    -- 最新のセッション席種イベントから席種IDを取得
    SELECT seat_type_id INTO v_seat_type_id
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 時間単位で切り上げ
  v_rounded_minutes := ceiling(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * (
    SELECT price_snapshot 
    FROM public.session_seat_events 
    WHERE session_id = p_session_id 
    ORDER BY changed_at DESC 
    LIMIT 1
  );
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;
</file>

<file path="supabase/migrations/20250707000001_update_table_usage_view.sql">
-- テーブル利用状況ビューを更新（time_unit_minutesを参照するように変更）
CREATE OR REPLACE VIEW public.v_table_usage AS
SELECT
  s.store_id,
  st.name AS store_name,
  t.table_id,
  t.name AS table_name,
  st2.display_name AS seat_type,
  st2.price_per_unit,
  st2.time_unit_minutes,
  s.session_id,
  s.start_at,
  s.charge_started_at,
  CASE
    WHEN s.charge_started_at IS NOT NULL THEN
      EXTRACT(epoch FROM (now() - s.charge_started_at)) / 60
    ELSE
      0
  END AS elapsed_minutes,
  CASE
    WHEN s.charge_started_at IS NOT NULL THEN
      CEILING(EXTRACT(epoch FROM (now() - s.charge_started_at)) / 60 / st2.time_unit_minutes) * st2.time_unit_minutes
    ELSE
      0
  END AS rounded_minutes,
  CASE
    WHEN s.charge_started_at IS NOT NULL THEN
      CEILING(EXTRACT(epoch FROM (now() - s.charge_started_at)) / 60 / st2.time_unit_minutes) * st2.price_per_unit
    ELSE
      0
  END AS current_charge
FROM
  public.sessions s
  JOIN public.tables t ON s.table_id = t.table_id
  JOIN public.stores st ON s.store_id = st.store_id
  JOIN public.seat_types st2 ON t.seat_type_id = st2.seat_type_id
WHERE
  s.charge_started_at IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM public.checkouts c
    WHERE c.session_id = s.session_id AND c.status = 'completed'
  );
</file>

<file path="supabase/migrations/20250708000000_update_sessions_table.sql">
-- sessionsテーブルに新しいフィールドを追加
ALTER TABLE public.sessions ADD COLUMN IF NOT EXISTS selected_cast_id UUID REFERENCES auth.users(id);
ALTER TABLE public.sessions ADD COLUMN IF NOT EXISTS is_new_customer BOOLEAN;
</file>

<file path="supabase/migrations/20250801000000_add_charge_pause.sql">
-- sessionsテーブルにcharge_paused_atフィールドを追加
ALTER TABLE public.sessions ADD COLUMN IF NOT EXISTS charge_paused_at TIMESTAMPTZ;

-- チャージ計算用の関数を更新（charge_paused_atを考慮）
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 一時停止中の場合、計算終了時間を一時停止時間にする
    IF v_charge_pause_time IS NOT NULL AND v_charge_pause_time > v_last_event_time AND v_charge_pause_time < v_event.changed_at THEN
      -- イベント間の経過時間を計算（分単位）- 一時停止時間まで
      v_elapsed_minutes := EXTRACT(epoch FROM (v_charge_pause_time - v_last_event_time)) / 60;
    ELSE
      -- イベント間の経過時間を計算（分単位）
      v_elapsed_minutes := EXTRACT(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    END IF;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_event.seat_type_id;
    
    -- 時間単位が設定されていない場合はデフォルト値（30分）を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間を設定
    v_last_event_time := v_event.changed_at;
    
    -- 一時停止中の場合、それ以降の計算は行わない
    IF v_charge_pause_time IS NOT NULL AND v_charge_pause_time <= v_event.changed_at THEN
      RETURN v_total_charge;
    END IF;
  END LOOP;
  
  -- 最後のイベントから現在（または一時停止時間）までの経過時間を計算
  IF v_last_event_time IS NULL THEN
    -- イベントがない場合は開始時間から計算
    v_last_event_time := v_charge_start_time;
  END IF;
  
  -- 最後の席種IDを取得
  SELECT seat_type_id INTO v_seat_type_id
  FROM public.session_seat_events
  WHERE session_id = p_session_id
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が設定されていない場合はデフォルト値（30分）を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 一時停止中の場合、計算終了時間を一時停止時間にする
  IF v_charge_pause_time IS NOT NULL THEN
    -- 一時停止時間が最後のイベント時間より前の場合は計算しない
    IF v_charge_pause_time <= v_last_event_time THEN
      RETURN v_total_charge;
    END IF;
    
    -- 最後のイベントから一時停止時間までの経過時間を計算（分単位）
    v_elapsed_minutes := EXTRACT(epoch FROM (v_charge_pause_time - v_last_event_time)) / 60;
  ELSE
    -- 最後のイベントから現在までの経過時間を計算（分単位）
    v_elapsed_minutes := EXTRACT(epoch FROM (v_current_time - v_last_event_time)) / 60;
  END IF;
  
  -- 時間単位で切り上げ
  v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * (
    SELECT price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1
  );
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;
</file>

<file path="supabase/migrations/20250802000000_add_table_move_charge.sql">
-- session_seat_eventsテーブルにis_table_move_chargeフィールドを追加（存在しない場合のみ）
DO $$
BEGIN
  -- カラムが存在しない場合のみ追加
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'session_seat_events'
    AND column_name = 'is_table_move_charge'
  ) THEN
    ALTER TABLE public.session_seat_events
    ADD COLUMN is_table_move_charge boolean DEFAULT false;

    -- 既存のレコードはfalseに設定
    UPDATE public.session_seat_events
    SET is_table_move_charge = false
    WHERE is_table_move_charge IS NULL;
  END IF;
END $$;

-- fn_calc_total_charge関数を更新して、is_table_move_chargeフィールドを考慮するように変更
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;

  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;

  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;

  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;

    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;

    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;

    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;

    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;

    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;

    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;

    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;

    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;

    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;

    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;

  -- 最後のイベントから現在までの料金を計算（席移動による料金記録かどうかに関わらず）
  IF v_last_event_time IS NOT NULL THEN
    -- 最後のイベントの情報を取得
    SELECT
      seat_type_id,
      price_snapshot,
      is_table_move_charge
    INTO
      v_seat_type_id,
      v_event.price_snapshot,
      v_event.is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;

    -- 席移動による料金記録の場合は、次のイベント（移動先テーブルの席種情報）を取得
    IF v_event.is_table_move_charge THEN
      -- 席移動料金イベントの次のイベント（移動先テーブルの席種情報）を取得
      SELECT
        seat_type_id,
        price_snapshot
      INTO
        v_seat_type_id,
        v_event.price_snapshot
      FROM public.session_seat_events
      WHERE
        session_id = p_session_id AND
        changed_at > v_last_event_time
      ORDER BY changed_at ASC
      LIMIT 1;
    END IF;

    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;

    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;

    -- 最後のイベントから現在までの経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;

    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;

    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;

    -- 最後の区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;

    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
  END IF;

  RETURN v_total_charge;
END;
$$;
</file>

<file path="supabase/migrations/20250803000000_fix_table_move_charge_calculation.sql">
-- テーブル移動後の料金計算を修正するマイグレーション

-- fn_calc_total_charge関数を更新して、席移動後も時間毎に料金が加算されるように修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes int;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントから現在までの料金を計算（席移動による料金記録かどうかに関わらず）
  IF v_last_event_time IS NOT NULL THEN
    -- 最後のイベントの情報を取得
    SELECT 
      seat_type_id,
      price_snapshot,
      is_table_move_charge
    INTO 
      v_seat_type_id,
      v_event.price_snapshot,
      v_event.is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
    
    -- 席移動による料金記録の場合は、次のイベント（移動先テーブルの席種情報）を取得
    IF v_event.is_table_move_charge THEN
      -- 席移動料金イベントの次のイベント（移動先テーブルの席種情報）を取得
      SELECT 
        seat_type_id,
        price_snapshot
      INTO 
        v_seat_type_id,
        v_event.price_snapshot
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_event_time
      ORDER BY changed_at ASC
      LIMIT 1;
    END IF;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- 最後のイベントから現在までの経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
    
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 最後の区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
  END IF;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS '席移動後も時間毎に料金が加算されるように修正（2025/08/03）';
</file>

<file path="supabase/migrations/20250804000000_fix_charge_calculation_for_short_time.sql">
-- 短時間（1分未満）の場合でもテーブル料金が0円にならないように修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    END IF;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントがない場合は開始時間を使用
  IF v_last_event_time IS NULL THEN
    v_last_event_time := v_charge_start_time;
    
    -- 最後のセッションの席種IDを取得
    SELECT t.seat_type_id INTO v_seat_type_id
    FROM public.sessions s
    JOIN public.tables t ON s.table_id = t.table_id
    WHERE s.session_id = p_session_id;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * (
    SELECT price_snapshot 
    FROM public.session_seat_events 
    WHERE session_id = p_session_id 
    ORDER BY changed_at DESC 
    LIMIT 1
  );
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS '短時間（1分未満）の場合でもテーブル料金が0円にならないように修正（2025/08/04）';
</file>

<file path="supabase/migrations/20250805000000_fix_table_move_charge_calculation.sql">
-- テーブル移動時の料金計算が重複して加算される問題を修正
-- fn_calc_total_charge関数は既に修正済みのため、変更なし

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動時の料金計算が重複して加算される問題を修正（2025/08/05）';
</file>

<file path="supabase/migrations/20250806000000_fix_double_charge_calculation.sql">
-- 0分の時点で二重に料金が計算される問題を修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    END IF;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントがない場合は開始時間を使用
  IF v_last_event_time IS NULL THEN
    v_last_event_time := v_charge_start_time;
    
    -- 最後のセッションの席種IDを取得
    SELECT t.seat_type_id INTO v_seat_type_id
    FROM public.sessions s
    JOIN public.tables t ON s.table_id = t.table_id
    WHERE s.session_id = p_session_id;
    
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  ELSE
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 重要な修正: 開始直後（0分）の場合は、最低料金を1回だけ適用する
  -- 開始時間と最後のイベント時間が同じ（つまり、まだイベントが発生していない）場合
  IF v_charge_start_time = v_last_event_time THEN
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
      v_time_units := 1;
      v_event_charge := v_time_units * v_price_snapshot;
      RETURN v_event_charge; -- 最低料金のみを返す（他のイベントはまだない）
    END IF;
  END IF;
  
  -- 通常の計算（開始直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS '0分の時点で二重に料金が計算される問題を修正（2025/08/06）';
</file>

<file path="supabase/migrations/20250807000000_fix_table_move_zero_minute_charge.sql">
-- テーブル移動時の0分時点での料金計算問題を修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 席移動直後（0分）のイベントの場合は、料金を計算しない
    -- 席移動料金イベントの直後のイベントで、経過時間が1分未満の場合
    IF v_has_move_charge AND v_last_event_time = v_last_move_charge_time AND v_elapsed_minutes < 1 THEN
      -- 次のイベントの開始時間として現在のイベント時間を設定し、料金は加算しない
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    END IF;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントがない場合は開始時間を使用
  IF v_last_event_time IS NULL THEN
    v_last_event_time := v_charge_start_time;
    
    -- 最後のセッションの席種IDを取得
    SELECT t.seat_type_id INTO v_seat_type_id
    FROM public.sessions s
    JOIN public.tables t ON s.table_id = t.table_id
    WHERE s.session_id = p_session_id;
    
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  ELSE
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合は、料金を計算しない
  -- 最後のイベントが席移動料金イベントで、経過時間が1分未満の場合
  IF v_has_move_charge AND v_last_event_time = v_last_move_charge_time AND v_elapsed_minutes < 1 THEN
    RETURN v_total_charge; -- 席移動料金のみを返す
  END IF;
  
  -- 重要な修正: 開始直後（0分）の場合は、最低料金を1回だけ適用する
  -- 開始時間と最後のイベント時間が同じ（つまり、まだイベントが発生していない）場合
  IF v_charge_start_time = v_last_event_time THEN
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
      v_time_units := 1;
      v_event_charge := v_time_units * v_price_snapshot;
      RETURN v_event_charge; -- 最低料金のみを返す（他のイベントはまだない）
    END IF;
  END IF;
  
  -- 通常の計算（開始直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動時の0分時点での料金計算問題を修正（2025/08/07）';
</file>

<file path="supabase/migrations/20250808000000_fix_table_move_immediate_charge.sql">
-- テーブル移動直後（0分時点）の料金計算問題を修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT charge_started_at, charge_paused_at INTO v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後の最初のイベント（移動先テーブルの席種情報）を取得
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    INTO v_next_event_after_move
    FROM public.session_seat_events
    WHERE 
      session_id = p_session_id AND 
      changed_at > v_last_move_charge_time
    ORDER BY changed_at ASC
    LIMIT 1;
  END IF;
  
  -- セッション席種イベントを時系列順に取得
  FOR v_event IN (
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at ASC
  ) LOOP
    -- 席移動による料金記録の場合は、そのまま合計に加算
    IF v_event.is_table_move_charge THEN
      v_total_charge := v_total_charge + v_event.price_snapshot;
      -- 次のイベントの開始時間として現在のイベント時間を設定
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 最初のイベントの場合
    IF v_last_event_time IS NULL THEN
      v_last_event_time := v_charge_start_time;
    END IF;
    
    -- 席種IDを取得
    v_seat_type_id := v_event.seat_type_id;
    
    -- 席種の時間単位を取得
    SELECT time_unit_minutes INTO v_time_unit_minutes
    FROM public.seat_types
    WHERE seat_type_id = v_seat_type_id;
    
    -- 時間単位が無効な場合はデフォルトの30分を使用
    IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
      v_time_unit_minutes := 30;
    END IF;
    
    -- イベント間の経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_event.changed_at - v_last_event_time)) / 60;
    
    -- 席移動直後（0分）のイベントの場合は、料金を計算しない
    -- 席移動料金イベントの直後のイベントで、経過時間が1分未満の場合
    IF v_has_move_charge AND v_last_event_time = v_last_move_charge_time AND v_elapsed_minutes < 1 THEN
      -- 次のイベントの開始時間として現在のイベント時間を設定し、料金は加算しない
      v_last_event_time := v_event.changed_at;
      CONTINUE;
    END IF;
    
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
    END IF;
    
    -- 時間単位の数を計算
    v_time_units := v_rounded_minutes / v_time_unit_minutes;
    
    -- 区間のチャージ金額を計算
    v_event_charge := v_time_units * v_event.price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- 次のイベントの開始時間として現在のイベント時間を設定
    v_last_event_time := v_event.changed_at;
  END LOOP;
  
  -- 最後のイベントがない場合は開始時間を使用
  IF v_last_event_time IS NULL THEN
    v_last_event_time := v_charge_start_time;
    
    -- 最後のセッションの席種IDを取得
    SELECT t.seat_type_id INTO v_seat_type_id
    FROM public.sessions s
    JOIN public.tables t ON s.table_id = t.table_id
    WHERE s.session_id = p_session_id;
    
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  ELSE
    -- 最後のセッションの価格スナップショットを取得
    SELECT price_snapshot INTO v_price_snapshot
    FROM public.session_seat_events
    WHERE session_id = p_session_id
    ORDER BY changed_at DESC
    LIMIT 1;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合は、移動先テーブルの料金を計算しない
  -- 最後のイベントが席移動後のイベントで、経過時間が1分未満の場合
  IF v_has_move_charge AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at AND v_elapsed_minutes < 1 THEN
    RETURN v_total_charge; -- 席移動料金のみを返す（移動先テーブルの料金は加算しない）
  END IF;
  
  -- 重要な修正: 開始直後（0分）の場合は、最低料金を1回だけ適用する
  -- 開始時間と最後のイベント時間が同じ（つまり、まだイベントが発生していない）場合
  IF v_charge_start_time = v_last_event_time THEN
    -- 1分未満の場合は時間単位として扱う（最低料金）
    IF v_elapsed_minutes < 1 THEN
      v_rounded_minutes := v_time_unit_minutes;
      v_time_units := 1;
      v_event_charge := v_time_units * v_price_snapshot;
      RETURN v_event_charge; -- 最低料金のみを返す（他のイベントはまだない）
    END IF;
  END IF;
  
  -- 通常の計算（開始直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動直後（0分時点）の料金計算問題を修正（2025/08/08）';
</file>

<file path="supabase/migrations/20250809000000_fix_table_move_charge_calculation_final.sql">
-- テーブル移動時の料金計算問題を最終的に修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record;
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後の最初のイベント（移動先テーブルの席種情報）を取得
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    INTO v_next_event_after_move
    FROM public.session_seat_events
    WHERE 
      session_id = p_session_id AND 
      changed_at > v_last_move_charge_time AND
      is_table_move_charge = false
    ORDER BY changed_at ASC
    LIMIT 1;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席移動直後（0分）の場合は、移動先テーブルの料金を計算しない
  IF v_has_move_charge AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    -- 最後のイベントから現在までの経過時間を計算（分単位）
    v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
    
    -- 1分未満の場合は、移動先テーブルの料金を加算しない
    IF v_elapsed_minutes < 1 THEN
      RETURN v_total_charge; -- 席移動料金のみを返す
    END IF;
  END IF;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動時の料金計算問題を最終的に修正（2025/08/09）';
</file>

<file path="supabase/migrations/20250810000000_fix_table_move_minimum_charge.sql">
-- テーブル移動時の最低料金計算を修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record;
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後の最初のイベント（移動先テーブルの席種情報）を取得
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    INTO v_next_event_after_move
    FROM public.session_seat_events
    WHERE 
      session_id = p_session_id AND 
      changed_at > v_last_move_charge_time AND
      is_table_move_charge = false
    ORDER BY changed_at ASC
    LIMIT 1;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  IF v_has_move_charge AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    -- 最低料金を適用（1単位分）
    v_event_charge := v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動時の最低料金計算を修正（2025/08/10）';
</file>

<file path="supabase/migrations/20250811000000_fix_table_move_time_progression.sql">
-- テーブル移動後の時間経過に伴う料金計算を修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record;
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、現在時刻を一時停止時間に設定
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後の最初のイベント（移動先テーブルの席種情報）を取得
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    INTO v_next_event_after_move
    FROM public.session_seat_events
    WHERE 
      session_id = p_session_id AND 
      changed_at > v_last_move_charge_time AND
      is_table_move_charge = false
    ORDER BY changed_at ASC
    LIMIT 1;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 経過時間をログに出力（デバッグ用）
  RAISE NOTICE 'Elapsed minutes: %, Current time: %, Last event time: %', 
    v_elapsed_minutes, v_current_time, v_last_event_time;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  IF v_has_move_charge AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    -- デバッグ情報
    RAISE NOTICE 'Table move case: time_units=%, price_snapshot=%, event_charge=%, total_charge=%', 
      v_time_units, v_price_snapshot, v_event_charge, v_total_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- デバッグ情報
  RAISE NOTICE 'Normal case: time_units=%, price_snapshot=%, event_charge=%, total_charge=%', 
    v_time_units, v_price_snapshot, v_event_charge, v_total_charge;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動後の時間経過に伴う料金計算を修正（2025/08/11）';
</file>

<file path="supabase/migrations/20250812000000_fix_next_event_after_move_null.sql">
-- テーブル移動後のイベントが存在しない場合のエラーを修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record;
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、一時停止時間を現在時刻として扱う
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後の最初のイベント（移動先テーブルの席種情報）を取得
    SELECT 
      event_id,
      seat_type_id,
      price_snapshot,
      changed_at,
      is_table_move_charge
    INTO v_next_event_after_move
    FROM public.session_seat_events
    WHERE 
      session_id = p_session_id AND 
      changed_at > v_last_move_charge_time AND
      is_table_move_charge = false
    ORDER BY changed_at ASC
    LIMIT 1;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  -- v_next_event_after_moveがNULLの場合のチェックを追加
  IF v_has_move_charge AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動後のイベントが存在しない場合のエラーを修正（2025/08/12）';
</file>

<file path="supabase/migrations/20250813000000_fix_next_event_after_move_null_robust.sql">
-- テーブル移動後のイベントが存在しない場合のエラーを修正（より堅牢な実装）
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record := NULL; -- 明示的にNULLで初期化
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
  v_has_next_event boolean := false; -- 次のイベントが存在するかのフラグ
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、一時停止時間を現在時刻として扱う
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 席移動後の最初のイベントを取得する前に、そのようなイベントが存在するか確認
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後のイベントが存在するか確認
    SELECT EXISTS (
      SELECT 1
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
    ) INTO v_has_next_event;
    
    -- 席移動後のイベントが存在する場合のみ取得
    IF v_has_next_event THEN
      SELECT 
        event_id,
        seat_type_id,
        price_snapshot,
        changed_at,
        is_table_move_charge
      INTO v_next_event_after_move
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
      ORDER BY changed_at ASC
      LIMIT 1;
    END IF;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  -- v_next_event_after_moveがNULLでないことを確認
  IF v_has_move_charge AND v_has_next_event AND v_next_event_after_move IS NOT NULL AND 
     v_last_event_time = v_next_event_after_move.changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動後のイベントが存在しない場合のエラーを修正（より堅牢な実装）（2025/08/13）';
</file>

<file path="supabase/migrations/20250814000000_fix_next_event_after_move_property_access.sql">
-- テーブル移動後のイベントのプロパティアクセスエラーを修正
CREATE OR REPLACE FUNCTION public.fn_calc_total_charge(p_session_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_charge int := 0;
  v_current_time timestamptz := now();
  v_charge_start_time timestamptz;
  v_charge_pause_time timestamptz;
  v_last_event_time timestamptz;
  v_event record;
  v_elapsed_minutes numeric;
  v_rounded_minutes int;
  v_time_units int;
  v_event_charge int;
  v_time_unit_minutes int;
  v_seat_type_id uuid;
  v_price_snapshot int;
  v_last_move_charge_time timestamptz;
  v_has_move_charge boolean := false;
  v_next_event_after_move record := NULL; -- 明示的にNULLで初期化
  v_move_charge_count int := 0;
  v_session_start_time timestamptz;
  v_has_next_event boolean := false; -- 次のイベントが存在するかのフラグ
  v_next_event_changed_at timestamptz := NULL; -- 次のイベントの時間を別変数で保持
BEGIN
  -- セッションの開始時間と一時停止時間を取得
  SELECT start_at, charge_started_at, charge_paused_at 
  INTO v_session_start_time, v_charge_start_time, v_charge_pause_time
  FROM public.sessions
  WHERE session_id = p_session_id;
  
  -- チャージ開始時間が設定されていない場合は0を返す
  IF v_charge_start_time IS NULL THEN
    RETURN 0;
  END IF;
  
  -- 一時停止中の場合は、一時停止時間を現在時刻として扱う
  IF v_charge_pause_time IS NOT NULL THEN
    v_current_time := v_charge_pause_time;
  END IF;
  
  -- 席移動料金イベントの数を取得
  SELECT COUNT(*) INTO v_move_charge_count
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後の席移動料金イベントの時間を取得（存在する場合）
  SELECT MAX(changed_at) INTO v_last_move_charge_time
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 席移動後の最初のイベントを取得する前に、そのようなイベントが存在するか確認
  IF v_last_move_charge_time IS NOT NULL THEN
    v_has_move_charge := true;
    
    -- 席移動後のイベントが存在するか確認
    SELECT EXISTS (
      SELECT 1
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
    ) INTO v_has_next_event;
    
    -- 席移動後のイベントが存在する場合のみ取得
    IF v_has_next_event THEN
      SELECT 
        event_id,
        seat_type_id,
        price_snapshot,
        changed_at,
        is_table_move_charge
      INTO v_next_event_after_move
      FROM public.session_seat_events
      WHERE 
        session_id = p_session_id AND 
        changed_at > v_last_move_charge_time AND
        is_table_move_charge = false
      ORDER BY changed_at ASC
      LIMIT 1;
      
      -- 次のイベントの時間を別変数に保存（NULLチェックを避けるため）
      IF v_next_event_after_move IS NOT NULL THEN
        v_next_event_changed_at := v_next_event_after_move.changed_at;
      END IF;
    END IF;
  END IF;
  
  -- 席移動料金のみを合計に加算
  SELECT COALESCE(SUM(price_snapshot), 0) INTO v_total_charge
  FROM public.session_seat_events
  WHERE session_id = p_session_id AND is_table_move_charge = true;
  
  -- 最後のイベントの情報を取得（席移動料金イベントを除く）
  SELECT 
    seat_type_id,
    price_snapshot,
    changed_at
  INTO 
    v_seat_type_id,
    v_price_snapshot,
    v_last_event_time
  FROM public.session_seat_events
  WHERE 
    session_id = p_session_id AND 
    is_table_move_charge = false
  ORDER BY changed_at DESC
  LIMIT 1;
  
  -- 席種の時間単位を取得
  SELECT time_unit_minutes INTO v_time_unit_minutes
  FROM public.seat_types
  WHERE seat_type_id = v_seat_type_id;
  
  -- 時間単位が無効な場合はデフォルトの30分を使用
  IF v_time_unit_minutes IS NULL OR v_time_unit_minutes <= 0 THEN
    v_time_unit_minutes := 30;
  END IF;
  
  -- 最後のイベントから現在までの経過時間を計算（分単位）
  v_elapsed_minutes := extract(epoch FROM (v_current_time - v_last_event_time)) / 60;
  
  -- 席移動直後（0分）の場合でも、移動先テーブルの最低料金を適用
  -- v_next_event_after_moveのプロパティにアクセスする前にNULLチェックを行う
  -- v_next_event_changed_atを使用して比較
  IF v_has_move_charge AND v_has_next_event AND v_next_event_after_move IS NOT NULL AND 
     v_next_event_changed_at IS NOT NULL AND v_last_event_time = v_next_event_changed_at THEN
    
    -- 経過時間に基づいて料金を計算
    -- 1分未満の場合は最低料金（1単位分）
    IF v_elapsed_minutes < 1 THEN
      v_time_units := 1;
    ELSE
      -- 時間単位で切り上げ
      v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
      -- 時間単位の数を計算
      v_time_units := v_rounded_minutes / v_time_unit_minutes;
    END IF;
    
    -- 移動先テーブルでの料金を計算
    v_event_charge := v_time_units * v_price_snapshot;
    
    -- 合計に加算
    v_total_charge := v_total_charge + v_event_charge;
    
    RETURN v_total_charge;
  END IF;
  
  -- 通常の計算（席移動直後でない場合）
  -- 1分未満の場合は時間単位として扱う（最低料金）
  IF v_elapsed_minutes < 1 THEN
    v_rounded_minutes := v_time_unit_minutes;
  ELSE
    -- 時間単位で切り上げ
    v_rounded_minutes := CEILING(v_elapsed_minutes::numeric / v_time_unit_minutes) * v_time_unit_minutes;
  END IF;
  
  -- 時間単位の数を計算
  v_time_units := v_rounded_minutes / v_time_unit_minutes;
  
  -- 最後の区間のチャージ金額を計算
  v_event_charge := v_time_units * v_price_snapshot;
  
  -- 合計に加算
  v_total_charge := v_total_charge + v_event_charge;
  
  RETURN v_total_charge;
END;
$$;

-- コメント追加
COMMENT ON FUNCTION public.fn_calc_total_charge(uuid) IS 'テーブル移動後のイベントのプロパティアクセスエラーを修正（2025/08/14）';
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      animation: {
        'fade-in-out': 'fadeInOut 1s ease-in-out',
      },
      keyframes: {
        fadeInOut: {
          '0%': { opacity: 0 },
          '10%': { opacity: 1 },
          '90%': { opacity: 1 },
          '100%': { opacity: 0 },
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="tsconfig.scripts.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true
  },
  "ts-node": {
    "transpileOnly": true
  }
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'node',
    globals: true,
    include: ['**/__tests__/**/*.test.ts', '**/__tests__/**/*.test.tsx'],
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './'),
    },
  },
});
</file>

<file path="app/api/menu-categories/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';

// カテゴリ一覧取得API
export async function GET(request: NextRequest) {
  try {
    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // カテゴリ一覧を取得
    const { data: categories, error } = await supabase
      .from('menu_categories')
      .select('*')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true })
      .order('name', { ascending: true });

    if (error) {
      console.error('カテゴリ一覧取得エラー:', error);
      return NextResponse.json(
        { error: 'カテゴリ一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(categories);
  } catch (error) {
    console.error('カテゴリ一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

// カテゴリ作成API
export async function POST(request: NextRequest) {
  try {
    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得（スマレジ連携の確認）
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('enable_smaregi_integration')
      .eq('store_id', storeId)
      .single();

    if (storeError) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // スマレジ連携が有効の場合はエラー
    if (store.enable_smaregi_integration) {
      return NextResponse.json(
        { error: 'スマレジ連携が有効になっているため、カテゴリの追加はできません。スマレジで部門を登録した後、メニュー管理画面で「スマレジと同期」ボタンをクリックしてください。' },
        { status: 403 }
      );
    }

    // リクエストボディを取得
    const data = await request.json();

    // バリデーション
    if (!data.name) {
      return NextResponse.json(
        { error: 'カテゴリ名は必須です' },
        { status: 400 }
      );
    }

    // 全カテゴリを取得
    const { data: allCategories, error: categoriesError } = await supabase
      .from('menu_categories')
      .select('category_id, name, display_order')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true });

    if (categoriesError) {
      console.error('カテゴリ一覧取得エラー:', categoriesError);
    }

    console.log('既存カテゴリ:', allCategories);

    // 新規カテゴリの表示順を設定（既存カテゴリの数 + 1）
    const newDisplayOrder = allCategories && allCategories.length > 0 ? allCategories.length + 1 : 1;
    console.log('新規カテゴリの表示順:', newDisplayOrder);

    // 新規カテゴリを作成
    const { data: newCategory, error: createError } = await supabase
      .from('menu_categories')
      .insert({
        store_id: storeId,
        name: data.name,
        display_order: newDisplayOrder,
        smaregi_category_id: data.smaregi_category_id || null,
        allow_treat_cast: data.allow_treat_cast || false
      })
      .select()
      .single();

    if (createError) {
      // 一意制約違反の場合
      if (createError.code === '23505') {
        return NextResponse.json(
          { error: '同じ名前のカテゴリが既に存在します' },
          { status: 400 }
        );
      }

      console.error('カテゴリ作成エラー:', createError);
      return NextResponse.json(
        { error: 'カテゴリの作成に失敗しました' },
        { status: 500 }
      );
    }

    console.log('作成されたカテゴリ:', newCategory);

    // 作成後の全カテゴリを取得して確認（デバッグ用）
    const { data: updatedCategories } = await supabase
      .from('menu_categories')
      .select('category_id, name, display_order')
      .eq('store_id', storeId)
      .order('display_order', { ascending: true });

    console.log('更新後のカテゴリ一覧:', updatedCategories);

    return NextResponse.json(newCategory, { status: 201 });
  } catch (error) {
    console.error('カテゴリ作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/menus/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createServerSupabaseClient, createServerComponentClient } from '@/lib/supabase';
import { getUserRoleInStore } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // メニュー一覧を取得
    const { data: menus, error } = await supabase
      .from('menus')
      .select('*')
      .eq('store_id', storeId)
      .order('category', { ascending: true })
      .order('name', { ascending: true });

    if (error) {
      console.error('メニュー一覧取得エラー:', error);
      return NextResponse.json(
        { error: 'メニュー一覧の取得に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(menus);
  } catch (error) {
    console.error('メニュー一覧取得エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    // URLクエリパラメータからstore-idを取得
    const storeIdFromQuery = request.nextUrl.searchParams.get('storeId');

    // "null"文字列の場合はnullとして扱う
    const validStoreIdFromQuery = storeIdFromQuery === 'null' ? null : storeIdFromQuery;

    // Cookieからstore-idを取得
    const cookieStore = await cookies();
    const storeIdFromCookie = cookieStore.get('store-id')?.value;

    // クエリパラメータを優先し、なければCookieから取得
    const storeId = validStoreIdFromQuery || storeIdFromCookie;

    if (!storeId) {
      return NextResponse.json(
        { error: '店舗情報が見つかりません' },
        { status: 401 }
      );
    }

    // 認証用クライアント（Cookieベース）
    const authClient = await createServerComponentClient();

    // ユーザー情報を取得
    const { data: { user } } = await authClient.auth.getUser();

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    if (!user) {
      return NextResponse.json(
        { error: '認証されていません' },
        { status: 401 }
      );
    }

    // ユーザーの役割を取得
    const userRole = await getUserRoleInStore(user.id, storeId);

    // 管理者でなければエラー
    if (userRole !== 'admin') {
      return NextResponse.json(
        { error: '権限がありません' },
        { status: 403 }
      );
    }

    // 店舗情報を取得（スマレジ連携の確認）
    const { data: store, error: storeError } = await supabase
      .from('stores')
      .select('enable_smaregi_integration')
      .eq('store_id', storeId)
      .single();

    if (storeError) {
      console.error('店舗情報取得エラー:', storeError);
      return NextResponse.json(
        { error: '店舗情報の取得に失敗しました' },
        { status: 500 }
      );
    }

    // スマレジ連携が有効の場合はエラー
    if (store.enable_smaregi_integration) {
      return NextResponse.json(
        { error: 'スマレジ連携が有効になっているため、メニューの追加はできません。スマレジで商品を登録した後、メニュー管理画面で「スマレジと同期」ボタンをクリックしてください。' },
        { status: 403 }
      );
    }

    const data = await request.json();

    // バリデーション
    if (!data.product_id || !data.name || data.price < 0) {
      return NextResponse.json(
        { error: '必須項目が不足しているか、無効な値です' },
        { status: 400 }
      );
    }

    // store_idを確実に設定
    data.store_id = storeId;

    // 同じ店舗内で同じproduct_idが存在するかチェック
    const { data: existingMenu } = await supabase
      .from('menus')
      .select('menu_id')
      .eq('store_id', storeId)
      .eq('product_id', data.product_id)
      .maybeSingle();

    if (existingMenu) {
      return NextResponse.json(
        { error: 'この商品IDは既に使用されています' },
        { status: 409 }
      );
    }

    // 新規メニューを作成
    const { data: newMenu, error: createError } = await supabase
      .from('menus')
      .insert({
        store_id: data.store_id,
        product_id: data.product_id,
        name: data.name,
        description: data.description || null,
        price: data.price,
        image_url: data.image_url || null,
        category: data.category || null,
        category_id: data.category_id || null,
        is_available: data.is_available !== false,
      })
      .select()
      .single();

    if (createError) {
      console.error('メニュー作成エラー:', createError);
      return NextResponse.json(
        { error: 'メニューの作成に失敗しました' },
        { status: 500 }
      );
    }

    return NextResponse.json(newMenu, { status: 201 });
  } catch (error) {
    console.error('メニュー作成エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sessions/[session_id]/calculate-charge/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ session_id: string }> }
) {
  try {
    const { session_id } = await params;

    // データベース操作用クライアント
    const supabase = await createServerSupabaseClient();

    // セッション情報を取得
    const { data: session, error: sessionError } = await supabase
      .from('sessions')
      .select(`
        session_id,
        store_id,
        charge_started_at,
        charge_paused_at
      `)
      .eq('session_id', session_id)
      .single();

    if (sessionError || !session) {
      console.error('セッション取得エラー:', sessionError);
      return NextResponse.json(
        { error: 'セッションが見つかりません' },
        { status: 404 }
      );
    }

    // 課金が開始されていない場合は0を返す
    if (!session.charge_started_at) {
      return NextResponse.json({ charge_amount: 0 });
    }

    // テーブル料金を計算（データベース関数を使用）
    // fn_calc_total_charge関数は既にis_table_move_charge=trueのイベントの料金を含めて計算している
    const { data: totalChargeData, error: chargeError } = await supabase
      .rpc('fn_calc_total_charge', { p_session_id: session_id });

    if (chargeError) {
      console.error('テーブル料金計算エラー:', chargeError);

      // エラーが発生した場合は、代替の計算方法を使用
      // 席移動料金を取得
      let moveChargeAmount = 0;
      try {
        const { data: moveCharges, error: moveChargeError } = await supabase
          .from('session_seat_events')
          .select('price_snapshot')
          .eq('session_id', session_id)
          .eq('is_table_move_charge', true);

        if (!moveChargeError && moveCharges && moveCharges.length > 0) {
          for (const charge of moveCharges) {
            moveChargeAmount += charge.price_snapshot;
          }
        }
      } catch (error) {
        console.error('席移動料金取得例外:', error);
      }

      // 最後のイベントの情報を取得（席移動料金イベントを除く）
      try {
        const { data: lastEvent, error: lastEventError } = await supabase
          .from('session_seat_events')
          .select('seat_type_id, price_snapshot, changed_at')
          .eq('session_id', session_id)
          .eq('is_table_move_charge', false)
          .order('changed_at', { ascending: false })
          .limit(1)
          .single();

        if (!lastEventError && lastEvent) {
          // 席種の時間単位を取得
          const { data: seatType, error: seatTypeError } = await supabase
            .from('seat_types')
            .select('time_unit_minutes')
            .eq('seat_type_id', lastEvent.seat_type_id)
            .single();

          const timeUnitMinutes = seatType && seatType.time_unit_minutes > 0
            ? seatType.time_unit_minutes
            : 30;

          // 最後のイベントからの経過時間を計算（分単位）
          const now = session.charge_paused_at
            ? new Date(session.charge_paused_at)
            : new Date();
          const lastEventTime = new Date(lastEvent.changed_at);
          const elapsedMs = now.getTime() - lastEventTime.getTime();
          const elapsedMinutes = elapsedMs / (1000 * 60);

          // 時間単位で切り上げ
          const roundedMinutes = Math.ceil(elapsedMinutes / timeUnitMinutes) * timeUnitMinutes;

          // 時間単位の数を計算
          const timeUnits = roundedMinutes / timeUnitMinutes;

          // 現在のテーブルでの料金を計算
          const currentTableCharge = timeUnits * lastEvent.price_snapshot;

          // 合計料金を計算
          const totalCharge = moveChargeAmount + currentTableCharge;

          // 計算結果を返す
          return NextResponse.json({
            charge_amount: totalCharge,
            table_charge: currentTableCharge > 0 ? currentTableCharge : 0,
            move_charge: moveChargeAmount,
            calculated_by: 'fallback'
          });
        }
      } catch (error) {
        console.error('代替計算エラー:', error);
      }

      // 代替計算も失敗した場合はエラーを返す
      return NextResponse.json(
        { error: 'テーブル料金の計算に失敗しました' },
        { status: 500 }
      );
    }

    // 席移動による料金の内訳を取得（表示用）
    let moveChargeAmount = 0;
    try {
      // is_table_move_chargeフィールドが存在する場合
      const { data: moveCharges, error: moveChargeError } = await supabase
        .from('session_seat_events')
        .select('price_snapshot')
        .eq('session_id', session_id)
        .eq('is_table_move_charge', true);

      if (!moveChargeError && moveCharges && moveCharges.length > 0) {
        for (const charge of moveCharges) {
          moveChargeAmount += charge.price_snapshot;
        }
      }
    } catch (error) {
      console.error('席移動料金取得例外:', error);
      // エラーがあっても処理は続行
    }

    // 通常のテーブル料金（現在のテーブルでの料金）を計算
    const currentTableCharge = (totalChargeData || 0) - moveChargeAmount;

    // デバッグ情報をログに出力
    console.log('料金計算結果:', {
      totalChargeData,
      moveChargeAmount,
      currentTableCharge
    });

    return NextResponse.json({
      charge_amount: totalChargeData || 0,
      table_charge: currentTableCharge > 0 ? currentTableCharge : 0,
      move_charge: moveChargeAmount
    });
  } catch (error) {
    console.error('テーブル料金計算エラー:', error);
    return NextResponse.json(
      { error: '予期せぬエラーが発生しました' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/portal/layout.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import LayoutWrapper from './components/layout-wrapper';

// ナビゲーションリンク
interface NavLink {
  href: string;
  label: string;
  roles: ('admin' | 'cast')[];
}

const navLinks: NavLink[] = [
  { href: '/portal/dashboard', label: 'ダッシュボード', roles: ['admin', 'cast'] },
  { href: '/portal/order-board', label: '注文ボード', roles: ['admin', 'cast'] },
  { href: '/portal/proxy-order', label: '代理注文', roles: ['admin', 'cast'] },
  { href: '/portal/tables', label: 'テーブル管理', roles: ['admin'] },
  { href: '/portal/seat-types', label: '席種設定', roles: ['admin'] },
  { href: '/portal/casts', label: 'キャスト管理', roles: ['admin'] },
  { href: '/portal/menus', label: 'メニュー管理', roles: ['admin'] },
  { href: '/portal/menu-categories', label: 'カテゴリ管理', roles: ['admin'] },
  { href: '/portal/reports', label: 'レポート', roles: ['admin'] },
  { href: '/portal/store-settings', label: '店舗設定', roles: ['admin'] },
];

export default async function PortalLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    redirect('/');
  }

  // APIからユーザー情報を取得

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();

  // 認証トークンとstore-id（両方の形式）を確実に転送
  const authCookies = allCookies.filter(c => c.name.includes('-auth-token') || c.name === 'sb-refresh-token' || c.name === 'sb-access-token');
  const storeIdCookie = allCookies.find(c => c.name === 'store-id');
  const storeIdLegacyCookie = allCookies.find(c => c.name === 'storeId');

  // 必要なCookieのみを転送
  const essentialCookies = [];

  // 認証関連のCookieを追加
  authCookies.forEach(cookie => {
    essentialCookies.push(`${cookie.name}=${cookie.value}`);
  });

  // 店舗ID関連のCookieを追加（両方の形式）
  if (storeIdCookie) essentialCookies.push(`${storeIdCookie.name}=${storeIdCookie.value}`);
  if (storeIdLegacyCookie) essentialCookies.push(`${storeIdLegacyCookie.name}=${storeIdLegacyCookie.value}`);

  const cookieHeader = essentialCookies.join('; ');



  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    const errorText = await userResponse.text();
    console.error('Portal layout: ユーザー情報の取得に失敗しました', {
      status: userResponse.status,
      statusText: userResponse.statusText,
      error: errorText
    });
    redirect('/');
  }



  const { user } = await userResponse.json();
  const userRole = user.role;



  // 店舗情報をAPIから取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    redirect('/');
  }

  const store = await storeResponse.json();

  return (
    <LayoutWrapper
      navLinks={navLinks}
      userRole={userRole}
      storeName={store?.name || '店舗'}
      userEmail={user.email}
    >
      {children}
    </LayoutWrapper>
  );
}
</file>

<file path="app/portal/menu-categories/category-list.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

interface Category {
  category_id: string;
  name: string;
  display_order: number;
  smaregi_category_id?: string;
  allow_treat_cast: boolean;
}

interface CategoryListProps {
  categories: Category[];
  enableSmaregiIntegration: boolean;
}

export default function CategoryList({ categories: initialCategories, enableSmaregiIntegration }: CategoryListProps) {
  const router = useRouter();
  const [categories, setCategories] = useState<Category[]>(initialCategories);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [newCategoryName, setNewCategoryName] = useState('');
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);

  // カテゴリ作成
  const handleCreateCategory = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newCategoryName.trim()) return;

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch('/api/menu-categories', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: newCategoryName.trim(),
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'カテゴリの作成に失敗しました');
      }

      const newCategory = await response.json();
      setCategories([...categories, newCategory]);
      setNewCategoryName('');
      setSuccess('カテゴリを作成しました');
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'カテゴリの作成に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  // カテゴリ更新
  const handleUpdateCategory = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingCategory || !editingCategory.name.trim()) return;

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch(`/api/menu-categories/${editingCategory.category_id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: editingCategory.name.trim(),
          display_order: editingCategory.display_order,
          allow_treat_cast: editingCategory.allow_treat_cast,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'カテゴリの更新に失敗しました');
      }

      const updatedCategory = await response.json();
      setCategories(
        categories.map((cat) =>
          cat.category_id === updatedCategory.category_id ? updatedCategory : cat
        )
      );
      setEditingCategory(null);
      setSuccess('カテゴリを更新しました');
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'カテゴリの更新に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  // カテゴリ削除
  const handleDeleteCategory = async (categoryId: string) => {
    if (!confirm('このカテゴリを削除してもよろしいですか？')) return;

    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const response = await fetch(`/api/menu-categories/${categoryId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'カテゴリの削除に失敗しました');
      }

      // 削除後に最新のカテゴリ一覧を取得
      const refreshResponse = await fetch('/api/menu-categories');
      if (refreshResponse.ok) {
        const updatedCategories = await refreshResponse.json();
        // 最新のカテゴリ一覧で状態を更新
        setCategories(updatedCategories);
      } else {
        // APIからの取得に失敗した場合は、クライアント側で削除だけ反映
        setCategories(categories.filter((cat) => cat.category_id !== categoryId));
      }

      setSuccess('カテゴリを削除しました');
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'カテゴリの削除に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  // 表示順の変更
  const handleMoveCategory = async (categoryId: string, direction: 'up' | 'down') => {
    const currentIndex = categories.findIndex((cat) => cat.category_id === categoryId);
    if (currentIndex === -1) return;

    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    if (newIndex < 0 || newIndex >= categories.length) return;

    const newCategories = [...categories];
    const currentCategory = { ...newCategories[currentIndex] };
    const targetCategory = { ...newCategories[newIndex] };

    // 表示順を入れ替え
    const tempOrder = currentCategory.display_order;
    currentCategory.display_order = targetCategory.display_order;
    targetCategory.display_order = tempOrder;

    newCategories[currentIndex] = currentCategory;
    newCategories[newIndex] = targetCategory;

    setIsLoading(true);
    setError(null);

    try {
      // 現在のカテゴリの表示順を更新
      const response1 = await fetch(`/api/menu-categories/${currentCategory.category_id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: currentCategory.name,
          display_order: currentCategory.display_order,
          allow_treat_cast: currentCategory.allow_treat_cast,
        }),
      });

      if (!response1.ok) {
        const data = await response1.json();
        throw new Error(data.error || 'カテゴリの更新に失敗しました');
      }

      // 入れ替え先のカテゴリの表示順を更新
      const response2 = await fetch(`/api/menu-categories/${targetCategory.category_id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: targetCategory.name,
          display_order: targetCategory.display_order,
          allow_treat_cast: targetCategory.allow_treat_cast,
        }),
      });

      if (!response2.ok) {
        const data = await response2.json();
        throw new Error(data.error || 'カテゴリの更新に失敗しました');
      }

      // 表示順でソート
      setCategories([...newCategories].sort((a, b) => a.display_order - b.display_order));
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'カテゴリの更新に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="bg-white shadow rounded-lg p-6">
        <h2 className="text-lg font-medium text-gray-900 mb-4">カテゴリ一覧</h2>

        {error && (
          <div className="mb-4 p-4 text-sm text-red-700 bg-red-100 rounded-lg">
            {error}
          </div>
        )}

        {success && (
          <div className="mb-4 p-4 text-sm text-green-700 bg-green-100 rounded-lg">
            {success}
          </div>
        )}

        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  表示順
                </th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  カテゴリ名
                </th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  スマレジID
                </th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  キャストに奢れる
                </th>
                <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  操作
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {categories.length === 0 ? (
                <tr>
                  <td colSpan={5} className="px-6 py-4 text-center text-sm text-gray-500">
                    カテゴリがありません
                  </td>
                </tr>
              ) : (
                categories.map((category, index) => (
                  <tr key={category.category_id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <div className="flex items-center space-x-2">
                        <span>{category.display_order}</span>
                        <div className="flex flex-col">
                          <button
                            onClick={() => handleMoveCategory(category.category_id, 'up')}
                            disabled={index === 0 || isLoading}
                            className="text-gray-400 hover:text-gray-600 disabled:opacity-50"
                          >
                            ▲
                          </button>
                          <button
                            onClick={() => handleMoveCategory(category.category_id, 'down')}
                            disabled={index === categories.length - 1 || isLoading}
                            className="text-gray-400 hover:text-gray-600 disabled:opacity-50"
                          >
                            ▼
                          </button>
                        </div>
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                      {editingCategory?.category_id === category.category_id ? (
                        <input
                          type="text"
                          value={editingCategory.name}
                          onChange={(e) =>
                            setEditingCategory({ ...editingCategory, name: e.target.value })
                          }
                          className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                        />
                      ) : (
                        category.name
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {category.smaregi_category_id || '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {editingCategory?.category_id === category.category_id ? (
                        <input
                          type="checkbox"
                          checked={editingCategory.allow_treat_cast}
                          onChange={(e) =>
                            setEditingCategory({ ...editingCategory, allow_treat_cast: e.target.checked })
                          }
                          className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                        />
                      ) : (
                        <span className={category.allow_treat_cast ? "text-green-600" : "text-red-600"}>
                          {category.allow_treat_cast ? "可能" : "不可"}
                        </span>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      {editingCategory?.category_id === category.category_id ? (
                        <div className="flex justify-end space-x-2">
                          <button
                            onClick={handleUpdateCategory}
                            disabled={isLoading}
                            className="text-blue-600 hover:text-blue-900"
                          >
                            保存
                          </button>
                          <button
                            onClick={() => setEditingCategory(null)}
                            className="text-gray-600 hover:text-gray-900"
                          >
                            キャンセル
                          </button>
                        </div>
                      ) : (
                        <div className="flex justify-end space-x-2">
                          <button
                            onClick={() => setEditingCategory(category)}
                            className="text-blue-600 hover:text-blue-900"
                          >
                            編集
                          </button>
                          <button
                            onClick={() => handleDeleteCategory(category.category_id)}
                            className="text-red-600 hover:text-red-900"
                          >
                            削除
                          </button>
                        </div>
                      )}
                    </td>
                  </tr>
                ))
              )}
            </tbody>
          </table>
        </div>
      </div>

      {!enableSmaregiIntegration && (
        <div className="bg-white shadow rounded-lg p-6">
          <h2 className="text-lg font-medium text-gray-900 mb-4">新規カテゴリ作成</h2>
          <form onSubmit={handleCreateCategory} className="space-y-4">
            <div>
              <label htmlFor="name" className="block text-sm font-medium text-gray-700">
                カテゴリ名
              </label>
              <div className="mt-1">
                <input
                  type="text"
                  name="name"
                  id="name"
                  value={newCategoryName}
                  onChange={(e) => setNewCategoryName(e.target.value)}
                  className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                  required
                />
              </div>
            </div>
            <div>
              <button
                type="submit"
                disabled={isLoading || !newCategoryName.trim()}
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isLoading ? '作成中...' : '作成'}
              </button>
            </div>
          </form>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/portal/menu-categories/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import CategoryList from './category-list';

export const metadata = {
  title: 'メニューカテゴリ管理',
};

export default async function MenuCategoriesPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    redirect('/login');
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');

  // 店舗情報を取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    throw new Error('店舗情報の取得に失敗しました');
  }

  const store = await storeResponse.json();

  // APIからカテゴリ一覧を取得
  const response = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/menu-categories?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!response.ok) {
    throw new Error('カテゴリ一覧の取得に失敗しました');
  }

  const categories = await response.json();

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">メニューカテゴリ管理</h1>
        <p className="mt-2 text-sm text-gray-700">
          メニューのカテゴリを管理します。カテゴリはメニュー表示時のグループ分けに使用されます。
        </p>

        {store.enable_smaregi_integration && (
          <div className="mt-4">
            <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                  </svg>
                </div>
                <div className="ml-3">
                  <p className="text-sm text-yellow-700">
                    スマレジ連携が有効になっているため、カテゴリの追加はできません。カテゴリを追加するには、スマレジで部門を登録した後、メニュー管理画面で「スマレジと同期」ボタンをクリックしてください。
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}

        <div className="mt-6">
          <CategoryList
            categories={categories}
            enableSmaregiIntegration={store.enable_smaregi_integration}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/portal/menus/page.tsx">
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import Link from 'next/link';
import MenuList from './menu-list';
import SmaregiSyncButton from './smaregi-sync-button';

export default async function MenusPage() {
  const cookieStore = await cookies();
  const storeId = cookieStore.get('store-id')?.value;

  if (!storeId) {
    return <div>店舗情報が見つかりません</div>;
  }

  // 現在のリクエストのCookieをすべて取得して転送
  const allCookies = cookieStore.getAll();
  const cookieHeader = allCookies
    .map(cookie => `${cookie.name}=${cookie.value}`)
    .join('; ');



  // APIからユーザー情報を取得
  const userResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/auth/user?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  if (!userResponse.ok) {
    redirect('/');
  }

  const { user } = await userResponse.json();

  // 管理者でなければダッシュボードにリダイレクト
  if (user.role !== 'admin') {
    redirect('/portal/dashboard');
  }

  // 店舗情報を取得
  const storeResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/stores/${storeId}`, {
    cache: 'no-store'
  });

  if (!storeResponse.ok) {
    console.error('店舗情報の取得に失敗しました:', await storeResponse.text());
    return <div>店舗情報が見つかりません</div>;
  }

  const store = await storeResponse.json();

  // メニュー一覧をAPIから取得
  const menusResponse = await fetch(`${process.env.NEXT_PUBLIC_URL || ''}/api/menus?storeId=${storeId}`, {
    cache: 'no-store',
    headers: {
      'Cookie': cookieHeader
    }
  });

  let menus = [];
  if (menusResponse.ok) {
    menus = await menusResponse.json();
  } else {
    console.error('メニュー一覧の取得に失敗しました:', await menusResponse.text());
  }

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-semibold text-gray-900">メニュー管理</h1>
          <div className="flex space-x-4">
            {store.enable_smaregi_integration && (
              <SmaregiSyncButton
                storeId={storeId}
                enableSmaregiIntegration={store.enable_smaregi_integration}
              />
            )}
            {!store.enable_smaregi_integration ? (
              <Link
                href="/portal/menus/new"
                className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700"
              >
                メニューを追加
              </Link>
            ) : null}
          </div>
        </div>
      </div>
      {store.enable_smaregi_integration && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                  <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-yellow-700">
                  スマレジ連携が有効になっているため、メニューの追加はできません。メニューを追加するには、スマレジで商品を登録した後、「スマレジと同期」ボタンをクリックしてください。
                </p>
              </div>
            </div>
          </div>
        </div>
      )}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
        <MenuList menus={menus || []} />
      </div>
    </div>
  );
}
</file>

</files>
